let t,e,n={};n.name="WebObjects/Graphics3D",interpretate.contextExpand(n),["AlignmentPoint","AspectRatio","AutomaticImageSize","Axes","AxesEdge","AxesLabel","AxesOrigin","AxesStyle","Background","BaselinePosition","BaseStyle","Boxed","BoxRatios","BoxStyle","ClipPlanes","ClipPlanesStyle","ColorOutput","ContentSelectable","ControllerLinking","ControllerMethod","ControllerPath","CoordinatesToolOptions","DisplayFunction","Epilog","FaceGrids","FaceGridsStyle","FormatType","ImageMargins","ImagePadding","ImageSize","ImageSizeRaw","LabelStyle","Lighting","Method","PlotLabel","PlotRange","PlotRangePadding","PlotRegion","PreserveImageOptions","Prolog","RotationAction","SphericalRegion","Ticks","TicksStyle","TouchscreenAutoZoom","ViewAngle","ViewCenter","ViewMatrix","ViewPoint","ViewProjection","VertexTextureCoordinates","RTX","ViewRange","ViewVector","ViewVertical","Controls","PointerLockControls","VertexNormals","VertexColors"].map((t=>{n[t]=()=>t})),n.Void=(t,e)=>{console.warn(t),console.warn("went to the void...")},n.Void.update=()=>{},n.Void.destroy=()=>{},n.CapForm=n.Void,n.Appearance=n.Void;let i;n.LABColor=async(e,n)=>{let i;i=e.length>1?[await interpretate(e[0],n),await interpretate(e[1],n),await interpretate(e[2],n)]:await interpretate(e[0],n);const r=(t=>{var e,n,i,r=(t[0]+16)/116,a=t[1]/500+r,s=r-t[2]/200;return n=-.9689*(a=.95047*(a*a*a>.008856?a*a*a:(a-16/116)/7.787))+1.8758*(r=1*(r*r*r>.008856?r*r*r:(r-16/116)/7.787))+.0415*(s=1.08883*(s*s*s>.008856?s*s*s:(s-16/116)/7.787)),i=.0557*a+-.204*r+1.057*s,e=(e=3.2406*a+-1.5372*r+-.4986*s)>.0031308?1.055*Math.pow(e,1/2.4)-.055:12.92*e,n=n>.0031308?1.055*Math.pow(n,1/2.4)-.055:12.92*n,i=i>.0031308?1.055*Math.pow(i,1/2.4)-.055:12.92*i,[255*Math.max(0,Math.min(1,e)),255*Math.max(0,Math.min(1,n)),255*Math.max(0,Math.min(1,i))]})(i.map((t=>255*t)));return console.log("LAB color"),console.log(r),n.color=new t.Color(...r.map((t=>t/255))),e.length>3&&(n.opacity=await interpretate(e[3],n)),n.color},n.LABColor.update=()=>{},n.Style=core.List,n.Dashing=(t,e)=>{console.log("Dashing not implemented")},n.Annotation=core.List,n.GraphicsGroup=async(e,n)=>{const i=new t.Group;let r=Object.assign({},n);r.mesh=i;for(const t of e)await interpretate(t,r);n.mesh.add(i)},n.Metalness=(t,e)=>{e.metalness=interpretate(t[0],e)},n.Emissive=async(t,e)=>{const n={...e};await interpretate(t[0],n),e.emissive=n.color,t.length>1&&(e.emissiveIntensity=await interpretate(t[1],n))},n.Hue=async(e,n)=>{const i=await interpretate(e[0],n),r=100*await interpretate(e[1],n),a=100*await interpretate(e[2],n);return n.color=new t.Color(`hsl(${i}, ${r}%, ${a}%)`),n.color},n.RGBColor=async(e,n)=>{if(3!==e.length&&1!==e.length)return console.log("RGB format not implemented",e),void console.error("RGB values should be triple!");let i=[...e];1===e.length&&(i=await interpretate(e[0],n));const r=await interpretate(i[0],n),a=await interpretate(i[1],n),s=await interpretate(i[2],n);return n.color=new t.Color(r,a,s),n.color},n.Roughness=(t,e)=>{const n=interpretate(t[0],e);"number"!=typeof n&&console.error("Opacity must have number value!"),console.log(n),e.roughness=n},n.Opacity=(t,e)=>{var n=interpretate(t[0],e);"number"!=typeof n&&console.error("Opacity must have number value!"),console.log(n),e.opacity=n},n.ImageScaled=(t,e)=>{},n.Thickness=async(t,e)=>{e.thickness=await interpretate(t[0],e)},n.Arrowheads=async(t,e)=>{1==t.length||(e.arrowHeight=await interpretate(t[1],e)),e.arrowRadius=await interpretate(t[0],e)},n.TubeArrow=async(e,n)=>{console.log("Context test"),console.log(void 0);let i=1;e.length>1&&(i=await interpretate(e[1],n));const r=await interpretate(e[0],n),a=new n.material({color:n.color,transparent:!1,roughness:n.roughness,opacity:n.opacity,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity}),s=new t.Vector3(...r[0]),o=new t.Vector3(...r[1]),l=s.clone().addScaledVector(o,-1),c=new t.CylinderGeometry(i,i,l.length(),32,1),h=new t.Mesh(c,a),u=new t.ConeGeometry(n.arrowRadius,n.arrowHeight,32),d=new t.Mesh(u,a);d.position.y=l.length()/2+n.arrowHeight/2;let p=new t.Group;p.add(h,d);var m=.5*Math.PI,f=o.clone().add(s).divideScalar(2),g=new t.Matrix4,v=new t.Matrix4;return new t.Matrix4,g.lookAt(o,s,new t.Vector3(0,1,0)),v.makeRotationX(m),g.multiply(v),p.applyMatrix4(g),p.position.addScaledVector(f,1),n.mesh.add(p),c.dispose(),u.dispose(),a.dispose(),p},n.Arrow=async(e,n)=>{let i;if(1===e.length&&"Tube"===e[0][0]?(console.log("TUBE inside!"),i=await interpretate(e[0][1],n)):i=await interpretate(e[0],n),1===i.length&&(i=i[0]),2!==i.length)return void console.error("Tube must have 2 vectors!");const r=[new t.Vector4(...i[0],1),new t.Vector4(...i[1],1)];r.forEach((t=>{t=t.applyMatrix4(n.matrix)}));const a=r[0].clone(),s=r[1].add(r[0].negate()),o=new t.ArrowHelper(s.normalize(),a,s.length(),n.color);return o.castShadow=n.shadows,o.receiveShadow=n.shadows,n.PathRendering&&(o.line.material.emissive=n.emissive,o.cone.material.emissive=n.emissive,o.line.material.emissiveIntensity=n.emissiveIntensity,o.cone.material.emissiveIntensity=n.emissiveIntensity),n.mesh.add(o),o.line.material.linewidth=n.thickness,o},n.Tube=n.Arrow,n.Sphere=async(e,n)=>{var i=1;e.length>1&&(i=await interpretate(e[1],n));const r=new n.material({color:n.color,roughness:n.roughness,opacity:n.opacity,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity});function a(e){const a=new t.Vector4(...e,1),s=new t.SphereGeometry(i,40,40),o=new t.Mesh(s,r);return o.position.set(a.x,a.y,a.z),o.castShadow=n.shadows,o.receiveShadow=n.shadows,n.mesh.add(o),s.dispose(),o}let s=await interpretate(e[0],n);if(1===s.length&&(s=s[0]),1===s.length&&(s=s[0]),3===s.length)n.local.object=a(s);else{if(!(s.length>3))return console.log(s),void console.error("List of coords. for sphere object is less 1");n.local.multiple=!0,n.local.object=[],s.forEach((t=>{n.local.object.push(a(t))}))}return r.dispose(),n.local.object},n.Sphere.update=async(e,n)=>{console.log("Sphere: updating the data!"),n.wake();const i=await interpretate(e[0],n);if(n.Lerp){if(n.local.multiple){if(!n.local.lerp){console.log("creating worker for lerp of movements multiple..");const e={alpha:.05,target:i.map((e=>new t.Vector3(...e))),eval:()=>{for(let t=0;t<n.local.object.length;++t)n.local.object[t].position.lerp(e.target[t],.05)}};n.local.lerp=e,n.Handlers.push(e)}for(let t=0;t<i.length;++t)n.local.lerp.target[t].fromArray(i);return}if(!n.local.lerp){console.log("creating worker for lerp of movements..");const e={alpha:.05,target:new t.Vector3(...i),eval:()=>{n.local.object.position.lerp(e.target,.05)}};n.local.lerp=e,n.Handlers.push(e)}n.local.lerp.target.fromArray(i)}else if(n.local.multiple){let t=0;i.forEach((e=>{n.local.object[t].position.set(...e),++t}))}else n.local.object.position.set(...i)},n.Sphere.destroy=async(t,e)=>{console.log("Sphere: destroy")},n.Sphere.virtual=!0,n.Sky=(e,n)=>{const i=new a;i.scale.setScalar(1e4),n.mesh.add(i),n.sky=i,n.sun=new t.Vector3;const r=i.material.uniforms;r.turbidity.value=10,r.rayleigh.value=2,r.mieCoefficient.value=.005,r.mieDirectionalG.value=.8},n._Water=(e,n)=>{const i=new t.PlaneGeometry(1e4,1e4),a=new r(i,{textureWidth:512,textureHeight:512,waterNormals:(new t.TextureLoader).load("textures/waternormals.jpg",(function(e){e.wrapS=e.wrapT=t.RepeatWrapping})),sunDirection:new t.Vector3,sunColor:16777215,waterColor:7695,distortionScale:3.7,fog:!0});a.rotation.x=-Math.PI/2,n.mesh.add(a),n.water=a},n.Cuboid=async(e,n)=>{var i,r,a;if(2===e.length){var s=[new t.Vector4(...await interpretate(e[1],n),1),new t.Vector4(...await interpretate(e[0],n),1)];r=s[0].clone().add(s[1]).divideScalar(2),i=s[0].clone().add(s[1].clone().negate())}else{if(1!==e.length)return void console.error("Expected 2 or 1 arguments");a=await interpretate(e[0],n),r=new t.Vector4(...a,1),i=new t.Vector4(1,1,1,1),r.add(i.clone().divideScalar(2))}const o=new t.BoxGeometry(i.x,i.y,i.z),l=new n.material({color:n.color,transparent:!0,opacity:n.opacity,roughness:n.roughness,depthWrite:!0,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity}),c=new t.Mesh(o,l);return c.position.set(r.x,r.y,r.z),c.receiveShadow=n.shadows,c.castShadow=n.shadows,n.mesh.add(c),o.dispose(),l.dispose(),c},n.Center=(t,e)=>"Center",n.Cylinder=async(e,n)=>{let i=1;e.length>1&&(i=await interpretate(e[1],n));let r=await interpretate(e[0],n);1===r.length&&(r=r[0]),r[0]=new t.Vector3(...r[0]),r[1]=new t.Vector3(...r[1]);const a=new n.material({color:n.color,transparent:!1,roughness:n.roughness,opacity:n.opacity,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity});console.log(r);var s=(new t.Vector3).subVectors(r[1],r[0]);console.log(s);var o=new t.CylinderGeometry(i,i,s.length(),32,4,!1);o.applyMatrix4((new t.Matrix4).makeTranslation(0,s.length()/2,0)),o.applyMatrix4((new t.Matrix4).makeRotationX(t.MathUtils.degToRad(90)));var l=new t.Mesh(o,a);l.receiveShadow=n.shadows,l.castShadow=n.shadows,l.position.copy(r[0]),l.lookAt(r[1]),n.mesh.add(l)},n.Tetrahedron=async(t,e)=>{var n=await interpretate(t[0],e);console.log("Points of tetrahedron:"),console.log(n);var i=[[n[0],n[1],n[2]],[n[0],n[1],n[3]],[n[1],n[2],n[3]],[n[0],n[3],n[2]]],r=["List"],a=t=>["List",t[0],t[1],t[2]];return i.forEach((t=>{r.push(["Polygon",["List",a(t[0]),a(t[1]),a(t[2])]])})),console.log(r),await interpretate(r,e)},n.Translate=async(e,n)=>{let i=new t.Group,r=await interpretate(e[1],n),a=Object.assign({},n);a.mesh=i,await interpretate(e[0],a),i.translateX(r[0]),i.translateY(r[1]),i.translateZ(r[2]),n.local.mesh=i,n.mesh.add(i)},n.Translate.update=async(e,n)=>{n.wake();const i=await interpretate(e[1],n),r=n.local.mesh;if(n.Lerp){if(!n.local.lerp){console.log("creating worker for lerp of movements..");const e={alpha:.05,target:new t.Vector3(...i),eval:()=>{r.position.lerp(e.target,.05)}};n.local.lerp=e,n.Handlers.push(e)}n.local.lerp.target.fromArray(i)}else r.translateX(i[0]),r.translateY(i[1]),r.translateZ(i[2])},n.Translate.virtual=!0,n.LookAt=async(n,i)=>{const r=new t.Group,a=await interpretate(n[1],i);await interpretate(n[0],{...i,mesh:r});let s=(new t.Box3).setFromObject(r),o=s.max.clone().add(s.min).divideScalar(2);console.log("center: "),console.log(o);let l=(new t.Matrix4).makeTranslation(-o.x,-o.y,-o.z);r.applyMatrix4(l),r.lookAt(...a),r.rotation.x=e.PI/2,l=(new t.Matrix4).makeTranslation(o.x,o.y,o.z),r.applyMatrix4(l),i.local.group=r,i.mesh.add(r)},n.LookAt.update=async(t,e)=>{e.wake();const n=await interpretate(t[1],e);e.local.group.lookAt(...n)},n.LookAt.virtual=!0,n.GeometricTransformation=async(e,n)=>{var i=new t.Group,r=[...await interpretate(e[1],{...n,hold:!1})];let a;r[0][0]?(r.forEach((t=>{t.push(0)})),r.push([0,0,0,1])):n.local.translationOnly=!0,await interpretate(e[0],{...n,mesh:i}),a=n.local.translationOnly?(new t.Matrix4).makeTranslation(...r):(new t.Matrix4).set(...aflatten(r)),i.matrixAutoUpdate=!1,n.local.quaternion=new t.Quaternion,n.local.position=new t.Vector3,n.local.scale=new t.Vector3,a.decompose(n.local.position,n.local.quaternion,n.local.scale),i.quaternion.copy(n.local.quaternion),i.position.copy(n.local.position),i.scale.copy(n.local.scale),i.updateMatrix(),n.local.group=i,n.mesh.add(i)},n.GeometricTransformation.update=async(e,n)=>{n.wake();let i=[...await interpretate(e[1],{...n,hold:!1})];const r=n.local.group;if(!n.local.translationOnly){i.forEach((t=>{t.push(0)})),i.push([0,0,0,1]);(new t.Matrix4).set(...aflatten(i)).decompose(n.local.position,n.local.quaternion,n.local.scale)}if(n.Lerp){if(!n.local.lerp){console.log("creating worker for lerp of matrix movements..");const t={alpha:.05,quaternion:n.local.quaternion.clone(),scale:n.local.scale.clone(),position:n.local.position.clone(),eval:()=>{r.quaternion.slerp(t.quaternion,t.alpha),r.position.lerp(t.position,t.alpha),r.updateMatrix()}};n.local.lerp=t,n.Handlers.push(t)}n.local.translationOnly?n.local.lerp.position.copy(n.local.position.set(...i)):n.local.lerp.quaternion.copy(n.local.quaternion)}else n.local.translationOnly?r.position.copy(n.local.position.set(...i)):(r.quaternion.copy(n.local.quaternion),r.position.copy(n.local.position),r.scale.copy(n.local.scale)),r.updateMatrix(),n.mesh.add(r)},n.GeometricTransformation.virtual=!0,n.GraphicsComplex=async(e,n)=>{var i=Object.assign({},n);const r=await core._getRules(e,{...n,hold:!0}),a=(await interpretate(e[0],i)).flat();i.vertices=new Float32Array(a),"VertexColors"in r&&(i.vertexcolors=await interpretate(r.VertexColors,n));const s=new t.Group;await interpretate(e[1],i),n.mesh.add(s)},n.AbsoluteThickness=(t,e)=>{},n.Polygon=async(e,n)=>{var i=new t.BufferGeometry;let r,a;if(n.hasOwnProperty("vertices")){r=n.vertices;let t=await interpretate(e[0],n);if(3===t[0].length)i.setIndex(t.flat().map((t=>t-1)));else{let e=[];if(console.log(t),Array.isArray(t[0]))for(let n=0;n<t.length;++n){const i=t[n];switch(i.length){case 3:e.push([i[0],i[1],i[2]]);break;case 4:e.push([i[0],i[1],i[2]]),e.push([i[0],i[2],i[3]]);break;case 5:e.push([i[0],i[1],i[4]]),e.push([i[1],i[2],i[3]]),e.push([i[1],i[3],i[4]]);break;case 6:e.push([i[0],i[1],i[5]]),e.push([i[1],i[2],i[5]]),e.push([i[5],i[2],i[4]]),e.push([i[2],i[3],i[4]]);break;default:console.error("cannot build complex polygon")}}else e=t.flat();i.setIndex(e.flat().map((t=>t-1)))}}else{let t=await interpretate(e[0],n);switch(r=new Float32Array(t.flat()),console.log("points"),console.log(t),t.length){case 3:i.setIndex([0,1,2]);break;case 4:i.setIndex([0,1,2,0,2,3]);break;case 5:i.setIndex([0,1,4,1,2,3,1,3,4]);break;case 6:i.setIndex([0,1,5,1,2,5,5,2,4,2,3,4]);break;default:console.log(t),console.error("Cant build complex polygon ::")}}i.setAttribute("position",new t.BufferAttribute(r,3)),i.computeVertexNormals(),n.vertexcolors?(console.log("vertex colors"),i.setAttribute("color",new t.Float32BufferAttribute(new Float32Array(n.vertexcolors.flat()),3)),console.log(n.material),
//!!! a bug. Cannot work with PhysicalBasedMaterial
a=new t.MeshBasicMaterial({vertexColors:!0,transparent:n.opacity<1,opacity:n.opacity,roughness:n.roughness,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity})):a=new n.material({color:n.color,transparent:n.opacity<1,opacity:n.opacity,roughness:n.roughness,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity}),console.log(n.opacity),a.side=t.DoubleSide;const s=new t.Mesh(i,a);return s.receiveShadow=n.shadows,s.castShadow=!0,n.mesh.add(s),a.dispose(),s},n.Polyhedron=async(e,n)=>{if(e[1][1].length>4)return await interpretate(["GraphicsComplex",e[0],["Polygon",e[1]]],n);{const r=await interpretate(e[1],n).flat(4).map((t=>t-1)),a=await interpretate(e[0],n).flat(4),s=new t.PolyhedronGeometry(a,r);var i=new n.material({color:n.color,transparent:!0,opacity:n.opacity,depthWrite:!0,roughness:n.roughness,metalness:n.metalness,emissive:n.emissive,emissiveIntensity:n.emissiveIntensity});const o=new t.Mesh(s,i);return o.receiveShadow=n.shadows,o.castShadow=n.shadows,n.mesh.add(o),s.dispose(),i.dispose(),o}},n.GrayLevel=(t,e)=>{},n.EdgeForm=(t,e)=>{},n.Specularity=(t,e)=>{},n.Text=(t,e)=>{},n.Directive=(t,e)=>{},n.PlaneGeometry=()=>{new t.PlaneGeometry},n.Line=async(e,n)=>{var i=new t.BufferGeometry;let r;if(n.hasOwnProperty("vertices")){r=n.vertices;let a=await interpretate(e[0],n);i.setIndex(a.flat().map((t=>t-1))),i.setAttribute("position",new t.BufferAttribute(r,3))}else{const r=await interpretate(e[0],n),a=[];for(let e=0;e<r.length;++e)a.push((new t.Vector3).fromArray(r[e]));console.log(r),i.setFromPoints(a)}const a=new t.LineBasicMaterial({linewidth:n.thickness,color:n.edgecolor,opacity:n.opacity,transparent:n.opacity<1}),s=new t.Line(i,a);return n.mesh.add(s),s},n.ImageSize=()=>"ImageSize",n.Background=()=>"Background",n.AspectRatio=()=>"AspectRatio",n.Lighting=()=>"Lighting",n.Default=()=>"Default",n.None=()=>"None",n.Lightmap=()=>"Lightmap",n.Automatic=()=>"Automatic";let r=!1,a=!1;n.Camera=(t,e)=>{console.warn("temporary disabled")},n.Reflectivity=(t,e)=>{e.reflectivity=interpretate(t[0],e)},n.IOR=(t,e)=>{e.ior=interpretate(t[0],e)},n.Clearcoat=(t,e)=>{e.clearcoat=interpretate(t[0],e)},n.LightProbe=(t,e)=>{},n.DefaultLighting=(t,e)=>{console.warn("temporary disabled")},n.SkyAndWater=async(t,e)=>{console.warn("temporary disabled")},n.Sky=async(t,e)=>{console.warn("temporary disabled")},n.Water=async(e,n)=>{r||(r=(await Promise.resolve().then((function(){return Dd}))).Water);let i,a=await core._getRules(e,n);console.log("options:"),console.log(a),a.dims=a.Size||[1e4,1e4];const s=new t.PlaneGeometry(...a.dims);i=new r(s,{textureWidth:512,textureHeight:512,waterNormals:(new t.TextureLoader).load("https://cdn.statically.io/gh/JerryI/Mathematica-ThreeJS-graphics-engine/master/assets/waternormals.jpg",(function(e){e.wrapS=e.wrapT=t.RepeatWrapping})),sunDirection:new t.Vector3(1,1,1),sunColor:16777215,waterColor:7695,distortionScale:3.7,fog:!0}),i.rotation.x=-Math.PI/2,n.local.water=i,n.local.scene.add(i);const o=n.local.sun||new t.Vector3(1,1,1);i.material.uniforms.sunDirection.value.copy(o).normalize(),n.local.handlers.push((function(){n.local.water.material.uniforms.time.value+=1/60}))},n.Large=(t,e)=>1;let s={};n.PointLight=async(e,n)=>{const i={...n},r=await core._getRules(e,{...n,hold:!0});console.log(r);let a=16777215;e.length-r.length>0&&(a=await interpretate(e[0],i));let s=1;e.length-r.length>1&&(s=await interpretate(e[1],n));let o=0;e.length-r.length>2&&(o=await interpretate(e[2],n));let l=2;e.length-r.length>3&&(l=await interpretate(e[3],n));let c=[0,0,10];r.Position&&(c=await interpretate(r.Position,n)),console.log(c),console.log(a);const h=new t.PointLight(a,s,o,l);return h.castShadow=n.shadows,h.position.set(...c),n.local.light=h,n.mesh.add(h),h},n.PointLight.update=async(e,n)=>{n.wake();const i=await core._getRules(e,{...n,hold:!0});if(i.Position){const e=await interpretate(i.Position,n);if(n.Lerp){if(!n.local.lerp){console.log("creating worker for lerp of movements..");const i={alpha:.05,target:new t.Vector3(...e),eval:()=>{n.local.light.position.lerp(i.target,.05)}};n.local.lerp=i,n.Handlers.push(i)}return void n.local.lerp.target.fromArray(e)}n.local.light.position.set(...e)}},n.PointLight.destroy=async(t,e)=>{console.log("PointLight destroyed")},n.PointLight.virtual=!0,n.SpotLight=async(e,n)=>{const i={...n},r=await core._getRules(e,{...n,hold:!0});console.log(r);let a=16777215;e.length-r.length>0&&(a=await interpretate(e[0],i));let s=1;e.length-r.length>1&&(s=await interpretate(e[1],n));let o=0;e.length-r.length>2&&(o=await interpretate(e[2],n));let l=Math.PI/3;e.length-r.length>3&&(l=await interpretate(e[3],n));let c=0;e.length-r.length>4&&(c=await interpretate(e[4],n));let h=2;e.length-r.length>5&&(h=await interpretate(h[5],n));let u=[10,10,100];r.Position&&(u=await interpretate(r.Position,n)),console.log(u);let d=[0,0,0];r.Target&&(d=await interpretate(r.Target,n)),console.log(d);const p=new t.SpotLight(a,s,o,l,c,h);return p.position.set(...u),p.target.position.set(...d),p.castShadow=n.shadows,n.local.spotLight=p,n.mesh.add(p),n.mesh.add(p.target),p},n.SpotLight.update=async(e,n)=>{n.wake();const i=await core._getRules(e,{...n,hold:!0});if(i.Position){const e=await interpretate(i.Position,n);if(n.Lerp){if(!n.local.lerp1){console.log("creating worker for lerp of movements..");const i={alpha:.05,target:new t.Vector3(...e),eval:()=>{n.local.spotLight.position.lerp(i.target,.05)}};n.local.lerp1=i,n.Handlers.push(i)}n.local.lerp1.target.fromArray(e)}else n.local.spotLight.position.set(...e)}if(i.Target){const e=await interpretate(i.Target,n);if(n.Lerp){if(!n.local.lerp2){console.log("creating worker for lerp of movements..");const i={alpha:.05,target:new t.Vector3(...e),eval:()=>{n.local.spotLight.target.position.lerp(i.target,.05)}};n.local.lerp2=i,n.Handlers.push(i)}n.local.lerp2.target.fromArray(e)}else n.local.spotLight.target.position.set(...e)}},n.SpotLight.destroy=async(t,e)=>{console.log("SpotLight destoyed")},n.SpotLight.virtual=!0,n.Shadows=async(t,e)=>{e.shadows=await interpretate(t[0],e)},n.HemisphereLight=async(e,n)=>{const i={...n};e.length>0?await interpretate(e[0],i):i.color=16777147;const r=i.color;e.length>1?await interpretate(e[1],i):i.color=526368;const a=i.color;e.length>2&&await interpretate(e[1],n);const s=new t.HemisphereLight(r,a,2);n.local.scene.add(s)},n.MeshMaterial=async(t,e)=>{const n=await interpretate(t[0],e);e.material=n},n.MeshPhysicalMaterial=()=>t.MeshPhysicalMaterial,n.MeshLambertMaterial=()=>t.MeshLambertMaterial,n.MeshPhongMaterial=()=>t.MeshPhongMaterial,n.MeshToonMaterial=()=>t.MeshToonMaterial;let o,l,c,h=!1;n.EventListener=async(t,e)=>{const i=await interpretate(t[1],e),r={...e},a=await interpretate(t[0],e);return h||(h=(await Promise.resolve().then((function(){return up}))).TransformControls),i.forEach((t=>{n.EventListener[t.lhs](t.rhs,a,r)})),null},n.EventListener.transform=(t,e,n)=>{console.log(n.camera);const i=new h(n.camera,n.local.renderer.domElement),r=n.controlObject.o;i.attach(e),n.local.scene.add(i);const a=throttle(((e,n,i)=>{server.kernel.emitt(t,`<|"position"->{${e}, ${n}, ${i}}|>`,"transform")}));i.addEventListener("change",(function(t){a(e.position.x,e.position.y,e.position.z)})),i.addEventListener("dragging-changed",(function(t){console.log("changed"),r.enabled=!t.value}))},core.Graphics3D=async(r,a)=>{t=await Promise.resolve().then((function(){return Ld})),l=(await Promise.resolve().then((function(){return _p}))).OrbitControls,i=(await Promise.resolve().then((function(){return Lm}))).GUI,o=(await Promise.resolve().then((function(){return Dm}))).RGBELoader,c=(await Promise.resolve().then((function(){return Fm}))).FullScreenQuad,e=t.MathUtils;let h=!1,u=performance.now(),d=await core._getRules(r,{...a,context:n,hold:!0});console.log(d),0===Object.keys(d).length&&r.length>1&&(d=await core._getRules(r[1],{...a,context:n,hold:!0}));let p=!1;"RTX"in d&&(p=!0,s=await Promise.resolve().then((function(){return Cv}))),a.local.handlers=[],a.local.prolog=[];const m=[],f=a.element,g=await(async(t,e)=>{let n;return t.ImageSize?(n=await interpretate(t.ImageSize,e),n instanceof Array||(n=[n,.618034*n])):n=[core.DefaultWidth,.618034*core.DefaultWidth],n})(d,a),v={multipleImportanceSampling:!0,stableNoise:!1,denoiseEnabled:!0,denoiseSigma:2.5,denoiseThreshold:.1,denoiseKSigma:1,environmentIntensity:1,environmentRotation:0,environmentBlur:0,backgroundBlur:0,bounces:5,samplesPerFrame:1,acesToneMapping:!0,resolutionScale:.5,transparentTraversals:20,filterGlossyFactor:.5,tiles:1,backgroundAlpha:1,checkerboardTransparency:!0,cameraProjection:"Orthographic"};d.ViewProjection&&(v.cameraProjection=await interpretate(d.ViewProjection,a)),p||(v.resolutionScale=1);const _=new i({autoPlace:!1,name:"...",closed:!0}),y=document.createElement("div");y.classList.add("graphics3d-controller"),y.appendChild(_.domElement),f.appendChild(y);const x={Save:function(){et(),b.domElement.toBlob((function(t){var e=document.createElement("a"),n=URL.createObjectURL(t);e.href=n,e.download="screenshot.png",e.click()}),"image/png",1)}};let b,w,M,S,T,E,A,R,C,P,I,L,D;_.add(x,"Save");b=new t.WebGLRenderer({antialias:!0}),b.toneMapping=t.ACESFilmicToneMapping,b.outputEncoding=t.sRGBEncoding,b.setClearColor(0,0),f.appendChild(b.domElement);const N=g[0]/g[1];p?(A=new s.PhysicalCamera(75,N,.025,500),A.position.set(-4,2,3)):(A=new t.PerspectiveCamera(75,N,.025,500),b.shadowMap.enabled=!0);const O=()=>{u=performance.now(),h&&a.local.wakeThreadUp()},U=5/N;R=new t.OrthographicCamera(-2.5,2.5,U/2,U/-2,0,100),R.position.set(-4,2,3),S=R,p&&(C=new s.EquirectCamera,C.position.set(-4,2,3),M=new s.PathTracingRenderer(b),M.alpha=!0,M.material=new s.PhysicalPathTracingMaterial,M.material.setDefine("TRANSPARENT_TRAVERSALS",v.transparentTraversals),M.material.setDefine("FEATURE_MIS",Number(v.multipleImportanceSampling)),M.tiles.set(v.tiles,v.tiles),T=new c(new t.MeshBasicMaterial({map:M.target.texture,blending:t.CustomBlending,premultipliedAlpha:b.getContextAttributes().premultipliedAlpha})),E=new c(new s.DenoiseMaterial({map:M.target.texture,blending:t.CustomBlending,premultipliedAlpha:b.getContextAttributes().premultipliedAlpha})));let F={init:(t,e)=>{F.o=new l(t,b.domElement),F.o.addEventListener("change",O),F.o.target.set(0,1,0),F.o.update()},dispose:()=>{}};if(d.Controls&&"PointerLockControls"===await interpretate(d.Controls,a)){const e=(await Promise.resolve().then((function(){return zv}))).PointerLockControls;F={init:(t,n)=>{F.o=new e(t,n),a.local.scene.add(F.o.getObject()),F.o.addEventListener("change",O),F.onKeyDown=function(t){switch(t.code){case"ArrowUp":case"KeyW":F.moveForward=!0;break;case"ArrowLeft":case"KeyA":F.moveLeft=!0;break;case"ArrowDown":case"KeyS":F.moveBackward=!0;break;case"ArrowRight":case"KeyD":F.moveRight=!0;break;case"Space":!0===F.canJump&&(F.velocity.y+=20),F.canJump=!1}return t.preventDefault(),t.returnValue=!1,t.cancelBubble=!0,!1},F.onKeyUp=function(t){switch(t.code){case"ArrowUp":case"KeyW":F.moveForward=!1;break;case"ArrowLeft":case"KeyA":F.moveLeft=!1;break;case"ArrowDown":case"KeyS":F.moveBackward=!1;break;case"ArrowRight":case"KeyD":F.moveRight=!1}return t.preventDefault(),t.returnValue=!1,t.cancelBubble=!0,!1},a.local.handlers.push(F.handler);const i=document.createElement("div");i.style.width="100%",i.style.height="100%",i.style.top="0",i.style.position="absolute",a.element.appendChild(i),b.domElement.addEventListener("keydown",F.onKeyDown),b.domElement.addEventListener("keyup",F.onKeyUp),b.domElement.tabIndex=1,i.addEventListener("click",(function(){F.o.lock()})),F.o.addEventListener("lock",(function(){i.style.display="none"})),F.o.addEventListener("unlock",(function(){i.style.display=""}))},prevTime:performance.now(),handler:()=>{const t=performance.now(),e=F.o;if(!0===e.isLocked){const n=(t-F.prevTime)/1e3;F.velocity.x-=10*F.velocity.x*n,F.velocity.z-=10*F.velocity.z*n,F.velocity.y-=39.2*n,F.direction.z=Number(F.moveForward)-Number(F.moveBackward),F.direction.x=Number(F.moveRight)-Number(F.moveLeft),F.direction.normalize(),(F.moveForward||F.moveBackward)&&(F.velocity.z-=40*F.direction.z*n),(F.moveLeft||F.moveRight)&&(F.velocity.x-=40*F.direction.x*n),e.moveRight(-F.velocity.x*n),e.moveForward(-F.velocity.z*n),e.getObject().position.y+=F.velocity.y*n,e.getObject().position.y<.3&&(F.velocity.y=0,e.getObject().position.y=.3,F.canJump=!0)}F.prevTime=t},moveBackward:!1,moveForward:!1,moveLeft:!1,moveRight:!1,canJump:!1,velocity:new t.Vector3,direction:new t.Vector3,dispose:()=>{document.removeEventListener("keydown",F.onKeyDown),document.removeEventListener("keyup",F.onKeyUp)}}}a.local.controlObject=F,F.init(S,b.domElement),w=F.o,a.local.controlObject=F,a.local.renderer=b,p&&w.addEventListener("change",(()=>{M.reset()})),L=new t.Scene;const B=new t.Group,z={...a,context:n,numerical:!0,tostring:!1,matrix:(new t.Matrix4).set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),material:t.MeshPhysicalMaterial,color:new t.Color(1,1,1),opacity:1,thickness:1,roughness:.5,edgecolor:new t.Color(0,0,0),mesh:B,metalness:0,emissive:new t.Color(0,0,0),emissiveIntensity:1,arrowHeight:20,arrowRadius:5,reflectivity:.5,clearcoat:0,shadows:!1,Lerp:d.Lerp||!0,camera:S,controlObject:F,Handlers:m,wake:O};a.local.wakeThreadUp=()=>{h&&(h=!1,console.warn("g3d >> waking up!"),G())},a.local.renderer=b,a.local.scene=L,z.camera=S,a.local.element=f,p&&(z.PathRendering=!0),await interpretate(r[0],z);var k=(new t.Box3).setFromObject(B);if(B.position.set(-(k.min.x+k.max.x)/2,-(k.min.y+k.max.y)/2,0),d.BoxRatios||d.Boxed){const t=[[[k.min.x,k.min.y,k.min.z],[k.max.x,k.min.y,k.min.z],[k.max.x,k.max.y,k.min.z],[k.min.x,k.max.y,k.min.z],[k.min.x,k.min.y,k.min.z]],[[k.min.x,k.min.y,k.max.z],[k.max.x,k.min.y,k.max.z],[k.max.x,k.max.y,k.max.z],[k.min.x,k.max.y,k.max.z],[k.min.x,k.min.y,k.max.z]],[[k.min.x,k.min.y,k.min.z],[k.min.x,k.min.y,k.max.z]],[[k.max.x,k.min.y,k.min.z],[k.max.x,k.min.y,k.max.z]],[[k.max.x,k.max.y,k.min.z],[k.max.x,k.max.y,k.max.z]],[[k.min.x,k.max.y,k.min.z],[k.min.x,k.max.y,k.max.z]]];for(const e of t)await interpretate(["Line",["JSObject",e]],{...z,opacity:.5})}let H,G;if(B.applyMatrix4((new t.Matrix4).set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1)),L.add(B),L.updateMatrixWorld(),"Lighting"in d||(e=>{const n=new t.PointLight(16777215,2,10);n.position.set(0,10,0),e.add(n);var i=new t.HemisphereLight(16777147,526368,2);e.add(i)})(L),p&&(I=new s.BlurredEnvMapGenerator(b)),"Lightmap"in d){const e=await interpretate(d.Lightmap,a);H=(new o).setDataType(t.FloatType).loadAsync(e).then((t=>{if(p&&(P=t,Q()),p)return;const e=V.fromEquirectangular(t).texture;L.environment=e,L.background=e,t.dispose(),V.dispose()}))}if(!p){var V=new t.PMREMGenerator(b);V.compileEquirectangularShader()}if(p){var W=new s.PathTracingSceneGenerator(L).generate(L),{bvh:j,textures:X,materials:q}=W,Y=j.geometry,Z=M.material;Z.bvh.updateFrom(j),Z.attributesArray.updateFrom(Y.attributes.normal,Y.attributes.tangent,Y.attributes.uv,Y.attributes.color),Z.materialIndexAttribute.updateFrom(Y.attributes.materialIndex),Z.textures.setTextures(b,2048,2048,X),Z.materials.updateFrom(q,X)}function J(){const t=g[0],e=g[1],n=v.resolutionScale,i=window.devicePixelRatio;p&&(M.setSize(t*n*i,e*n*i),M.reset()),b.setSize(t,e),b.setPixelRatio(window.devicePixelRatio*n);const r=t/e;A.aspect=r,A.updateProjectionMatrix();const a=5/r;R.top=a/2,R.bottom=a/-2,R.updateProjectionMatrix()}function K(){p&&M.reset()}function Q(){const t=I.generate(P,v.environmentBlur);M.material.envMapInfo.updateFrom(t),L.environment=t,M.reset()}function $(t){"Perspective"===t?(S&&A.position.copy(S.position),S=A):"Orthographic"===t&&(S&&R.position.copy(S.position),S=R),w.object=S,p&&(M.camera=S),w.update(),a.local.camera=S,z.camera=S,K()}function tt(){O(),p&&(M.material.materials.updateFrom(W.materials,W.textures),M.material.filterGlossyFactor=v.filterGlossyFactor,M.material.environmentIntensity=v.environmentIntensity,M.material.backgroundBlur=v.backgroundBlur,M.material.bounces=v.bounces,M.material.backgroundAlpha=v.backgroundAlpha,M.material.physicalCamera.updateFrom(S)),S.updateMatrixWorld(),v.backgroundAlpha<1?L.background=null:L.background=L.environment}function et(){if(p){S.updateMatrixWorld(),void 0===D&&(D=b.info.programs.length);for(let t=0,e=v.samplesPerFrame;t<e;t++)M.update();E.material.sigma=v.denoiseSigma,E.material.threshold=v.denoiseThreshold,E.material.kSigma=v.denoiseKSigma;const t=v.denoiseEnabled?E:T;b.autoClear=!1,t.material.map=M.target.texture,t.render(b),b.autoClear=!0}else b.render(L,S);for(let t=0;t<m.length;++t)m[t].eval();a.local.handlers.forEach((t=>{t()}))}if("Lightmap"in d&&await Promise.all([H]),G=p?()=>{et(),a.local.aid=requestAnimationFrame(G)}:()=>{et(),performance.now()-u>1e3?(h=!0,console.warn("g3d >> Sleeping...")):a.local.aid=requestAnimationFrame(G)},J(),$(v.cameraProjection),p){const t=_.addFolder("Path Tracing");t.add(v,"stableNoise").onChange((t=>{M.stableNoise=t,tt()})),t.add(v,"multipleImportanceSampling").onChange((t=>{M.material.setDefine("FEATURE_MIS",Number(t)),M.reset(),tt()})),t.add(v,"tiles",1,4,1).onChange((t=>{M.tiles.set(t,t),tt()})),t.add(v,"samplesPerFrame",1,10,1),t.add(v,"filterGlossyFactor",0,1).onChange((()=>{M.reset(),tt()})),t.add(v,"bounces",1,30,1).onChange((()=>{M.reset(),tt()})),t.add(v,"transparentTraversals",0,40,1).onChange((t=>{M.material.setDefine("TRANSPARENT_TRAVERSALS",t),M.reset(),tt()})),t.add(v,"resolutionScale",.1,1).onChange((()=>{J()}));const e=_.addFolder("Denoising");e.add(v,"denoiseEnabled").onChange(tt),e.add(v,"denoiseSigma",.01,12).onChange(tt),e.add(v,"denoiseThreshold",.01,1).onChange(tt),e.add(v,"denoiseKSigma",0,12).onChange(tt),e.close();const n=_.addFolder("Environment");n.add(v,"environmentIntensity",0,10).onChange((()=>{M.reset(),tt()})),n.add(v,"environmentRotation",0,2*Math.PI).onChange((t=>{M.material.environmentRotation.makeRotationY(t),M.reset(),tt()})),n.add(v,"environmentBlur",0,1).onChange((()=>{Q(),tt()})),n.add(v,"backgroundBlur",0,1).onChange((()=>{M.reset(),tt()})),n.add(v,"backgroundAlpha",0,1).onChange((()=>{M.reset(),tt()})),n.close()}const nt=_.addFolder("Camera");nt.add(v,"cameraProjection",["Perspective","Orthographic"]).onChange((t=>{$(t),tt()})),nt.add(v,"acesToneMapping").onChange((e=>{b.toneMapping=e?t.ACESFilmicToneMapping:t.NoToneMapping,p&&(T.material.needsUpdate=!0),tt()})),p&&(nt.add(A,"focusDistance",1,100).onChange(K),nt.add(A,"apertureBlades",0,10,1).onChange((function(t){A.apertureBlades=0===t?0:Math.max(t,3),this.updateDisplay(),K(),tt()})),nt.add(A,"apertureRotation",0,12.5).onChange(K),nt.add(A,"anamorphicRatio",.1,10).onChange(K),nt.add(A,"bokehSize",0,50).onChange(K).listen(),nt.add(A,"fStop",.3,20).onChange(K).listen(),nt.add(A,"fov",25,100).onChange((()=>{A.updateProjectionMatrix(),K(),tt()})).listen()),nt.close(),G()},core.Graphics3D.destroy=(t,e)=>{console.log("Graphics3D was removed"),console.log("env global:"),console.log(e.global),console.log("env local:"),console.log(e.local),e.local.wakeThreadUp=()=>{},e.local.controlObject.dispose(),cancelAnimationFrame(e.local.aid)};
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const u="160",d={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},p={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},m=1,f=2,g=3,v=0,_=1,y=2,x=100,b=204,w=205,M=0,S=1,T=2,E=0,A=1,R=2,C=3,P=4,I=5,L=6,D="attached",N="detached",O=300,U=301,F=302,B=303,z=304,k=306,H=1e3,G=1001,V=1002,W=1003,j=1004,X=1005,q=1006,Y=1007,Z=1008,J=1009,K=1010,Q=1011,$=1012,tt=1013,et=1014,nt=1015,it=1016,rt=1017,at=1018,st=1020,ot=1023,lt=1026,ct=1027,ht=1028,ut=1029,dt=1030,pt=1031,mt=1033,ft=33776,gt=33777,vt=33778,_t=33779,yt=35840,xt=35841,bt=35842,wt=35843,Mt=36196,St=37492,Tt=37496,Et=37808,At=37809,Rt=37810,Ct=37811,Pt=37812,It=37813,Lt=37814,Dt=37815,Nt=37816,Ot=37817,Ut=37818,Ft=37819,Bt=37820,zt=37821,kt=36492,Ht=36494,Gt=36495,Vt=36284,Wt=36285,jt=36286,Xt=2300,qt=2301,Yt=2302,Zt=2400,Jt=2401,Kt=2402,Qt=2500,$t=2501,te=3e3,ee=3001,ne="",ie="srgb",re="srgb-linear",ae="display-p3",se="display-p3-linear",oe="linear",le="srgb",ce="rec709",he="p3",ue=7680,de=35044,pe="300 es",me=1035,fe=2e3,ge=2001;class ve{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,i=n.length;e<i;e++)n[e].call(this,t);t.target=null}}}const _e=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let ye=1234567;const xe=Math.PI/180,be=180/Math.PI;function we(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,i=4294967295*Math.random()|0;return(_e[255&t]+_e[t>>8&255]+_e[t>>16&255]+_e[t>>24&255]+"-"+_e[255&e]+_e[e>>8&255]+"-"+_e[e>>16&15|64]+_e[e>>24&255]+"-"+_e[63&n|128]+_e[n>>8&255]+"-"+_e[n>>16&255]+_e[n>>24&255]+_e[255&i]+_e[i>>8&255]+_e[i>>16&255]+_e[i>>24&255]).toLowerCase()}function Me(t,e,n){return Math.max(e,Math.min(n,t))}function Se(t,e){return(t%e+e)%e}function Te(t,e,n){return(1-n)*t+n*e}function Ee(t){return 0==(t&t-1)&&0!==t}function Ae(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function Re(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Ce(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const Pe={DEG2RAD:xe,RAD2DEG:be,generateUUID:we,clamp:Me,euclideanModulo:Se,mapLinear:function(t,e,n,i,r){return i+(t-e)*(r-i)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:Te,damp:function(t,e,n,i){return Te(t,e,1-Math.exp(-n*i))},pingpong:function(t,e=1){return e-Math.abs(Se(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(ye=t);let e=ye+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*xe},radToDeg:function(t){return t*be},isPowerOfTwo:Ee,ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:Ae,setQuaternionFromProperEuler:function(t,e,n,i,r){const a=Math.cos,s=Math.sin,o=a(n/2),l=s(n/2),c=a((e+i)/2),h=s((e+i)/2),u=a((e-i)/2),d=s((e-i)/2),p=a((i-e)/2),m=s((i-e)/2);switch(r){case"XYX":t.set(o*h,l*u,l*d,o*c);break;case"YZY":t.set(l*d,o*h,l*u,o*c);break;case"ZXZ":t.set(l*u,l*d,o*h,o*c);break;case"XZX":t.set(o*h,l*m,l*p,o*c);break;case"YXY":t.set(l*p,o*h,l*m,o*c);break;case"ZYZ":t.set(l*m,l*p,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:Ce,denormalize:Re};class Ie{constructor(t=0,e=0){Ie.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Me(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),r=this.x-t.x,a=this.y-t.y;return this.x=r*n-a*i+t.x,this.y=r*i+a*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Le{constructor(t,e,n,i,r,a,s,o,l){Le.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,a,s,o,l)}set(t,e,n,i,r,a,s,o,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=s,c[3]=e,c[4]=r,c[5]=o,c[6]=n,c[7]=a,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,a=n[0],s=n[3],o=n[6],l=n[1],c=n[4],h=n[7],u=n[2],d=n[5],p=n[8],m=i[0],f=i[3],g=i[6],v=i[1],_=i[4],y=i[7],x=i[2],b=i[5],w=i[8];return r[0]=a*m+s*v+o*x,r[3]=a*f+s*_+o*b,r[6]=a*g+s*y+o*w,r[1]=l*m+c*v+h*x,r[4]=l*f+c*_+h*b,r[7]=l*g+c*y+h*w,r[2]=u*m+d*v+p*x,r[5]=u*f+d*_+p*b,r[8]=u*g+d*y+p*w,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8];return e*a*c-e*s*l-n*r*c+n*s*o+i*r*l-i*a*o}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8],h=c*a-s*l,u=s*o-c*r,d=l*r-a*o,p=e*h+n*u+i*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=h*m,t[1]=(i*l-c*n)*m,t[2]=(s*n-i*a)*m,t[3]=u*m,t[4]=(c*e-i*o)*m,t[5]=(i*r-s*e)*m,t[6]=d*m,t[7]=(n*o-l*e)*m,t[8]=(a*e-n*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,r,a,s){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*a+l*s)+a+t,-i*l,i*o,-i*(-l*a+o*s)+s+e,0,0,1),this}scale(t,e){return this.premultiply(De.makeScale(t,e)),this}rotate(t){return this.premultiply(De.makeRotation(-t)),this}translate(t,e){return this.premultiply(De.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,n,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}const De=new Le;function Ne(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const Oe={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function Ue(t,e){return new Oe[t](e)}function Fe(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function Be(){const t=Fe("canvas");return t.style.display="block",t}const ze={};function ke(t){t in ze||(ze[t]=!0,console.warn(t))}const He=(new Le).set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Ge=(new Le).set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Ve={[re]:{transfer:oe,primaries:ce,toReference:t=>t,fromReference:t=>t},[ie]:{transfer:le,primaries:ce,toReference:t=>t.convertSRGBToLinear(),fromReference:t=>t.convertLinearToSRGB()},[se]:{transfer:oe,primaries:he,toReference:t=>t.applyMatrix3(Ge),fromReference:t=>t.applyMatrix3(He)},[ae]:{transfer:le,primaries:he,toReference:t=>t.convertSRGBToLinear().applyMatrix3(Ge),fromReference:t=>t.applyMatrix3(He).convertLinearToSRGB()}},We=new Set([re,se]),je={enabled:!0,_workingColorSpace:re,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(t){if(!We.has(t))throw new Error(`Unsupported working color space, "${t}".`);this._workingColorSpace=t},convert:function(t,e,n){if(!1===this.enabled||e===n||!e||!n)return t;const i=Ve[e].toReference;return(0,Ve[n].fromReference)(i(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this._workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this._workingColorSpace)},getPrimaries:function(t){return Ve[t].primaries},getTransfer:function(t){return t===ne?oe:Ve[t].transfer}};function Xe(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function qe(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}let Ye;class Ze{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Ye&&(Ye=Fe("canvas")),Ye.width=t.width,Ye.height=t.height;const n=Ye.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Ye}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=Fe("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const i=n.getImageData(0,0,t.width,t.height),r=i.data;for(let t=0;t<r.length;t++)r[t]=255*Xe(r[t]/255);return n.putImageData(i,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*Xe(e[t]/255)):e[t]=Xe(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Je=0;class Ke{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Je++}),this.uuid=we(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(null!==i){let t;if(Array.isArray(i)){t=[];for(let e=0,n=i.length;e<n;e++)i[e].isDataTexture?t.push(Qe(i[e].image)):t.push(Qe(i[e]))}else t=Qe(i);n.url=t}return e||(t.images[this.uuid]=n),n}}function Qe(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Ze.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let $e=0;class tn extends ve{constructor(t=tn.DEFAULT_IMAGE,e=tn.DEFAULT_MAPPING,n=1001,i=1001,r=1006,a=1008,s=1023,o=1009,l=tn.DEFAULT_ANISOTROPY,c=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:$e++}),this.uuid=we(),this.name="",this.source=new Ke(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=l,this.format=s,this.internalFormat=null,this.type=o,this.offset=new Ie(0,0),this.repeat=new Ie(1,1),this.center=new Ie(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Le,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,"string"==typeof c?this.colorSpace=c:(ke("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===ee?ie:ne),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==O)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case H:t.x=t.x-Math.floor(t.x);break;case G:t.x=t.x<0?0:1;break;case V:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case H:t.y=t.y-Math.floor(t.y);break;case G:t.y=t.y<0?0:1;break;case V:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return ke("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===ie?ee:te}set encoding(t){ke("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=t===ee?ie:ne}}tn.DEFAULT_IMAGE=null,tn.DEFAULT_MAPPING=O,tn.DEFAULT_ANISOTROPY=1;class en{constructor(t=0,e=0,n=0,i=1){en.prototype.isVector4=!0,this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,a=t.elements;return this.x=a[0]*e+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*e+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*e+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*e+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,r;const a=.01,s=.1,o=t.elements,l=o[0],c=o[4],h=o[8],u=o[1],d=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(c-u)<a&&Math.abs(h-m)<a&&Math.abs(p-f)<a){if(Math.abs(c+u)<s&&Math.abs(h+m)<s&&Math.abs(p+f)<s&&Math.abs(l+d+g-3)<s)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,v=(g+1)/2,_=(c+u)/4,y=(h+m)/4,x=(p+f)/4;return t>o&&t>v?t<a?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(t),i=_/n,r=y/n):o>v?o<a?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(o),n=_/i,r=x/i):v<a?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(v),n=y/r,i=x/r),this.set(n,i,r,e),this}let v=Math.sqrt((f-p)*(f-p)+(h-m)*(h-m)+(u-c)*(u-c));return Math.abs(v)<.001&&(v=1),this.x=(f-p)/v,this.y=(h-m)/v,this.z=(u-c)/v,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class nn extends ve{constructor(t=1,e=1,n={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new en(0,0,t,e),this.scissorTest=!1,this.viewport=new en(0,0,t,e);const i={width:t,height:e,depth:1};void 0!==n.encoding&&(ke("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===ee?ie:ne),n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:q,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},n),this.texture=new tn(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps,this.texture.internalFormat=n.internalFormat,this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Ke(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class rn extends nn{constructor(t=1,e=1,n={}){super(t,e,n),this.isWebGLRenderTarget=!0}}class an extends tn{constructor(t=null,e=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=W,this.minFilter=W,this.wrapR=G,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class sn extends rn{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new an(null,t,e,n),this.texture.isRenderTargetTexture=!0}}class on extends tn{constructor(t=null,e=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:t,width:e,height:n,depth:i},this.magFilter=W,this.minFilter=W,this.wrapR=G,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ln{constructor(t=0,e=0,n=0,i=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,a,s){let o=n[i+0],l=n[i+1],c=n[i+2],h=n[i+3];const u=r[a+0],d=r[a+1],p=r[a+2],m=r[a+3];if(0===s)return t[e+0]=o,t[e+1]=l,t[e+2]=c,void(t[e+3]=h);if(1===s)return t[e+0]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=m);if(h!==m||o!==u||l!==d||c!==p){let t=1-s;const e=o*u+l*d+c*p+h*m,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),a=Math.atan2(r,e*n);t=Math.sin(t*a)/r,s=Math.sin(s*a)/r}const r=s*n;if(o=o*t+u*r,l=l*t+d*r,c=c*t+p*r,h=h*t+m*r,t===1-s){const t=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=t,l*=t,c*=t,h*=t}}t[e]=o,t[e+1]=l,t[e+2]=c,t[e+3]=h}static multiplyQuaternionsFlat(t,e,n,i,r,a){const s=n[i],o=n[i+1],l=n[i+2],c=n[i+3],h=r[a],u=r[a+1],d=r[a+2],p=r[a+3];return t[e]=s*p+c*h+o*d-l*u,t[e+1]=o*p+c*u+l*h-s*d,t[e+2]=l*p+c*d+s*u-o*h,t[e+3]=c*p-s*h-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const n=t._x,i=t._y,r=t._z,a=t._order,s=Math.cos,o=Math.sin,l=s(n/2),c=s(i/2),h=s(r/2),u=o(n/2),d=o(i/2),p=o(r/2);switch(a){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],a=e[1],s=e[5],o=e[9],l=e[2],c=e[6],h=e[10],u=n+s+h;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(c-o)*t,this._y=(r-l)*t,this._z=(a-i)*t}else if(n>s&&n>h){const t=2*Math.sqrt(1+n-s-h);this._w=(c-o)/t,this._x=.25*t,this._y=(i+a)/t,this._z=(r+l)/t}else if(s>h){const t=2*Math.sqrt(1+s-n-h);this._w=(r-l)/t,this._x=(i+a)/t,this._y=.25*t,this._z=(o+c)/t}else{const t=2*Math.sqrt(1+h-n-s);this._w=(a-i)/t,this._x=(r+l)/t,this._y=(o+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Me(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,a=t._w,s=e._x,o=e._y,l=e._z,c=e._w;return this._x=n*c+a*s+i*l-r*o,this._y=i*c+a*o+r*s-n*l,this._z=r*c+a*l+n*o-i*s,this._w=a*c-n*s-i*o-r*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,i=this._y,r=this._z,a=this._w;let s=a*t._w+n*t._x+i*t._y+r*t._z;if(s<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,s=-s):this.copy(t),s>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const o=1-s*s;if(o<=Number.EPSILON){const t=1-e;return this._w=t*a+e*this._w,this._x=t*n+e*this._x,this._y=t*i+e*this._y,this._z=t*r+e*this._z,this.normalize(),this}const l=Math.sqrt(o),c=Math.atan2(l,s),h=Math.sin((1-e)*c)/l,u=Math.sin(e*c)/l;return this._w=a*h+this._w*u,this._x=n*h+this._x*u,this._y=i*h+this._y*u,this._z=r*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(i),n*Math.sin(r),n*Math.cos(r),e*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class cn{constructor(t=0,e=0,n=0){cn.prototype.isVector3=!0,this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(un.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(un.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,a=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t.x,a=t.y,s=t.z,o=t.w,l=2*(a*i-s*n),c=2*(s*e-r*i),h=2*(r*n-a*e);return this.x=e+o*l+a*h-s*c,this.y=n+o*c+s*l-r*h,this.z=i+o*h+r*c-a*l,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,a=e.x,s=e.y,o=e.z;return this.x=i*o-r*s,this.y=r*a-n*o,this.z=n*s-i*a,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return hn.copy(this).projectOnVector(t),this.sub(hn)}reflect(t){return this.sub(hn.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Me(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const hn=new cn,un=new ln;class dn{constructor(t=new cn(1/0,1/0,1/0),e=new cn(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e+=3)this.expandByPoint(mn.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,n=t.count;e<n;e++)this.expandByPoint(mn.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=mn.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n){const i=n.getAttribute("position");if(!0===e&&void 0!==i&&!0!==t.isInstancedMesh)for(let e=0,n=i.count;e<n;e++)!0===t.isMesh?t.getVertexPosition(e,mn):mn.fromBufferAttribute(i,e),mn.applyMatrix4(t.matrixWorld),this.expandByPoint(mn);else void 0!==t.boundingBox?(null===t.boundingBox&&t.computeBoundingBox(),fn.copy(t.boundingBox)):(null===n.boundingBox&&n.computeBoundingBox(),fn.copy(n.boundingBox)),fn.applyMatrix4(t.matrixWorld),this.union(fn)}const i=t.children;for(let t=0,n=i.length;t<n;t++)this.expandByObject(i[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,mn),mn.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(wn),Mn.subVectors(this.max,wn),gn.subVectors(t.a,wn),vn.subVectors(t.b,wn),_n.subVectors(t.c,wn),yn.subVectors(vn,gn),xn.subVectors(_n,vn),bn.subVectors(gn,_n);let e=[0,-yn.z,yn.y,0,-xn.z,xn.y,0,-bn.z,bn.y,yn.z,0,-yn.x,xn.z,0,-xn.x,bn.z,0,-bn.x,-yn.y,yn.x,0,-xn.y,xn.x,0,-bn.y,bn.x,0];return!!En(e,gn,vn,_n,Mn)&&(e=[1,0,0,0,1,0,0,0,1],!!En(e,gn,vn,_n,Mn)&&(Sn.crossVectors(yn,xn),e=[Sn.x,Sn.y,Sn.z],En(e,gn,vn,_n,Mn)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,mn).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(mn).length()),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(pn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),pn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),pn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),pn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),pn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),pn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),pn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),pn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(pn)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const pn=[new cn,new cn,new cn,new cn,new cn,new cn,new cn,new cn],mn=new cn,fn=new dn,gn=new cn,vn=new cn,_n=new cn,yn=new cn,xn=new cn,bn=new cn,wn=new cn,Mn=new cn,Sn=new cn,Tn=new cn;function En(t,e,n,i,r){for(let a=0,s=t.length-3;a<=s;a+=3){Tn.fromArray(t,a);const s=r.x*Math.abs(Tn.x)+r.y*Math.abs(Tn.y)+r.z*Math.abs(Tn.z),o=e.dot(Tn),l=n.dot(Tn),c=i.dot(Tn);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>s)return!1}return!0}const An=new dn,Rn=new cn,Cn=new cn;class Pn{constructor(t=new cn,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):An.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Rn.subVectors(t,this.center);const e=Rn.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(Rn,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(!0===this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(Cn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Rn.copy(t.center).add(Cn)),this.expandByPoint(Rn.copy(t.center).sub(Cn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const In=new cn,Ln=new cn,Dn=new cn,Nn=new cn,On=new cn,Un=new cn,Fn=new cn;class Bn{constructor(t=new cn,e=new cn(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,In)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=In.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(In.copy(this.origin).addScaledVector(this.direction,e),In.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){Ln.copy(t).add(e).multiplyScalar(.5),Dn.copy(e).sub(t).normalize(),Nn.copy(this.origin).sub(Ln);const r=.5*t.distanceTo(e),a=-this.direction.dot(Dn),s=Nn.dot(this.direction),o=-Nn.dot(Dn),l=Nn.lengthSq(),c=Math.abs(1-a*a);let h,u,d,p;if(c>0)if(h=a*o-s,u=a*s-o,p=r*c,h>=0)if(u>=-p)if(u<=p){const t=1/c;h*=t,u*=t,d=h*(h+a*u+2*s)+u*(a*h+u+2*o)+l}else u=r,h=Math.max(0,-(a*u+s)),d=-h*h+u*(u+2*o)+l;else u=-r,h=Math.max(0,-(a*u+s)),d=-h*h+u*(u+2*o)+l;else u<=-p?(h=Math.max(0,-(-a*r+s)),u=h>0?-r:Math.min(Math.max(-r,-o),r),d=-h*h+u*(u+2*o)+l):u<=p?(h=0,u=Math.min(Math.max(-r,-o),r),d=u*(u+2*o)+l):(h=Math.max(0,-(a*r+s)),u=h>0?r:Math.min(Math.max(-r,-o),r),d=-h*h+u*(u+2*o)+l);else u=a>0?-r:r,h=Math.max(0,-(a*u+s)),d=-h*h+u*(u+2*o)+l;return n&&n.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(Ln).addScaledVector(Dn,u),d}intersectSphere(t,e){In.subVectors(t.center,this.origin);const n=In.dot(this.direction),i=In.dot(In)-n*n,r=t.radius*t.radius;if(i>r)return null;const a=Math.sqrt(r-i),s=n-a,o=n+a;return o<0?null:s<0?this.at(o,e):this.at(s,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,r,a,s,o;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),c>=0?(r=(t.min.y-u.y)*c,a=(t.max.y-u.y)*c):(r=(t.max.y-u.y)*c,a=(t.min.y-u.y)*c),n>a||r>i?null:((r>n||isNaN(n))&&(n=r),(a<i||isNaN(i))&&(i=a),h>=0?(s=(t.min.z-u.z)*h,o=(t.max.z-u.z)*h):(s=(t.max.z-u.z)*h,o=(t.min.z-u.z)*h),n>o||s>i?null:((s>n||n!=n)&&(n=s),(o<i||i!=i)&&(i=o),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return null!==this.intersectBox(t,In)}intersectTriangle(t,e,n,i,r){On.subVectors(e,t),Un.subVectors(n,t),Fn.crossVectors(On,Un);let a,s=this.direction.dot(Fn);if(s>0){if(i)return null;a=1}else{if(!(s<0))return null;a=-1,s=-s}Nn.subVectors(this.origin,t);const o=a*this.direction.dot(Un.crossVectors(Nn,Un));if(o<0)return null;const l=a*this.direction.dot(On.cross(Nn));if(l<0)return null;if(o+l>s)return null;const c=-a*Nn.dot(Fn);return c<0?null:this.at(c/s,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class zn{constructor(t,e,n,i,r,a,s,o,l,c,h,u,d,p,m,f){zn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,n,i,r,a,s,o,l,c,h,u,d,p,m,f)}set(t,e,n,i,r,a,s,o,l,c,h,u,d,p,m,f){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=i,g[1]=r,g[5]=a,g[9]=s,g[13]=o,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new zn).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/kn.setFromMatrixColumn(t,0).length(),r=1/kn.setFromMatrixColumn(t,1).length(),a=1/kn.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*a,e[9]=n[9]*a,e[10]=n[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,n=t.x,i=t.y,r=t.z,a=Math.cos(n),s=Math.sin(n),o=Math.cos(i),l=Math.sin(i),c=Math.cos(r),h=Math.sin(r);if("XYZ"===t.order){const t=a*c,n=a*h,i=s*c,r=s*h;e[0]=o*c,e[4]=-o*h,e[8]=l,e[1]=n+i*l,e[5]=t-r*l,e[9]=-s*o,e[2]=r-t*l,e[6]=i+n*l,e[10]=a*o}else if("YXZ"===t.order){const t=o*c,n=o*h,i=l*c,r=l*h;e[0]=t+r*s,e[4]=i*s-n,e[8]=a*l,e[1]=a*h,e[5]=a*c,e[9]=-s,e[2]=n*s-i,e[6]=r+t*s,e[10]=a*o}else if("ZXY"===t.order){const t=o*c,n=o*h,i=l*c,r=l*h;e[0]=t-r*s,e[4]=-a*h,e[8]=i+n*s,e[1]=n+i*s,e[5]=a*c,e[9]=r-t*s,e[2]=-a*l,e[6]=s,e[10]=a*o}else if("ZYX"===t.order){const t=a*c,n=a*h,i=s*c,r=s*h;e[0]=o*c,e[4]=i*l-n,e[8]=t*l+r,e[1]=o*h,e[5]=r*l+t,e[9]=n*l-i,e[2]=-l,e[6]=s*o,e[10]=a*o}else if("YZX"===t.order){const t=a*o,n=a*l,i=s*o,r=s*l;e[0]=o*c,e[4]=r-t*h,e[8]=i*h+n,e[1]=h,e[5]=a*c,e[9]=-s*c,e[2]=-l*c,e[6]=n*h+i,e[10]=t-r*h}else if("XZY"===t.order){const t=a*o,n=a*l,i=s*o,r=s*l;e[0]=o*c,e[4]=-h,e[8]=l*c,e[1]=t*h+r,e[5]=a*c,e[9]=n*h-i,e[2]=i*h-n,e[6]=s*c,e[10]=r*h+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Gn,t,Vn)}lookAt(t,e,n){const i=this.elements;return Xn.subVectors(t,e),0===Xn.lengthSq()&&(Xn.z=1),Xn.normalize(),Wn.crossVectors(n,Xn),0===Wn.lengthSq()&&(1===Math.abs(n.z)?Xn.x+=1e-4:Xn.z+=1e-4,Xn.normalize(),Wn.crossVectors(n,Xn)),Wn.normalize(),jn.crossVectors(Xn,Wn),i[0]=Wn.x,i[4]=jn.x,i[8]=Xn.x,i[1]=Wn.y,i[5]=jn.y,i[9]=Xn.y,i[2]=Wn.z,i[6]=jn.z,i[10]=Xn.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,a=n[0],s=n[4],o=n[8],l=n[12],c=n[1],h=n[5],u=n[9],d=n[13],p=n[2],m=n[6],f=n[10],g=n[14],v=n[3],_=n[7],y=n[11],x=n[15],b=i[0],w=i[4],M=i[8],S=i[12],T=i[1],E=i[5],A=i[9],R=i[13],C=i[2],P=i[6],I=i[10],L=i[14],D=i[3],N=i[7],O=i[11],U=i[15];return r[0]=a*b+s*T+o*C+l*D,r[4]=a*w+s*E+o*P+l*N,r[8]=a*M+s*A+o*I+l*O,r[12]=a*S+s*R+o*L+l*U,r[1]=c*b+h*T+u*C+d*D,r[5]=c*w+h*E+u*P+d*N,r[9]=c*M+h*A+u*I+d*O,r[13]=c*S+h*R+u*L+d*U,r[2]=p*b+m*T+f*C+g*D,r[6]=p*w+m*E+f*P+g*N,r[10]=p*M+m*A+f*I+g*O,r[14]=p*S+m*R+f*L+g*U,r[3]=v*b+_*T+y*C+x*D,r[7]=v*w+_*E+y*P+x*N,r[11]=v*M+_*A+y*I+x*O,r[15]=v*S+_*R+y*L+x*U,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],a=t[1],s=t[5],o=t[9],l=t[13],c=t[2],h=t[6],u=t[10],d=t[14];return t[3]*(+r*o*h-i*l*h-r*s*u+n*l*u+i*s*d-n*o*d)+t[7]*(+e*o*d-e*l*u+r*a*u-i*a*d+i*l*c-r*o*c)+t[11]*(+e*l*h-e*s*d-r*a*h+n*a*d+r*s*c-n*l*c)+t[15]*(-i*s*c-e*o*h+e*s*u+i*a*h-n*a*u+n*o*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],r=t[3],a=t[4],s=t[5],o=t[6],l=t[7],c=t[8],h=t[9],u=t[10],d=t[11],p=t[12],m=t[13],f=t[14],g=t[15],v=h*f*l-m*u*l+m*o*d-s*f*d-h*o*g+s*u*g,_=p*u*l-c*f*l-p*o*d+a*f*d+c*o*g-a*u*g,y=c*m*l-p*h*l+p*s*d-a*m*d-c*s*g+a*h*g,x=p*h*o-c*m*o-p*s*u+a*m*u+c*s*f-a*h*f,b=e*v+n*_+i*y+r*x;if(0===b)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const w=1/b;return t[0]=v*w,t[1]=(m*u*r-h*f*r-m*i*d+n*f*d+h*i*g-n*u*g)*w,t[2]=(s*f*r-m*o*r+m*i*l-n*f*l-s*i*g+n*o*g)*w,t[3]=(h*o*r-s*u*r-h*i*l+n*u*l+s*i*d-n*o*d)*w,t[4]=_*w,t[5]=(c*f*r-p*u*r+p*i*d-e*f*d-c*i*g+e*u*g)*w,t[6]=(p*o*r-a*f*r-p*i*l+e*f*l+a*i*g-e*o*g)*w,t[7]=(a*u*r-c*o*r+c*i*l-e*u*l-a*i*d+e*o*d)*w,t[8]=y*w,t[9]=(p*h*r-c*m*r-p*n*d+e*m*d+c*n*g-e*h*g)*w,t[10]=(a*m*r-p*s*r+p*n*l-e*m*l-a*n*g+e*s*g)*w,t[11]=(c*s*r-a*h*r-c*n*l+e*h*l+a*n*d-e*s*d)*w,t[12]=x*w,t[13]=(c*m*i-p*h*i+p*n*u-e*m*u-c*n*f+e*h*f)*w,t[14]=(p*s*i-a*m*i-p*n*o+e*m*o+a*n*f-e*s*f)*w,t[15]=(a*h*i-c*s*i+c*n*o-e*h*o-a*n*u+e*s*u)*w,this}scale(t){const e=this.elements,n=t.x,i=t.y,r=t.z;return e[0]*=n,e[4]*=i,e[8]*=r,e[1]*=n,e[5]*=i,e[9]*=r,e[2]*=n,e[6]*=i,e[10]*=r,e[3]*=n,e[7]*=i,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,a=t.x,s=t.y,o=t.z,l=r*a,c=r*s;return this.set(l*a+n,l*s-i*o,l*o+i*s,0,l*s+i*o,c*s+n,c*o-i*a,0,l*o-i*s,c*o+i*a,r*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,i,r,a){return this.set(1,n,r,0,t,1,a,0,e,i,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,r=e._x,a=e._y,s=e._z,o=e._w,l=r+r,c=a+a,h=s+s,u=r*l,d=r*c,p=r*h,m=a*c,f=a*h,g=s*h,v=o*l,_=o*c,y=o*h,x=n.x,b=n.y,w=n.z;return i[0]=(1-(m+g))*x,i[1]=(d+y)*x,i[2]=(p-_)*x,i[3]=0,i[4]=(d-y)*b,i[5]=(1-(u+g))*b,i[6]=(f+v)*b,i[7]=0,i[8]=(p+_)*w,i[9]=(f-v)*w,i[10]=(1-(u+m))*w,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let r=kn.set(i[0],i[1],i[2]).length();const a=kn.set(i[4],i[5],i[6]).length(),s=kn.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],Hn.copy(this);const o=1/r,l=1/a,c=1/s;return Hn.elements[0]*=o,Hn.elements[1]*=o,Hn.elements[2]*=o,Hn.elements[4]*=l,Hn.elements[5]*=l,Hn.elements[6]*=l,Hn.elements[8]*=c,Hn.elements[9]*=c,Hn.elements[10]*=c,e.setFromRotationMatrix(Hn),n.x=r,n.y=a,n.z=s,this}makePerspective(t,e,n,i,r,a,s=2e3){const o=this.elements,l=2*r/(e-t),c=2*r/(n-i),h=(e+t)/(e-t),u=(n+i)/(n-i);let d,p;if(s===fe)d=-(a+r)/(a-r),p=-2*a*r/(a-r);else{if(s!==ge)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+s);d=-a/(a-r),p=-a*r/(a-r)}return o[0]=l,o[4]=0,o[8]=h,o[12]=0,o[1]=0,o[5]=c,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,n,i,r,a,s=2e3){const o=this.elements,l=1/(e-t),c=1/(n-i),h=1/(a-r),u=(e+t)*l,d=(n+i)*c;let p,m;if(s===fe)p=(a+r)*h,m=-2*h;else{if(s!==ge)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+s);p=r*h,m=-1*h}return o[0]=2*l,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*c,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=m,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const kn=new cn,Hn=new zn,Gn=new cn(0,0,0),Vn=new cn(1,1,1),Wn=new cn,jn=new cn,Xn=new cn,qn=new zn,Yn=new ln;class Zn{constructor(t=0,e=0,n=0,i=Zn.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const i=t.elements,r=i[0],a=i[4],s=i[8],o=i[1],l=i[5],c=i[9],h=i[2],u=i[6],d=i[10];switch(e){case"XYZ":this._y=Math.asin(Me(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Me(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(s,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(Me(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(o,r));break;case"ZYX":this._y=Math.asin(-Me(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,r)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(Me(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(s,d));break;case"XZY":this._z=Math.asin(-Me(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(s,r)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return qn.makeRotationFromQuaternion(t),this.setFromRotationMatrix(qn,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Yn.setFromEuler(this),this.setFromQuaternion(Yn,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Zn.DEFAULT_ORDER="XYZ";class Jn{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let Kn=0;const Qn=new cn,$n=new ln,ti=new zn,ei=new cn,ni=new cn,ii=new cn,ri=new ln,ai=new cn(1,0,0),si=new cn(0,1,0),oi=new cn(0,0,1),li={type:"added"},ci={type:"removed"};class hi extends ve{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Kn++}),this.uuid=we(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hi.DEFAULT_UP.clone();const t=new cn,e=new Zn,n=new ln,i=new cn(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new zn},normalMatrix:{value:new Le}}),this.matrix=new zn,this.matrixWorld=new zn,this.matrixAutoUpdate=hi.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=hi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Jn,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return $n.setFromAxisAngle(t,e),this.quaternion.multiply($n),this}rotateOnWorldAxis(t,e){return $n.setFromAxisAngle(t,e),this.quaternion.premultiply($n),this}rotateX(t){return this.rotateOnAxis(ai,t)}rotateY(t){return this.rotateOnAxis(si,t)}rotateZ(t){return this.rotateOnAxis(oi,t)}translateOnAxis(t,e){return Qn.copy(t).applyQuaternion(this.quaternion),this.position.add(Qn.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ai,t)}translateY(t){return this.translateOnAxis(si,t)}translateZ(t){return this.translateOnAxis(oi,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(ti.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ei.copy(t):ei.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),ni.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ti.lookAt(ni,ei,this.up):ti.lookAt(ei,ni,this.up),this.quaternion.setFromRotationMatrix(ti),i&&(ti.extractRotation(i.matrixWorld),$n.setFromRotationMatrix(ti),this.quaternion.premultiply($n.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(li)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(ci)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),ti.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),ti.multiply(t.parent.matrixWorld)),t.applyMatrix4(ti),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}getObjectsByProperty(t,e,n=[]){this[t]===e&&n.push(this);const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].getObjectsByProperty(t,e,n);return n}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ni,t,ii),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ni,ri,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++){const i=e[n];!0!==i.matrixWorldAutoUpdate&&!0!==t||i.updateMatrixWorld(t)}}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&!0===n.matrixWorldAutoUpdate&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++){const n=t[e];!0===n.matrixWorldAutoUpdate&&n.updateWorldMatrix(!1,!0)}}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};function r(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map((t=>({boxInitialized:t.boxInitialized,boxMin:t.box.min.toArray(),boxMax:t.box.max.toArray(),sphereInitialized:t.sphereInitialized,sphereRadius:t.sphere.radius,sphereCenter:t.sphere.center.toArray()}))),i.maxGeometryCount=this._maxGeometryCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(t),null!==this.boundingSphere&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),null!==this.boundingBox&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(i.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const i=n[e];r(t.shapes,i)}else r(t.shapes,n)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,i=this.material.length;n<i;n++)e.push(r(t.materials,this.material[n]));i.material=e}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(let e=0;e<this.children.length;e++)i.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];i.animations.push(r(t.animations,n))}}if(e){const e=a(t.geometries),i=a(t.materials),r=a(t.textures),s=a(t.images),o=a(t.shapes),l=a(t.skeletons),c=a(t.animations),h=a(t.nodes);e.length>0&&(n.geometries=e),i.length>0&&(n.materials=i),r.length>0&&(n.textures=r),s.length>0&&(n.images=s),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c),h.length>0&&(n.nodes=h)}return n.object=i,n;function a(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}hi.DEFAULT_UP=new cn(0,1,0),hi.DEFAULT_MATRIX_AUTO_UPDATE=!0,hi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ui=new cn,di=new cn,pi=new cn,mi=new cn,fi=new cn,gi=new cn,vi=new cn,_i=new cn,yi=new cn,xi=new cn;let bi=!1;class wi{constructor(t=new cn,e=new cn,n=new cn){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i.subVectors(n,e),ui.subVectors(t,e),i.cross(ui);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(t,e,n,i,r){ui.subVectors(i,e),di.subVectors(n,e),pi.subVectors(t,e);const a=ui.dot(ui),s=ui.dot(di),o=ui.dot(pi),l=di.dot(di),c=di.dot(pi),h=a*l-s*s;if(0===h)return r.set(0,0,0),null;const u=1/h,d=(l*o-s*c)*u,p=(a*c-s*o)*u;return r.set(1-d-p,p,d)}static containsPoint(t,e,n,i){return null!==this.getBarycoord(t,e,n,i,mi)&&(mi.x>=0&&mi.y>=0&&mi.x+mi.y<=1)}static getUV(t,e,n,i,r,a,s,o){return!1===bi&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),bi=!0),this.getInterpolation(t,e,n,i,r,a,s,o)}static getInterpolation(t,e,n,i,r,a,s,o){return null===this.getBarycoord(t,e,n,i,mi)?(o.x=0,o.y=0,"z"in o&&(o.z=0),"w"in o&&(o.w=0),null):(o.setScalar(0),o.addScaledVector(r,mi.x),o.addScaledVector(a,mi.y),o.addScaledVector(s,mi.z),o)}static isFrontFacing(t,e,n,i){return ui.subVectors(n,e),di.subVectors(t,e),ui.cross(di).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}setFromAttributeAndIndices(t,e,n,i){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,i),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ui.subVectors(this.c,this.b),di.subVectors(this.a,this.b),.5*ui.cross(di).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return wi.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return wi.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,r){return!1===bi&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),bi=!0),wi.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}getInterpolation(t,e,n,i,r){return wi.getInterpolation(t,this.a,this.b,this.c,e,n,i,r)}containsPoint(t){return wi.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return wi.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,i=this.b,r=this.c;let a,s;fi.subVectors(i,n),gi.subVectors(r,n),_i.subVectors(t,n);const o=fi.dot(_i),l=gi.dot(_i);if(o<=0&&l<=0)return e.copy(n);yi.subVectors(t,i);const c=fi.dot(yi),h=gi.dot(yi);if(c>=0&&h<=c)return e.copy(i);const u=o*h-c*l;if(u<=0&&o>=0&&c<=0)return a=o/(o-c),e.copy(n).addScaledVector(fi,a);xi.subVectors(t,r);const d=fi.dot(xi),p=gi.dot(xi);if(p>=0&&d<=p)return e.copy(r);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return s=l/(l-p),e.copy(n).addScaledVector(gi,s);const f=c*p-d*h;if(f<=0&&h-c>=0&&d-p>=0)return vi.subVectors(r,i),s=(h-c)/(h-c+(d-p)),e.copy(i).addScaledVector(vi,s);const g=1/(f+m+u);return a=m*g,s=u*g,e.copy(n).addScaledVector(fi,a).addScaledVector(gi,s)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Mi={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Si={h:0,s:0,l:0},Ti={h:0,s:0,l:0};function Ei(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}class Ai{constructor(t,e,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,n)}set(t,e,n){if(void 0===e&&void 0===n){const e=t;e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e)}else this.setRGB(t,e,n);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=ie){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,je.toWorkingColorSpace(this,e),this}setRGB(t,e,n,i=je.workingColorSpace){return this.r=t,this.g=e,this.b=n,je.toWorkingColorSpace(this,i),this}setHSL(t,e,n,i=je.workingColorSpace){if(t=Se(t,1),e=Me(e,0,1),n=Me(n,0,1),0===e)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,r=2*n-i;this.r=Ei(r,i,t+1/3),this.g=Ei(r,i,t),this.b=Ei(r,i,t-1/3)}return je.toWorkingColorSpace(this,i),this}setStyle(t,e=ie){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const a=i[1],s=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=i[1],r=n.length;if(3===r)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(6===r)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=ie){const n=Mi[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Xe(t.r),this.g=Xe(t.g),this.b=Xe(t.b),this}copyLinearToSRGB(t){return this.r=qe(t.r),this.g=qe(t.g),this.b=qe(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=ie){return je.fromWorkingColorSpace(Ri.copy(this),t),65536*Math.round(Me(255*Ri.r,0,255))+256*Math.round(Me(255*Ri.g,0,255))+Math.round(Me(255*Ri.b,0,255))}getHexString(t=ie){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=je.workingColorSpace){je.fromWorkingColorSpace(Ri.copy(this),e);const n=Ri.r,i=Ri.g,r=Ri.b,a=Math.max(n,i,r),s=Math.min(n,i,r);let o,l;const c=(s+a)/2;if(s===a)o=0,l=0;else{const t=a-s;switch(l=c<=.5?t/(a+s):t/(2-a-s),a){case n:o=(i-r)/t+(i<r?6:0);break;case i:o=(r-n)/t+2;break;case r:o=(n-i)/t+4}o/=6}return t.h=o,t.s=l,t.l=c,t}getRGB(t,e=je.workingColorSpace){return je.fromWorkingColorSpace(Ri.copy(this),e),t.r=Ri.r,t.g=Ri.g,t.b=Ri.b,t}getStyle(t=ie){je.fromWorkingColorSpace(Ri.copy(this),t);const e=Ri.r,n=Ri.g,i=Ri.b;return t!==ie?`color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(255*e)},${Math.round(255*n)},${Math.round(255*i)})`}offsetHSL(t,e,n){return this.getHSL(Si),this.setHSL(Si.h+t,Si.s+e,Si.l+n)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Si),t.getHSL(Ti);const n=Te(Si.h,Ti.h,e),i=Te(Si.s,Ti.s,e),r=Te(Si.l,Ti.l,e);return this.setHSL(n,i,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,n=this.g,i=this.b,r=t.elements;return this.r=r[0]*e+r[3]*n+r[6]*i,this.g=r[1]*e+r[4]*n+r[7]*i,this.b=r[2]*e+r[5]*n+r[8]*i,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ri=new Ai;Ai.NAMES=Mi;let Ci=0;class Pi extends ve{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ci++}),this.uuid=we(),this.name="",this.type="Material",this.blending=1,this.side=v,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=b,this.blendDst=w,this.blendEquation=x,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ai(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ue,this.stencilZFail=ue,this.stencilZPass=ue,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const i=this[e];void 0!==i?i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[e]=n:console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function i(t){const e=[];for(const n in t){const i=t[n];delete i.metadata,e.push(i)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(n.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(n.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),void 0!==this.anisotropy&&(n.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(n.blending=this.blending),this.side!==v&&(n.side=this.side),!0===this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=!0),this.blendSrc!==b&&(n.blendSrc=this.blendSrc),this.blendDst!==w&&(n.blendDst=this.blendDst),this.blendEquation!==x&&(n.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(n.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(n.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(n.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(n.depthFunc=this.depthFunc),!1===this.depthTest&&(n.depthTest=this.depthTest),!1===this.depthWrite&&(n.depthWrite=this.depthWrite),!1===this.colorWrite&&(n.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(n.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(n.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(n.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ue&&(n.stencilFail=this.stencilFail),this.stencilZFail!==ue&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==ue&&(n.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(n.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaHash&&(n.alphaHash=!0),!0===this.alphaToCoverage&&(n.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=!0),!0===this.forceSinglePass&&(n.forceSinglePass=!0),!0===this.wireframe&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=!0),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData),e){const e=i(t.textures),r=i(t.images);e.length>0&&(n.textures=e),r.length>0&&(n.images=r)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let i=0;i!==t;++i)n[i]=e[i].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}class Ii extends Pi{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ai(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=M,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const Li=Di();function Di(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),i=new Uint32Array(512),r=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(i[t]=0,i[256|t]=32768,r[t]=24,r[256|t]=24):e<-14?(i[t]=1024>>-e-14,i[256|t]=1024>>-e-14|32768,r[t]=-e-1,r[256|t]=-e-1):e<=15?(i[t]=e+15<<10,i[256|t]=e+15<<10|32768,r[t]=13,r[256|t]=13):e<128?(i[t]=31744,i[256|t]=64512,r[t]=24,r[256|t]=24):(i[t]=31744,i[256|t]=64512,r[t]=13,r[256|t]=13)}const a=new Uint32Array(2048),s=new Uint32Array(64),o=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;0==(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,a[t]=e|n}for(let t=1024;t<2048;++t)a[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)s[t]=t<<23;s[31]=1199570944,s[32]=2147483648;for(let t=33;t<63;++t)s[t]=2147483648+(t-32<<23);s[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(o[t]=1024);return{floatView:e,uint32View:n,baseTable:i,shiftTable:r,mantissaTable:a,exponentTable:s,offsetTable:o}}function Ni(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=Me(t,-65504,65504),Li.floatView[0]=t;const e=Li.uint32View[0],n=e>>23&511;return Li.baseTable[n]+((8388607&e)>>Li.shiftTable[n])}function Oi(t){const e=t>>10;return Li.uint32View[0]=Li.mantissaTable[Li.offsetTable[e]+(1023&t)]+Li.exponentTable[e],Li.floatView[0]}const Ui={toHalfFloat:Ni,fromHalfFloat:Oi},Fi=new cn,Bi=new Ie;class zi{constructor(t,e,n=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=n,this.usage=de,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=nt,this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}get updateRange(){return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)Bi.fromBufferAttribute(this,e),Bi.applyMatrix3(t),this.setXY(e,Bi.x,Bi.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Fi.fromBufferAttribute(this,e),Fi.applyMatrix3(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Fi.fromBufferAttribute(this,e),Fi.applyMatrix4(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Fi.fromBufferAttribute(this,e),Fi.applyNormalMatrix(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Fi.fromBufferAttribute(this,e),Fi.transformDirection(t),this.setXYZ(e,Fi.x,Fi.y,Fi.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let n=this.array[t*this.itemSize+e];return this.normalized&&(n=Re(n,this.array)),n}setComponent(t,e,n){return this.normalized&&(n=Ce(n,this.array)),this.array[t*this.itemSize+e]=n,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Re(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Re(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Re(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Re(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array)),this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array),r=Ce(r,this.array)),this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==de&&(t.usage=this.usage),t}}class ki extends zi{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Hi extends zi{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Gi extends zi{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Vi=0;const Wi=new zn,ji=new hi,Xi=new cn,qi=new dn,Yi=new dn,Zi=new cn;class Ji extends ve{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Vi++}),this.uuid=we(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Ne(t)?Hi:ki)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new Le).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Wi.makeRotationFromQuaternion(t),this.applyMatrix4(Wi),this}rotateX(t){return Wi.makeRotationX(t),this.applyMatrix4(Wi),this}rotateY(t){return Wi.makeRotationY(t),this.applyMatrix4(Wi),this}rotateZ(t){return Wi.makeRotationZ(t),this.applyMatrix4(Wi),this}translate(t,e,n){return Wi.makeTranslation(t,e,n),this.applyMatrix4(Wi),this}scale(t,e,n){return Wi.makeScale(t,e,n),this.applyMatrix4(Wi),this}lookAt(t){return ji.lookAt(t),ji.updateMatrix(),this.applyMatrix4(ji.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Xi).negate(),this.translate(Xi.x,Xi.y,Xi.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Gi(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new dn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new cn(-1/0,-1/0,-1/0),new cn(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];qi.setFromBufferAttribute(n),this.morphTargetsRelative?(Zi.addVectors(this.boundingBox.min,qi.min),this.boundingBox.expandByPoint(Zi),Zi.addVectors(this.boundingBox.max,qi.max),this.boundingBox.expandByPoint(Zi)):(this.boundingBox.expandByPoint(qi.min),this.boundingBox.expandByPoint(qi.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Pn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new cn,1/0);if(t){const n=this.boundingSphere.center;if(qi.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Yi.setFromBufferAttribute(n),this.morphTargetsRelative?(Zi.addVectors(qi.min,Yi.min),qi.expandByPoint(Zi),Zi.addVectors(qi.max,Yi.max),qi.expandByPoint(Zi)):(qi.expandByPoint(Yi.min),qi.expandByPoint(Yi.max))}qi.getCenter(n);let i=0;for(let e=0,r=t.count;e<r;e++)Zi.fromBufferAttribute(t,e),i=Math.max(i,n.distanceToSquared(Zi));if(e)for(let r=0,a=e.length;r<a;r++){const a=e[r],s=this.morphTargetsRelative;for(let e=0,r=a.count;e<r;e++)Zi.fromBufferAttribute(a,e),s&&(Xi.fromBufferAttribute(t,e),Zi.add(Xi)),i=Math.max(i,n.distanceToSquared(Zi))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,r=e.normal.array,a=e.uv.array,s=i.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new zi(new Float32Array(4*s),4));const o=this.getAttribute("tangent").array,l=[],c=[];for(let t=0;t<s;t++)l[t]=new cn,c[t]=new cn;const h=new cn,u=new cn,d=new cn,p=new Ie,m=new Ie,f=new Ie,g=new cn,v=new cn;function _(t,e,n){h.fromArray(i,3*t),u.fromArray(i,3*e),d.fromArray(i,3*n),p.fromArray(a,2*t),m.fromArray(a,2*e),f.fromArray(a,2*n),u.sub(h),d.sub(h),m.sub(p),f.sub(p);const r=1/(m.x*f.y-f.x*m.y);isFinite(r)&&(g.copy(u).multiplyScalar(f.y).addScaledVector(d,-m.y).multiplyScalar(r),v.copy(d).multiplyScalar(m.x).addScaledVector(u,-f.x).multiplyScalar(r),l[t].add(g),l[e].add(g),l[n].add(g),c[t].add(v),c[e].add(v),c[n].add(v))}let y=this.groups;0===y.length&&(y=[{start:0,count:n.length}]);for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)_(n[t+0],n[t+1],n[t+2])}const x=new cn,b=new cn,w=new cn,M=new cn;function S(t){w.fromArray(r,3*t),M.copy(w);const e=l[t];x.copy(e),x.sub(w.multiplyScalar(w.dot(e))).normalize(),b.crossVectors(M,e);const n=b.dot(c[t])<0?-1:1;o[4*t]=x.x,o[4*t+1]=x.y,o[4*t+2]=x.z,o[4*t+3]=n}for(let t=0,e=y.length;t<e;++t){const e=y[t],i=e.start;for(let t=i,r=i+e.count;t<r;t+=3)S(n[t+0]),S(n[t+1]),S(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new zi(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const i=new cn,r=new cn,a=new cn,s=new cn,o=new cn,l=new cn,c=new cn,h=new cn;if(t)for(let u=0,d=t.count;u<d;u+=3){const d=t.getX(u+0),p=t.getX(u+1),m=t.getX(u+2);i.fromBufferAttribute(e,d),r.fromBufferAttribute(e,p),a.fromBufferAttribute(e,m),c.subVectors(a,r),h.subVectors(i,r),c.cross(h),s.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),s.add(c),o.add(c),l.add(c),n.setXYZ(d,s.x,s.y,s.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,s=e.count;t<s;t+=3)i.fromBufferAttribute(e,t+0),r.fromBufferAttribute(e,t+1),a.fromBufferAttribute(e,t+2),c.subVectors(a,r),h.subVectors(i,r),c.cross(h),n.setXYZ(t+0,c.x,c.y,c.z),n.setXYZ(t+1,c.x,c.y,c.z),n.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Zi.fromBufferAttribute(t,e),Zi.normalize(),t.setXYZ(e,Zi.x,Zi.y,Zi.z)}toNonIndexed(){function t(t,e){const n=t.array,i=t.itemSize,r=t.normalized,a=new n.constructor(e.length*i);let s=0,o=0;for(let r=0,l=e.length;r<l;r++){s=t.isInterleavedBufferAttribute?e[r]*t.data.stride+t.offset:e[r]*i;for(let t=0;t<i;t++)a[o++]=n[s++]}return new zi(a,i,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ji,n=this.index.array,i=this.attributes;for(const r in i){const a=t(i[r],n);e.setAttribute(r,a)}const r=this.morphAttributes;for(const i in r){const a=[],s=r[i];for(let e=0,i=s.length;e<i;e++){const i=t(s[e],n);a.push(i)}e.morphAttributes[i]=a}e.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let t=0,n=a.length;t<n;t++){const n=a[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const i=n[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let r=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],a=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];a.push(i.toJSON(t.data))}a.length>0&&(i[e]=a,r=!0)}r&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(t.data.groups=JSON.parse(JSON.stringify(a)));const s=this.boundingSphere;return null!==s&&(t.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const i=t.attributes;for(const t in i){const n=i[t];this.setAttribute(t,n.clone(e))}const r=t.morphAttributes;for(const t in r){const n=[],i=r[t];for(let t=0,r=i.length;t<r;t++)n.push(i[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const a=t.groups;for(let t=0,e=a.length;t<e;t++){const e=a[t];this.addGroup(e.start,e.count,e.materialIndex)}const s=t.boundingBox;null!==s&&(this.boundingBox=s.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ki=new zn,Qi=new Bn,$i=new Pn,tr=new cn,er=new cn,nr=new cn,ir=new cn,rr=new cn,ar=new cn,sr=new Ie,or=new Ie,lr=new Ie,cr=new cn,hr=new cn,ur=new cn,dr=new cn,pr=new cn;class mr extends hi{constructor(t=new Ji,e=new Ii){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}getVertexPosition(t,e){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,a=n.morphTargetsRelative;e.fromBufferAttribute(i,t);const s=this.morphTargetInfluences;if(r&&s){ar.set(0,0,0);for(let n=0,i=r.length;n<i;n++){const i=s[n],o=r[n];0!==i&&(rr.fromBufferAttribute(o,t),a?ar.addScaledVector(rr,i):ar.addScaledVector(rr.sub(e),i))}e.add(ar)}return e}raycast(t,e){const n=this.geometry,i=this.material,r=this.matrixWorld;if(void 0!==i){if(null===n.boundingSphere&&n.computeBoundingSphere(),$i.copy(n.boundingSphere),$i.applyMatrix4(r),Qi.copy(t.ray).recast(t.near),!1===$i.containsPoint(Qi.origin)){if(null===Qi.intersectSphere($i,tr))return;if(Qi.origin.distanceToSquared(tr)>(t.far-t.near)**2)return}Ki.copy(r).invert(),Qi.copy(t.ray).applyMatrix4(Ki),null!==n.boundingBox&&!1===Qi.intersectsBox(n.boundingBox)||this._computeIntersections(t,e,Qi)}}_computeIntersections(t,e,n){let i;const r=this.geometry,a=this.material,s=r.index,o=r.attributes.position,l=r.attributes.uv,c=r.attributes.uv1,h=r.attributes.normal,u=r.groups,d=r.drawRange;if(null!==s)if(Array.isArray(a))for(let r=0,o=u.length;r<o;r++){const o=u[r],p=a[o.materialIndex];for(let r=Math.max(o.start,d.start),a=Math.min(s.count,Math.min(o.start+o.count,d.start+d.count));r<a;r+=3){i=fr(this,p,t,n,l,c,h,s.getX(r),s.getX(r+1),s.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=o.materialIndex,e.push(i))}}else{for(let r=Math.max(0,d.start),o=Math.min(s.count,d.start+d.count);r<o;r+=3){i=fr(this,a,t,n,l,c,h,s.getX(r),s.getX(r+1),s.getX(r+2)),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}else if(void 0!==o)if(Array.isArray(a))for(let r=0,s=u.length;r<s;r++){const s=u[r],p=a[s.materialIndex];for(let r=Math.max(s.start,d.start),a=Math.min(o.count,Math.min(s.start+s.count,d.start+d.count));r<a;r+=3){i=fr(this,p,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),i.face.materialIndex=s.materialIndex,e.push(i))}}else{for(let r=Math.max(0,d.start),s=Math.min(o.count,d.start+d.count);r<s;r+=3){i=fr(this,a,t,n,l,c,h,r,r+1,r+2),i&&(i.faceIndex=Math.floor(r/3),e.push(i))}}}}function fr(t,e,n,i,r,a,s,o,l,c){t.getVertexPosition(o,er),t.getVertexPosition(l,nr),t.getVertexPosition(c,ir);const h=function(t,e,n,i,r,a,s,o){let l;if(l=e.side===_?i.intersectTriangle(s,a,r,!0,o):i.intersectTriangle(r,a,s,e.side===v,o),null===l)return null;pr.copy(o),pr.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(pr);return c<n.near||c>n.far?null:{distance:c,point:pr.clone(),object:t}}(t,e,n,i,er,nr,ir,dr);if(h){r&&(sr.fromBufferAttribute(r,o),or.fromBufferAttribute(r,l),lr.fromBufferAttribute(r,c),h.uv=wi.getInterpolation(dr,er,nr,ir,sr,or,lr,new Ie)),a&&(sr.fromBufferAttribute(a,o),or.fromBufferAttribute(a,l),lr.fromBufferAttribute(a,c),h.uv1=wi.getInterpolation(dr,er,nr,ir,sr,or,lr,new Ie),h.uv2=h.uv1),s&&(cr.fromBufferAttribute(s,o),hr.fromBufferAttribute(s,l),ur.fromBufferAttribute(s,c),h.normal=wi.getInterpolation(dr,er,nr,ir,cr,hr,ur,new cn),h.normal.dot(i.direction)>0&&h.normal.multiplyScalar(-1));const t={a:o,b:l,c:c,normal:new cn,materialIndex:0};wi.getNormal(er,nr,ir,t.normal),h.face=t}return h}class gr extends Ji{constructor(t=1,e=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};const s=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const o=[],l=[],c=[],h=[];let u=0,d=0;function p(t,e,n,i,r,a,p,m,f,g,v){const _=a/f,y=p/g,x=a/2,b=p/2,w=m/2,M=f+1,S=g+1;let T=0,E=0;const A=new cn;for(let a=0;a<S;a++){const s=a*y-b;for(let o=0;o<M;o++){const u=o*_-x;A[t]=u*i,A[e]=s*r,A[n]=w,l.push(A.x,A.y,A.z),A[t]=0,A[e]=0,A[n]=m>0?1:-1,c.push(A.x,A.y,A.z),h.push(o/f),h.push(1-a/g),T+=1}}for(let t=0;t<g;t++)for(let e=0;e<f;e++){const n=u+e+M*t,i=u+e+M*(t+1),r=u+(e+1)+M*(t+1),a=u+(e+1)+M*t;o.push(n,i,a),o.push(i,r,a),E+=6}s.addGroup(d,E,v),d+=E,u+=T}p("z","y","x",-1,-1,n,e,t,a,r,0),p("z","y","x",1,-1,n,e,-t,a,r,1),p("x","z","y",1,1,t,n,e,i,a,2),p("x","z","y",1,-1,t,n,-e,i,a,3),p("x","y","z",1,-1,t,e,n,i,r,4),p("x","y","z",-1,-1,t,e,-n,i,r,5),this.setIndex(o),this.setAttribute("position",new Gi(l,3)),this.setAttribute("normal",new Gi(c,3)),this.setAttribute("uv",new Gi(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new gr(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function vr(t){const e={};for(const n in t){e[n]={};for(const i in t[n]){const r=t[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?r.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][i]=null):e[n][i]=r.clone():Array.isArray(r)?e[n][i]=r.slice():e[n][i]=r}}return e}function _r(t){const e={};for(let n=0;n<t.length;n++){const i=vr(t[n]);for(const t in i)e[t]=i[t]}return e}function yr(t){return null===t.getRenderTarget()?t.outputColorSpace:je.workingColorSpace}const xr={clone:vr,merge:_r};class br extends Pi{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=vr(t.uniforms),this.uniformsGroups=function(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const i=this.uniforms[n].value;i&&i.isTexture?e.uniforms[n]={type:"t",value:i.toJSON(t).uuid}:i&&i.isColor?e.uniforms[n]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[n]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[n]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[n]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[n]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[n]={type:"m4",value:i.toArray()}:e.uniforms[n]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}class wr extends hi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new zn,this.projectionMatrix=new zn,this.projectionMatrixInverse=new zn,this.coordinateSystem=fe}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class Mr extends wr{constructor(t=50,e=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*be*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*xe*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*be*Math.atan(Math.tan(.5*xe*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,r,a){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*xe*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i;const a=this.view;if(null!==this.view&&this.view.enabled){const t=a.fullWidth,s=a.fullHeight;r+=a.offsetX*i/t,e-=a.offsetY*n/s,i*=a.width/t,n*=a.height/s}const s=this.filmOffset;0!==s&&(r+=t*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const Sr=-90;class Tr extends hi{constructor(t,e,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Mr(Sr,1,t,e);i.layers=this.layers,this.add(i);const r=new Mr(Sr,1,t,e);r.layers=this.layers,this.add(r);const a=new Mr(Sr,1,t,e);a.layers=this.layers,this.add(a);const s=new Mr(Sr,1,t,e);s.layers=this.layers,this.add(s);const o=new Mr(Sr,1,t,e);o.layers=this.layers,this.add(o);const l=new Mr(Sr,1,t,e);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[n,i,r,a,s,o]=e;for(const t of e)this.remove(t);if(t===fe)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),s.up.set(0,1,0),s.lookAt(0,0,1),o.up.set(0,1,0),o.lookAt(0,0,-1);else{if(t!==ge)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),s.up.set(0,-1,0),s.lookAt(0,0,1),o.up.set(0,-1,0),o.lookAt(0,0,-1)}for(const t of e)this.add(t),t.updateMatrixWorld()}update(t,e){null===this.parent&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[r,a,s,o,l,c]=this.children,h=t.getRenderTarget(),u=t.getActiveCubeFace(),d=t.getActiveMipmapLevel(),p=t.xr.enabled;t.xr.enabled=!1;const m=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0,i),t.render(e,r),t.setRenderTarget(n,1,i),t.render(e,a),t.setRenderTarget(n,2,i),t.render(e,s),t.setRenderTarget(n,3,i),t.render(e,o),t.setRenderTarget(n,4,i),t.render(e,l),n.texture.generateMipmaps=m,t.setRenderTarget(n,5,i),t.render(e,c),t.setRenderTarget(h,u,d),t.xr.enabled=p,n.texture.needsPMREMUpdate=!0}}class Er extends tn{constructor(t,e,n,i,r,a,s,o,l,c){super(t=void 0!==t?t:[],e=void 0!==e?e:U,n,i,r,a,s,o,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class Ar extends rn{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const n={width:t,height:t,depth:1},i=[n,n,n,n,n,n];void 0!==e.encoding&&(ke("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),e.colorSpace=e.encoding===ee?ie:ne),this.texture=new Er(i,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:q}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},i=new gr(5,5,5),r=new br({name:"CubemapFromEquirect",uniforms:vr(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:_,blending:0});r.uniforms.tEquirect.value=e;const a=new mr(i,r),s=e.minFilter;e.minFilter===Z&&(e.minFilter=q);return new Tr(1,10,this).update(t,a),e.minFilter=s,a.geometry.dispose(),a.material.dispose(),this}clear(t,e,n,i){const r=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,n,i);t.setRenderTarget(r)}}const Rr=new cn,Cr=new cn,Pr=new Le;class Ir{constructor(t=new cn(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Rr.subVectors(n,e).cross(Cr.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const n=t.delta(Rr),i=this.normal.dot(n);if(0===i)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:e.copy(t.start).addScaledVector(n,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||Pr.getNormalMatrix(t),i=this.coplanarPoint(Rr).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Lr=new Pn,Dr=new cn;class Nr{constructor(t=new Ir,e=new Ir,n=new Ir,i=new Ir,r=new Ir,a=new Ir){this.planes=[t,e,n,i,r,a]}set(t,e,n,i,r,a){const s=this.planes;return s[0].copy(t),s[1].copy(e),s[2].copy(n),s[3].copy(i),s[4].copy(r),s[5].copy(a),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t,e=2e3){const n=this.planes,i=t.elements,r=i[0],a=i[1],s=i[2],o=i[3],l=i[4],c=i[5],h=i[6],u=i[7],d=i[8],p=i[9],m=i[10],f=i[11],g=i[12],v=i[13],_=i[14],y=i[15];if(n[0].setComponents(o-r,u-l,f-d,y-g).normalize(),n[1].setComponents(o+r,u+l,f+d,y+g).normalize(),n[2].setComponents(o+a,u+c,f+p,y+v).normalize(),n[3].setComponents(o-a,u-c,f-p,y-v).normalize(),n[4].setComponents(o-s,u-h,f-m,y-_).normalize(),e===fe)n[5].setComponents(o+s,u+h,f+m,y+_).normalize();else{if(e!==ge)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);n[5].setComponents(s,h,m,_).normalize()}return this}intersectsObject(t){if(void 0!==t.boundingSphere)null===t.boundingSphere&&t.computeBoundingSphere(),Lr.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;null===e.boundingSphere&&e.computeBoundingSphere(),Lr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Lr)}intersectsSprite(t){return Lr.center.set(0,0,0),Lr.radius=.7071067811865476,Lr.applyMatrix4(t.matrixWorld),this.intersectsSphere(Lr)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Dr.x=i.normal.x>0?t.max.x:t.min.x,Dr.y=i.normal.y>0?t.max.y:t.min.y,Dr.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Dr)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Or(){let t=null,e=!1,n=null,i=null;function r(e,a){n(e,a),i=t.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==n&&(i=t.requestAnimationFrame(r),e=!0)},stop:function(){t.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Ur(t,e){const n=e.isWebGL2,i=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),i.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=i.get(e);n&&(t.deleteBuffer(n.buffer),i.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){const t=i.get(e);return void((!t||t.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const a=i.get(e);if(void 0===a)i.set(e,function(e,i){const r=e.array,a=e.usage,s=r.byteLength,o=t.createBuffer();let l;if(t.bindBuffer(i,o),t.bufferData(i,r,a),e.onUploadCallback(),r instanceof Float32Array)l=t.FLOAT;else if(r instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");l=t.HALF_FLOAT}else l=t.UNSIGNED_SHORT;else if(r instanceof Int16Array)l=t.SHORT;else if(r instanceof Uint32Array)l=t.UNSIGNED_INT;else if(r instanceof Int32Array)l=t.INT;else if(r instanceof Int8Array)l=t.BYTE;else if(r instanceof Uint8Array)l=t.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);l=t.UNSIGNED_BYTE}return{buffer:o,type:l,bytesPerElement:r.BYTES_PER_ELEMENT,version:e.version,size:s}}(e,r));else if(a.version<e.version){if(a.size!==e.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(e,i,r){const a=i.array,s=i._updateRange,o=i.updateRanges;if(t.bindBuffer(r,e),-1===s.count&&0===o.length&&t.bufferSubData(r,0,a),0!==o.length){for(let e=0,i=o.length;e<i;e++){const i=o[e];n?t.bufferSubData(r,i.start*a.BYTES_PER_ELEMENT,a,i.start,i.count):t.bufferSubData(r,i.start*a.BYTES_PER_ELEMENT,a.subarray(i.start,i.start+i.count))}i.clearUpdateRanges()}-1!==s.count&&(n?t.bufferSubData(r,s.offset*a.BYTES_PER_ELEMENT,a,s.offset,s.count):t.bufferSubData(r,s.offset*a.BYTES_PER_ELEMENT,a.subarray(s.offset,s.offset+s.count)),s.count=-1),i.onUploadCallback()}(a.buffer,e,r),a.version=e.version}}}}class Fr extends Ji{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const r=t/2,a=e/2,s=Math.floor(n),o=Math.floor(i),l=s+1,c=o+1,h=t/s,u=e/o,d=[],p=[],m=[],f=[];for(let t=0;t<c;t++){const e=t*u-a;for(let n=0;n<l;n++){const i=n*h-r;p.push(i,-e,0),m.push(0,0,1),f.push(n/s),f.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<s;e++){const n=e+l*t,i=e+l*(t+1),r=e+1+l*(t+1),a=e+1+l*t;d.push(n,i,a),d.push(i,r,a)}this.setIndex(d),this.setAttribute("position",new Gi(p,3)),this.setAttribute("normal",new Gi(m,3)),this.setAttribute("uv",new Gi(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Fr(t.width,t.height,t.widthSegments,t.heightSegments)}}const Br={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},zr={common:{diffuse:{value:new Ai(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Le},alphaMap:{value:null},alphaMapTransform:{value:new Le},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Le}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Le}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Le}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Le},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Le},normalScale:{value:new Ie(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Le},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Le}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Le}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Le}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ai(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ai(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Le},alphaTest:{value:0},uvTransform:{value:new Le}},sprite:{diffuse:{value:new Ai(16777215)},opacity:{value:1},center:{value:new Ie(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Le},alphaMap:{value:null},alphaMapTransform:{value:new Le},alphaTest:{value:0}}},kr={basic:{uniforms:_r([zr.common,zr.specularmap,zr.envmap,zr.aomap,zr.lightmap,zr.fog]),vertexShader:Br.meshbasic_vert,fragmentShader:Br.meshbasic_frag},lambert:{uniforms:_r([zr.common,zr.specularmap,zr.envmap,zr.aomap,zr.lightmap,zr.emissivemap,zr.bumpmap,zr.normalmap,zr.displacementmap,zr.fog,zr.lights,{emissive:{value:new Ai(0)}}]),vertexShader:Br.meshlambert_vert,fragmentShader:Br.meshlambert_frag},phong:{uniforms:_r([zr.common,zr.specularmap,zr.envmap,zr.aomap,zr.lightmap,zr.emissivemap,zr.bumpmap,zr.normalmap,zr.displacementmap,zr.fog,zr.lights,{emissive:{value:new Ai(0)},specular:{value:new Ai(1118481)},shininess:{value:30}}]),vertexShader:Br.meshphong_vert,fragmentShader:Br.meshphong_frag},standard:{uniforms:_r([zr.common,zr.envmap,zr.aomap,zr.lightmap,zr.emissivemap,zr.bumpmap,zr.normalmap,zr.displacementmap,zr.roughnessmap,zr.metalnessmap,zr.fog,zr.lights,{emissive:{value:new Ai(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Br.meshphysical_vert,fragmentShader:Br.meshphysical_frag},toon:{uniforms:_r([zr.common,zr.aomap,zr.lightmap,zr.emissivemap,zr.bumpmap,zr.normalmap,zr.displacementmap,zr.gradientmap,zr.fog,zr.lights,{emissive:{value:new Ai(0)}}]),vertexShader:Br.meshtoon_vert,fragmentShader:Br.meshtoon_frag},matcap:{uniforms:_r([zr.common,zr.bumpmap,zr.normalmap,zr.displacementmap,zr.fog,{matcap:{value:null}}]),vertexShader:Br.meshmatcap_vert,fragmentShader:Br.meshmatcap_frag},points:{uniforms:_r([zr.points,zr.fog]),vertexShader:Br.points_vert,fragmentShader:Br.points_frag},dashed:{uniforms:_r([zr.common,zr.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Br.linedashed_vert,fragmentShader:Br.linedashed_frag},depth:{uniforms:_r([zr.common,zr.displacementmap]),vertexShader:Br.depth_vert,fragmentShader:Br.depth_frag},normal:{uniforms:_r([zr.common,zr.bumpmap,zr.normalmap,zr.displacementmap,{opacity:{value:1}}]),vertexShader:Br.meshnormal_vert,fragmentShader:Br.meshnormal_frag},sprite:{uniforms:_r([zr.sprite,zr.fog]),vertexShader:Br.sprite_vert,fragmentShader:Br.sprite_frag},background:{uniforms:{uvTransform:{value:new Le},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Br.background_vert,fragmentShader:Br.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Br.backgroundCube_vert,fragmentShader:Br.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Br.cube_vert,fragmentShader:Br.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Br.equirect_vert,fragmentShader:Br.equirect_frag},distanceRGBA:{uniforms:_r([zr.common,zr.displacementmap,{referencePosition:{value:new cn},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Br.distanceRGBA_vert,fragmentShader:Br.distanceRGBA_frag},shadow:{uniforms:_r([zr.lights,zr.fog,{color:{value:new Ai(0)},opacity:{value:1}}]),vertexShader:Br.shadow_vert,fragmentShader:Br.shadow_frag}};kr.physical={uniforms:_r([kr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Le},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Le},clearcoatNormalScale:{value:new Ie(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Le},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Le},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Le},sheen:{value:0},sheenColor:{value:new Ai(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Le},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Le},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Le},transmissionSamplerSize:{value:new Ie},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Le},attenuationDistance:{value:0},attenuationColor:{value:new Ai(0)},specularColor:{value:new Ai(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Le},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Le},anisotropyVector:{value:new Ie},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Le}}]),vertexShader:Br.meshphysical_vert,fragmentShader:Br.meshphysical_frag};const Hr={r:0,b:0,g:0};function Gr(t,e,n,i,r,a,s){const o=new Ai(0);let l,c,h=!0===a?0:1,u=null,d=0,p=null;function m(e,n){e.getRGB(Hr,yr(t)),i.buffers.color.setClear(Hr.r,Hr.g,Hr.b,n,s)}return{getClearColor:function(){return o},setClearColor:function(t,e=1){o.set(t),h=e,m(o,h)},getClearAlpha:function(){return h},setClearAlpha:function(t){h=t,m(o,h)},render:function(a,f){let g=!1,y=!0===f.isScene?f.background:null;if(y&&y.isTexture){y=(f.backgroundBlurriness>0?n:e).get(y)}null===y?m(o,h):y&&y.isColor&&(m(y,1),g=!0);const x=t.xr.getEnvironmentBlendMode();"additive"===x?i.buffers.color.setClear(0,0,0,1,s):"alpha-blend"===x&&i.buffers.color.setClear(0,0,0,0,s),(t.autoClear||g)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),y&&(y.isCubeTexture||y.mapping===k)?(void 0===c&&(c=new mr(new gr(1,1,1),new br({name:"BackgroundCubeMaterial",uniforms:vr(kr.backgroundCube.uniforms),vertexShader:kr.backgroundCube.vertexShader,fragmentShader:kr.backgroundCube.fragmentShader,side:_,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=y,c.material.uniforms.flipEnvMap.value=y.isCubeTexture&&!1===y.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=f.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=f.backgroundIntensity,c.material.toneMapped=je.getTransfer(y.colorSpace)!==le,u===y&&d===y.version&&p===t.toneMapping||(c.material.needsUpdate=!0,u=y,d=y.version,p=t.toneMapping),c.layers.enableAll(),a.unshift(c,c.geometry,c.material,0,0,null)):y&&y.isTexture&&(void 0===l&&(l=new mr(new Fr(2,2),new br({name:"BackgroundMaterial",uniforms:vr(kr.background.uniforms),vertexShader:kr.background.vertexShader,fragmentShader:kr.background.fragmentShader,side:v,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(l)),l.material.uniforms.t2D.value=y,l.material.uniforms.backgroundIntensity.value=f.backgroundIntensity,l.material.toneMapped=je.getTransfer(y.colorSpace)!==le,!0===y.matrixAutoUpdate&&y.updateMatrix(),l.material.uniforms.uvTransform.value.copy(y.matrix),u===y&&d===y.version&&p===t.toneMapping||(l.material.needsUpdate=!0,u=y,d=y.version,p=t.toneMapping),l.layers.enableAll(),a.unshift(l,l.geometry,l.material,0,0,null))}}}function Vr(t,e,n,i){const r=t.getParameter(t.MAX_VERTEX_ATTRIBS),a=i.isWebGL2?null:e.get("OES_vertex_array_object"),s=i.isWebGL2||null!==a,o={},l=p(null);let c=l,h=!1;function u(e){return i.isWebGL2?t.bindVertexArray(e):a.bindVertexArrayOES(e)}function d(e){return i.isWebGL2?t.deleteVertexArray(e):a.deleteVertexArrayOES(e)}function p(t){const e=[],n=[],i=[];for(let t=0;t<r;t++)e[t]=0,n[t]=0,i[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:i,object:t,attributes:{},index:null}}function m(){const t=c.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function f(t){g(t,0)}function g(n,r){const a=c.newAttributes,s=c.enabledAttributes,o=c.attributeDivisors;if(a[n]=1,0===s[n]&&(t.enableVertexAttribArray(n),s[n]=1),o[n]!==r){(i.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,r),o[n]=r}}function v(){const e=c.newAttributes,n=c.enabledAttributes;for(let i=0,r=n.length;i<r;i++)n[i]!==e[i]&&(t.disableVertexAttribArray(i),n[i]=0)}function _(e,n,i,r,a,s,o){!0===o?t.vertexAttribIPointer(e,n,i,a,s):t.vertexAttribPointer(e,n,i,r,a,s)}function y(){x(),h=!0,c!==l&&(c=l,u(c.object))}function x(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(r,l,d,y,x){let b=!1;if(s){const e=function(e,n,r){const s=!0===r.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let c=l[n.id];void 0===c&&(c={},l[n.id]=c);let h=c[s];void 0===h&&(h=p(i.isWebGL2?t.createVertexArray():a.createVertexArrayOES()),c[s]=h);return h}(y,d,l);c!==e&&(c=e,u(c.object)),b=function(t,e,n,i){const r=c.attributes,a=e.attributes;let s=0;const o=n.getAttributes();for(const e in o){if(o[e].location>=0){const n=r[e];let i=a[e];if(void 0===i&&("instanceMatrix"===e&&t.instanceMatrix&&(i=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(i=t.instanceColor)),void 0===n)return!0;if(n.attribute!==i)return!0;if(i&&n.data!==i.data)return!0;s++}}return c.attributesNum!==s||c.index!==i}(r,y,d,x),b&&function(t,e,n,i){const r={},a=e.attributes;let s=0;const o=n.getAttributes();for(const e in o){if(o[e].location>=0){let n=a[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const i={};i.attribute=n,n&&n.data&&(i.data=n.data),r[e]=i,s++}}c.attributes=r,c.attributesNum=s,c.index=i}(r,y,d,x)}else{const t=!0===l.wireframe;c.geometry===y.id&&c.program===d.id&&c.wireframe===t||(c.geometry=y.id,c.program=d.id,c.wireframe=t,b=!0)}null!==x&&n.update(x,t.ELEMENT_ARRAY_BUFFER),(b||h)&&(h=!1,function(r,a,s,o){if(!1===i.isWebGL2&&(r.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;m();const l=o.attributes,c=s.getAttributes(),h=a.defaultAttributeValues;for(const e in c){const a=c[e];if(a.location>=0){let s=l[e];if(void 0===s&&("instanceMatrix"===e&&r.instanceMatrix&&(s=r.instanceMatrix),"instanceColor"===e&&r.instanceColor&&(s=r.instanceColor)),void 0!==s){const e=s.normalized,l=s.itemSize,c=n.get(s);if(void 0===c)continue;const h=c.buffer,u=c.type,d=c.bytesPerElement,p=!0===i.isWebGL2&&(u===t.INT||u===t.UNSIGNED_INT||s.gpuType===tt);if(s.isInterleavedBufferAttribute){const n=s.data,i=n.stride,c=s.offset;if(n.isInstancedInterleavedBuffer){for(let t=0;t<a.locationSize;t++)g(a.location+t,n.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<a.locationSize;t++)f(a.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<a.locationSize;t++)_(a.location+t,l/a.locationSize,u,e,i*d,(c+l/a.locationSize*t)*d,p)}else{if(s.isInstancedBufferAttribute){for(let t=0;t<a.locationSize;t++)g(a.location+t,s.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let t=0;t<a.locationSize;t++)f(a.location+t);t.bindBuffer(t.ARRAY_BUFFER,h);for(let t=0;t<a.locationSize;t++)_(a.location+t,l/a.locationSize,u,e,l*d,l/a.locationSize*t*d,p)}}else if(void 0!==h){const n=h[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(a.location,n);break;case 3:t.vertexAttrib3fv(a.location,n);break;case 4:t.vertexAttrib4fv(a.location,n);break;default:t.vertexAttrib1fv(a.location,n)}}}}v()}(r,l,d,y),null!==x&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n.get(x).buffer))},reset:y,resetDefaultState:x,dispose:function(){y();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const i=n[t.id];for(const t in i)d(i[t].object),delete i[t];delete n[t.id]}},initAttributes:m,enableAttribute:f,disableUnusedAttributes:v}}function Wr(t,e,n,i){const r=i.isWebGL2;let a;this.setMode=function(t){a=t},this.render=function(e,i){t.drawArrays(a,e,i),n.update(i,a,1)},this.renderInstances=function(i,s,o){if(0===o)return;let l,c;if(r)l=t,c="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](a,i,s,o),n.update(s,a,o)},this.renderMultiDraw=function(t,i,r){if(0===r)return;const s=e.get("WEBGL_multi_draw");if(null===s)for(let e=0;e<r;e++)this.render(t[e],i[e]);else{s.multiDrawArraysWEBGL(a,t,0,i,0,r);let e=0;for(let t=0;t<r;t++)e+=i[t];n.update(e,a,1)}}}function jr(t,e,n){let i;function r(e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const a="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===t.constructor.name;let s=void 0!==n.precision?n.precision:"highp";const o=r(s);o!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",o,"instead."),s=o);const l=a||e.has("WEBGL_draw_buffers"),c=!0===n.logarithmicDepthBuffer,h=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=t.getParameter(t.MAX_TEXTURE_SIZE),p=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),m=t.getParameter(t.MAX_VERTEX_ATTRIBS),f=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),g=t.getParameter(t.MAX_VARYING_VECTORS),v=t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),_=u>0,y=a||e.has("OES_texture_float");return{isWebGL2:a,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");i=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:r,precision:s,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:v,vertexTextures:_,floatFragmentTextures:y,floatVertexTextures:_&&y,maxSamples:a?t.getParameter(t.MAX_SAMPLES):0}}function Xr(t){const e=this;let n=null,i=0,r=!1,a=!1;const s=new Ir,o=new Le,l={value:null,needsUpdate:!1};function c(t,n,i,r){const a=null!==t?t.length:0;let c=null;if(0!==a){if(c=l.value,!0!==r||null===c){const e=i+4*a,r=n.matrixWorldInverse;o.getNormalMatrix(r),(null===c||c.length<e)&&(c=new Float32Array(e));for(let e=0,n=i;e!==a;++e,n+=4)s.copy(t[e]).applyMatrix4(r,o),s.normal.toArray(c,n),c[n+3]=s.constant}l.value=c,l.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e){const n=0!==t.length||e||0!==i||r;return r=e,i=t.length,n},this.beginShadows=function(){a=!0,c(null)},this.endShadows=function(){a=!1},this.setGlobalState=function(t,e){n=c(t,e,0)},this.setState=function(s,o,h){const u=s.clippingPlanes,d=s.clipIntersection,p=s.clipShadows,m=t.get(s);if(!r||null===u||0===u.length||a&&!p)a?c(null):function(){l.value!==n&&(l.value=n,l.needsUpdate=i>0);e.numPlanes=i,e.numIntersection=0}();else{const t=a?0:i,e=4*t;let r=m.clippingState||null;l.value=r,r=c(u,o,e,h);for(let t=0;t!==e;++t)r[t]=n[t];m.clippingState=r,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function qr(t){let e=new WeakMap;function n(t,e){return e===B?t.mapping=U:e===z&&(t.mapping=F),t}function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const a=r.mapping;if(a===B||a===z){if(e.has(r)){return n(e.get(r).texture,r.mapping)}{const a=r.image;if(a&&a.height>0){const s=new Ar(a.height/2);return s.fromEquirectangularTexture(t,r),e.set(r,s),r.addEventListener("dispose",i),n(s.texture,r.mapping)}return null}}}return r},dispose:function(){e=new WeakMap}}}class Yr extends wr{constructor(t=-1,e=1,n=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,i,r,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-t,a=n+t,s=i+e,o=i-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=t*this.view.offsetX,a=r+t*this.view.width,s-=e*this.view.offsetY,o=s-e*this.view.height}this.projectionMatrix.makeOrthographic(r,a,s,o,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}const Zr=[.125,.215,.35,.446,.526,.582],Jr=20,Kr=new Yr,Qr=new Ai;let $r=null,ta=0,ea=0;const na=(1+Math.sqrt(5))/2,ia=1/na,ra=[new cn(1,1,1),new cn(-1,1,1),new cn(1,1,-1),new cn(-1,1,-1),new cn(0,na,ia),new cn(0,na,-ia),new cn(ia,0,na),new cn(-ia,0,na),new cn(na,ia,0),new cn(-na,ia,0)];class aa{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,i=100){$r=this._renderer.getRenderTarget(),ta=this._renderer.getActiveCubeFace(),ea=this._renderer.getActiveMipmapLevel(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(t,n,i,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=ca(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=la(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget($r,ta,ea),t.scissorTest=!1,oa(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===U||t.mapping===F?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),$r=this._renderer.getRenderTarget(),ta=this._renderer.getActiveCubeFace(),ea=this._renderer.getActiveMipmapLevel();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:q,minFilter:q,generateMipmaps:!1,type:it,format:ot,colorSpace:re,depthBuffer:!1},i=sa(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=sa(t,e,n);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],i=[];let r=t;const a=t-4+1+Zr.length;for(let s=0;s<a;s++){const a=Math.pow(2,r);n.push(a);let o=1/a;s>t-4?o=Zr[s-t+4-1]:0===s&&(o=0),i.push(o);const l=1/(a-2),c=-l,h=1+l,u=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,p=6,m=3,f=2,g=1,v=new Float32Array(m*p*d),_=new Float32Array(f*p*d),y=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,i=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];v.set(i,m*p*t),_.set(u,f*p*t);const r=[t,t,t,t,t,t];y.set(r,g*p*t)}const x=new Ji;x.setAttribute("position",new zi(v,m)),x.setAttribute("uv",new zi(_,f)),x.setAttribute("faceIndex",new zi(y,g)),e.push(x),r>4&&r--}return{lodPlanes:e,sizeLods:n,sigmas:i}}(i)),this._blurMaterial=function(t,e,n){const i=new Float32Array(Jr),r=new cn(0,1,0),a=new br({name:"SphericalGaussianBlur",defines:{n:Jr,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:ha(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1});return a}(i,t,e)}return i}_compileMaterial(t){const e=new mr(this._lodPlanes[0],t);this._renderer.compile(e,Kr)}_sceneToCubeUV(t,e,n,i){const r=new Mr(90,1,e,n),a=[1,-1,1,1,1,1],s=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(Qr),o.toneMapping=E,o.autoClear=!1;const h=new Ii({name:"PMREM.Background",side:_,depthWrite:!1,depthTest:!1}),u=new mr(new gr,h);let d=!1;const p=t.background;p?p.isColor&&(h.color.copy(p),t.background=null,d=!0):(h.color.copy(Qr),d=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(r.up.set(0,a[e],0),r.lookAt(s[e],0,0)):1===n?(r.up.set(0,0,a[e]),r.lookAt(0,s[e],0)):(r.up.set(0,a[e],0),r.lookAt(0,0,s[e]));const l=this._cubeSize;oa(i,n*l,e>2?l:0,l,l),o.setRenderTarget(i),d&&o.render(u,r),o.render(t,r)}u.geometry.dispose(),u.material.dispose(),o.toneMapping=c,o.autoClear=l,t.background=p}_textureToCubeUV(t,e){const n=this._renderer,i=t.mapping===U||t.mapping===F;i?(null===this._cubemapMaterial&&(this._cubemapMaterial=ca()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=la());const r=i?this._cubemapMaterial:this._equirectMaterial,a=new mr(this._lodPlanes[0],r);r.uniforms.envMap.value=t;const s=this._cubeSize;oa(e,0,0,3*s,2*s),n.setRenderTarget(e),n.render(a,Kr)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<this._lodPlanes.length;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),i=ra[(e-1)%ra.length];this._blur(t,e-1,e,n,i)}e.autoClear=n}_blur(t,e,n,i,r){const a=this._pingPongRenderTarget;this._halfBlur(t,a,e,n,i,"latitudinal",r),this._halfBlur(a,t,n,n,i,"longitudinal",r)}_halfBlur(t,e,n,i,r,a,s){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new mr(this._lodPlanes[i],l),h=l.uniforms,u=this._sizeLods[n]-1,d=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/d,m=isFinite(r)?1+Math.floor(3*p):Jr;m>Jr&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);const f=[];let g=0;for(let t=0;t<Jr;++t){const e=t/p,n=Math.exp(-e*e/2);f.push(n),0===t?g+=n:t<m&&(g+=2*n)}for(let t=0;t<f.length;t++)f[t]=f[t]/g;h.envMap.value=t.texture,h.samples.value=m,h.weights.value=f,h.latitudinal.value="latitudinal"===a,s&&(h.poleAxis.value=s);const{_lodMax:v}=this;h.dTheta.value=d,h.mipInt.value=v-n;const _=this._sizeLods[i];oa(e,3*_*(i>v-4?i-v+4:0),4*(this._cubeSize-_),3*_,2*_),o.setRenderTarget(e),o.render(c,Kr)}}function sa(t,e,n){const i=new rn(t,e,n);return i.texture.mapping=k,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function oa(t,e,n,i,r){t.viewport.set(e,n,i,r),t.scissor.set(e,n,i,r)}function la(){return new br({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:ha(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ca(){return new br({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:ha(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ha(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function ua(t){let e=new WeakMap,n=null;function i(t){const n=t.target;n.removeEventListener("dispose",i);const r=e.get(n);void 0!==r&&(e.delete(n),r.dispose())}return{get:function(r){if(r&&r.isTexture){const a=r.mapping,s=a===B||a===z,o=a===U||a===F;if(s||o){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;let i=e.get(r);return null===n&&(n=new aa(t)),i=s?n.fromEquirectangular(r,i):n.fromCubemap(r,i),e.set(r,i),i.texture}if(e.has(r))return e.get(r).texture;{const a=r.image;if(s&&a&&a.height>0||o&&a&&function(t){let e=0;const n=6;for(let i=0;i<n;i++)void 0!==t[i]&&e++;return e===n}(a)){null===n&&(n=new aa(t));const a=s?n.fromEquirectangular(r):n.fromCubemap(r);return e.set(r,a),r.addEventListener("dispose",i),a.texture}return null}}}return r},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function da(t){const e={};function n(n){if(void 0!==e[n])return e[n];let i;switch(n){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(n)}return e[n]=i,i}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?(n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance")):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function pa(t,e,n,i){const r={},a=new WeakMap;function s(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);for(const t in o.morphAttributes){const n=o.morphAttributes[t];for(let t=0,i=n.length;t<i;t++)e.remove(n[t])}o.removeEventListener("dispose",s),delete r[o.id];const l=a.get(o);l&&(e.remove(l),a.delete(o)),i.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],i=t.index,r=t.attributes.position;let s=0;if(null!==i){const t=i.array;s=i.version;for(let e=0,i=t.length;e<i;e+=3){const i=t[e+0],r=t[e+1],a=t[e+2];n.push(i,r,r,a,a,i)}}else{if(void 0===r)return;{const t=r.array;s=r.version;for(let e=0,i=t.length/3-1;e<i;e+=3){const t=e+0,i=e+1,r=e+2;n.push(t,i,i,r,r,t)}}}const o=new(Ne(n)?Hi:ki)(n,1);o.version=s;const l=a.get(t);l&&e.remove(l),a.set(t,o)}return{get:function(t,e){return!0===r[e.id]||(e.addEventListener("dispose",s),r[e.id]=!0,n.memory.geometries++),e},update:function(n){const i=n.attributes;for(const n in i)e.update(i[n],t.ARRAY_BUFFER);const r=n.morphAttributes;for(const n in r){const i=r[n];for(let n=0,r=i.length;n<r;n++)e.update(i[n],t.ARRAY_BUFFER)}},getWireframeAttribute:function(t){const e=a.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return a.get(t)}}}function ma(t,e,n,i){const r=i.isWebGL2;let a,s,o;this.setMode=function(t){a=t},this.setIndex=function(t){s=t.type,o=t.bytesPerElement},this.render=function(e,i){t.drawElements(a,i,s,e*o),n.update(i,a,1)},this.renderInstances=function(i,l,c){if(0===c)return;let h,u;if(r)h=t,u="drawElementsInstanced";else if(h=e.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](a,l,s,i*o,c),n.update(l,a,c)},this.renderMultiDraw=function(t,i,r){if(0===r)return;const l=e.get("WEBGL_multi_draw");if(null===l)for(let e=0;e<r;e++)this.render(t[e]/o,i[e]);else{l.multiDrawElementsWEBGL(a,i,0,s,t,0,r);let e=0;for(let t=0;t<r;t++)e+=i[t];n.update(e,a,1)}}}function fa(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,i,r){switch(e.calls++,i){case t.TRIANGLES:e.triangles+=r*(n/3);break;case t.LINES:e.lines+=r*(n/2);break;case t.LINE_STRIP:e.lines+=r*(n-1);break;case t.LINE_LOOP:e.lines+=r*n;break;case t.POINTS:e.points+=r*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function ga(t,e){return t[0]-e[0]}function va(t,e){return Math.abs(e[1])-Math.abs(t[1])}function _a(t,e,n){const i={},r=new Float32Array(8),a=new WeakMap,s=new en,o=[];for(let t=0;t<8;t++)o[t]=[t,0];return{update:function(l,c,h){const u=l.morphTargetInfluences;if(!0===e.isWebGL2){const d=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,p=void 0!==d?d.length:0;let m=a.get(c);if(void 0===m||m.count!==p){void 0!==m&&m.texture.dispose();const v=void 0!==c.morphAttributes.position,_=void 0!==c.morphAttributes.normal,y=void 0!==c.morphAttributes.color,x=c.morphAttributes.position||[],b=c.morphAttributes.normal||[],w=c.morphAttributes.color||[];let M=0;!0===v&&(M=1),!0===_&&(M=2),!0===y&&(M=3);let S=c.attributes.position.count*M,T=1;S>e.maxTextureSize&&(T=Math.ceil(S/e.maxTextureSize),S=e.maxTextureSize);const E=new Float32Array(S*T*4*p),A=new an(E,S,T,p);A.type=nt,A.needsUpdate=!0;const R=4*M;for(let P=0;P<p;P++){const I=x[P],L=b[P],D=w[P],N=S*T*4*P;for(let O=0;O<I.count;O++){const U=O*R;!0===v&&(s.fromBufferAttribute(I,O),E[N+U+0]=s.x,E[N+U+1]=s.y,E[N+U+2]=s.z,E[N+U+3]=0),!0===_&&(s.fromBufferAttribute(L,O),E[N+U+4]=s.x,E[N+U+5]=s.y,E[N+U+6]=s.z,E[N+U+7]=0),!0===y&&(s.fromBufferAttribute(D,O),E[N+U+8]=s.x,E[N+U+9]=s.y,E[N+U+10]=s.z,E[N+U+11]=4===D.itemSize?s.w:1)}}function C(){A.dispose(),a.delete(c),c.removeEventListener("dispose",C)}m={count:p,texture:A,size:new Ie(S,T)},a.set(c,m),c.addEventListener("dispose",C)}let f=0;for(let F=0;F<u.length;F++)f+=u[F];const g=c.morphTargetsRelative?1:1-f;h.getUniforms().setValue(t,"morphTargetBaseInfluence",g),h.getUniforms().setValue(t,"morphTargetInfluences",u),h.getUniforms().setValue(t,"morphTargetsTexture",m.texture,n),h.getUniforms().setValue(t,"morphTargetsTextureSize",m.size)}else{const B=void 0===u?0:u.length;let z=i[c.id];if(void 0===z||z.length!==B){z=[];for(let W=0;W<B;W++)z[W]=[W,0];i[c.id]=z}for(let j=0;j<B;j++){const X=z[j];X[0]=j,X[1]=u[j]}z.sort(va);for(let q=0;q<8;q++)q<B&&z[q][1]?(o[q][0]=z[q][0],o[q][1]=z[q][1]):(o[q][0]=Number.MAX_SAFE_INTEGER,o[q][1]=0);o.sort(ga);const k=c.morphAttributes.position,H=c.morphAttributes.normal;let G=0;for(let Y=0;Y<8;Y++){const Z=o[Y],J=Z[0],K=Z[1];J!==Number.MAX_SAFE_INTEGER&&K?(k&&c.getAttribute("morphTarget"+Y)!==k[J]&&c.setAttribute("morphTarget"+Y,k[J]),H&&c.getAttribute("morphNormal"+Y)!==H[J]&&c.setAttribute("morphNormal"+Y,H[J]),r[Y]=K,G+=K):(k&&!0===c.hasAttribute("morphTarget"+Y)&&c.deleteAttribute("morphTarget"+Y),H&&!0===c.hasAttribute("morphNormal"+Y)&&c.deleteAttribute("morphNormal"+Y),r[Y]=0)}const V=c.morphTargetsRelative?1:1-G;h.getUniforms().setValue(t,"morphTargetBaseInfluence",V),h.getUniforms().setValue(t,"morphTargetInfluences",r)}}}}function ya(t,e,n,i){let r=new WeakMap;function a(t){const e=t.target;e.removeEventListener("dispose",a),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(s){const o=i.render.frame,l=s.geometry,c=e.get(s,l);if(r.get(c)!==o&&(e.update(c),r.set(c,o)),s.isInstancedMesh&&(!1===s.hasEventListener("dispose",a)&&s.addEventListener("dispose",a),r.get(s)!==o&&(n.update(s.instanceMatrix,t.ARRAY_BUFFER),null!==s.instanceColor&&n.update(s.instanceColor,t.ARRAY_BUFFER),r.set(s,o))),s.isSkinnedMesh){const t=s.skeleton;r.get(t)!==o&&(t.update(),r.set(t,o))}return c},dispose:function(){r=new WeakMap}}}class xa extends tn{constructor(t,e,n,i,r,a,s,o,l,c){if((c=void 0!==c?c:lt)!==lt&&c!==ct)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===lt&&(n=et),void 0===n&&c===ct&&(n=st),super(null,i,r,a,s,o,c,n,l),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=void 0!==s?s:W,this.minFilter=void 0!==o?o:W,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return null!==this.compareFunction&&(e.compareFunction=this.compareFunction),e}}const ba=new tn,wa=new xa(1,1);wa.compareFunction=515;const Ma=new an,Sa=new on,Ta=new Er,Ea=[],Aa=[],Ra=new Float32Array(16),Ca=new Float32Array(9),Pa=new Float32Array(4);function Ia(t,e,n){const i=t[0];if(i<=0||i>0)return t;const r=e*n;let a=Ea[r];if(void 0===a&&(a=new Float32Array(r),Ea[r]=a),0!==e){i.toArray(a,0);for(let i=1,r=0;i!==e;++i)r+=n,t[i].toArray(a,r)}return a}function La(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function Da(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}function Na(t,e){let n=Aa[e];void 0===n&&(n=new Int32Array(e),Aa[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocateTextureUnit();return n}function Oa(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ua(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(La(n,e))return;t.uniform2fv(this.addr,e),Da(n,e)}}function Fa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(La(n,e))return;t.uniform3fv(this.addr,e),Da(n,e)}}function Ba(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(La(n,e))return;t.uniform4fv(this.addr,e),Da(n,e)}}function za(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(La(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Da(n,e)}else{if(La(n,i))return;Pa.set(i),t.uniformMatrix2fv(this.addr,!1,Pa),Da(n,i)}}function ka(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(La(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Da(n,e)}else{if(La(n,i))return;Ca.set(i),t.uniformMatrix3fv(this.addr,!1,Ca),Da(n,i)}}function Ha(t,e){const n=this.cache,i=e.elements;if(void 0===i){if(La(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Da(n,e)}else{if(La(n,i))return;Ra.set(i),t.uniformMatrix4fv(this.addr,!1,Ra),Da(n,i)}}function Ga(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Va(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(La(n,e))return;t.uniform2iv(this.addr,e),Da(n,e)}}function Wa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(La(n,e))return;t.uniform3iv(this.addr,e),Da(n,e)}}function ja(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(La(n,e))return;t.uniform4iv(this.addr,e),Da(n,e)}}function Xa(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function qa(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(La(n,e))return;t.uniform2uiv(this.addr,e),Da(n,e)}}function Ya(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(La(n,e))return;t.uniform3uiv(this.addr,e),Da(n,e)}}function Za(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(La(n,e))return;t.uniform4uiv(this.addr,e),Da(n,e)}}function Ja(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r);const a=this.type===t.SAMPLER_2D_SHADOW?wa:ba;n.setTexture2D(e||a,r)}function Ka(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Sa,r)}function Qa(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTextureCube(e||Ta,r)}function $a(t,e,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||Ma,r)}function ts(t,e){t.uniform1fv(this.addr,e)}function es(t,e){const n=Ia(e,this.size,2);t.uniform2fv(this.addr,n)}function ns(t,e){const n=Ia(e,this.size,3);t.uniform3fv(this.addr,n)}function is(t,e){const n=Ia(e,this.size,4);t.uniform4fv(this.addr,n)}function rs(t,e){const n=Ia(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function as(t,e){const n=Ia(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function ss(t,e){const n=Ia(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function os(t,e){t.uniform1iv(this.addr,e)}function ls(t,e){t.uniform2iv(this.addr,e)}function cs(t,e){t.uniform3iv(this.addr,e)}function hs(t,e){t.uniform4iv(this.addr,e)}function us(t,e){t.uniform1uiv(this.addr,e)}function ds(t,e){t.uniform2uiv(this.addr,e)}function ps(t,e){t.uniform3uiv(this.addr,e)}function ms(t,e){t.uniform4uiv(this.addr,e)}function fs(t,e,n){const i=this.cache,r=e.length,a=Na(n,r);La(i,a)||(t.uniform1iv(this.addr,a),Da(i,a));for(let t=0;t!==r;++t)n.setTexture2D(e[t]||ba,a[t])}function gs(t,e,n){const i=this.cache,r=e.length,a=Na(n,r);La(i,a)||(t.uniform1iv(this.addr,a),Da(i,a));for(let t=0;t!==r;++t)n.setTexture3D(e[t]||Sa,a[t])}function vs(t,e,n){const i=this.cache,r=e.length,a=Na(n,r);La(i,a)||(t.uniform1iv(this.addr,a),Da(i,a));for(let t=0;t!==r;++t)n.setTextureCube(e[t]||Ta,a[t])}function _s(t,e,n){const i=this.cache,r=e.length,a=Na(n,r);La(i,a)||(t.uniform1iv(this.addr,a),Da(i,a));for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||Ma,a[t])}class ys{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.setValue=function(t){switch(t){case 5126:return Oa;case 35664:return Ua;case 35665:return Fa;case 35666:return Ba;case 35674:return za;case 35675:return ka;case 35676:return Ha;case 5124:case 35670:return Ga;case 35667:case 35671:return Va;case 35668:case 35672:return Wa;case 35669:case 35673:return ja;case 5125:return Xa;case 36294:return qa;case 36295:return Ya;case 36296:return Za;case 35678:case 36198:case 36298:case 36306:case 35682:return Ja;case 35679:case 36299:case 36307:return Ka;case 35680:case 36300:case 36308:case 36293:return Qa;case 36289:case 36303:case 36311:case 36292:return $a}}(e.type)}}class xs{constructor(t,e,n){this.id=t,this.addr=n,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=function(t){switch(t){case 5126:return ts;case 35664:return es;case 35665:return ns;case 35666:return is;case 35674:return rs;case 35675:return as;case 35676:return ss;case 5124:case 35670:return os;case 35667:case 35671:return ls;case 35668:case 35672:return cs;case 35669:case 35673:return hs;case 5125:return us;case 36294:return ds;case 36295:return ps;case 36296:return ms;case 35678:case 36198:case 36298:case 36306:case 35682:return fs;case 35679:case 36299:case 36307:return gs;case 35680:case 36300:case 36308:case 36293:return vs;case 36289:case 36303:case 36311:case 36292:return _s}}(e.type)}}class bs{constructor(t){this.id=t,this.seq=[],this.map={}}setValue(t,e,n){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const a=i[r];a.setValue(t,e[a.id],n)}}}const ws=/(\w+)(\])?(\[|\.)?/g;function Ms(t,e){t.seq.push(e),t.map[e.id]=e}function Ss(t,e,n){const i=t.name,r=i.length;for(ws.lastIndex=0;;){const a=ws.exec(i),s=ws.lastIndex;let o=a[1];const l="]"===a[2],c=a[3];if(l&&(o|=0),void 0===c||"["===c&&s+2===r){Ms(n,void 0===c?new ys(o,t,e):new xs(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new bs(o),Ms(n,t)),n=t}}}class Ts{constructor(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i);Ss(n,t.getUniformLocation(e,n.name),this)}}setValue(t,e,n,i){const r=this.map[e];void 0!==r&&r.setValue(t,n,i)}setOptional(t,e,n){const i=e[n];void 0!==i&&this.setValue(t,n,i)}static upload(t,e,n,i){for(let r=0,a=e.length;r!==a;++r){const a=e[r],s=n[a.id];!1!==s.needsUpdate&&a.setValue(t,s.value,i)}}static seqWithValue(t,e){const n=[];for(let i=0,r=t.length;i!==r;++i){const r=t[i];r.id in e&&n.push(r)}return n}}function Es(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}const As=37297;let Rs=0;function Cs(t,e,n){const i=t.getShaderParameter(e,t.COMPILE_STATUS),r=t.getShaderInfoLog(e).trim();if(i&&""===r)return"";const a=/ERROR: 0:(\d+)/.exec(r);if(a){const i=parseInt(a[1]);return n.toUpperCase()+"\n\n"+r+"\n\n"+function(t,e){const n=t.split("\n"),i=[],r=Math.max(e-6,0),a=Math.min(e+6,n.length);for(let t=r;t<a;t++){const r=t+1;i.push(`${r===e?">":" "} ${r}: ${n[t]}`)}return i.join("\n")}(t.getShaderSource(e),i)}return r}function Ps(t,e){const n=function(t){const e=je.getPrimaries(je.workingColorSpace),n=je.getPrimaries(t);let i;switch(e===n?i="":e===he&&n===ce?i="LinearDisplayP3ToLinearSRGB":e===ce&&n===he&&(i="LinearSRGBToLinearDisplayP3"),t){case re:case se:return[i,"LinearTransferOETF"];case ie:case ae:return[i,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",t),[i,"LinearTransferOETF"]}}(e);return`vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`}function Is(t,e){let n;switch(e){case A:n="Linear";break;case R:n="Reinhard";break;case C:n="OptimizedCineon";break;case P:n="ACESFilmic";break;case L:n="AgX";break;case I:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Ls(t){return""!==t}function Ds(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Ns(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Os=/^[ \t]*#include +<([\w\d./]+)>/gm;function Us(t){return t.replace(Os,Bs)}const Fs=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function Bs(t,e){let n=Br[e];if(void 0===n){const t=Fs.get(e);if(void 0===t)throw new Error("Can not resolve #include <"+e+">");n=Br[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,t)}return Us(n)}const zs=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ks(t){return t.replace(zs,Hs)}function Hs(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function Gs(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Vs(t,e,n,i){const r=t.getContext(),a=n.defines;let s=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===m?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===f?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===g&&(e="SHADOWMAP_TYPE_VSM"),e}(n),c=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case U:case F:e="ENVMAP_TYPE_CUBE";break;case k:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),h=function(t){let e="ENVMAP_MODE_REFLECTION";t.envMap&&t.envMapMode===F&&(e="ENVMAP_MODE_REFRACTION");return e}(n),u=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case M:e="ENVMAP_BLENDING_MULTIPLY";break;case S:e="ENVMAP_BLENDING_MIX";break;case T:e="ENVMAP_BLENDING_ADD"}return e}(n),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:i,maxMip:n}}(n),p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUVHeight||t.bumpMap||t.normalMapTangentSpace||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ls).join("\n")}(n),v=function(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":""].filter(Ls).join("\n")}(n),_=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(a),y=r.createProgram();let x,b,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(x=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_].filter(Ls).join("\n"),x.length>0&&(x+="\n"),b=[p,"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_].filter(Ls).join("\n"),b.length>0&&(b+="\n")):(x=[Gs(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+h:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Ls).join("\n"),b=[p,Gs(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,_,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",n.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==E?"#define TONE_MAPPING":"",n.toneMapping!==E?Br.tonemapping_pars_fragment:"",n.toneMapping!==E?Is("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Br.colorspace_pars_fragment,Ps("linearToOutputTexel",n.outputColorSpace),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Ls).join("\n")),s=Us(s),s=Ds(s,n),s=Ns(s,n),o=Us(o),o=Ds(o,n),o=Ns(o,n),s=ks(s),o=ks(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",x=[v,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+x,b=["precision mediump sampler2DArray;","#define varying in",n.glslVersion===pe?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===pe?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const A=w+x+s,R=w+b+o,C=Es(r,r.VERTEX_SHADER,A),P=Es(r,r.FRAGMENT_SHADER,R);function I(e){if(t.debug.checkShaderErrors){const n=r.getProgramInfoLog(y).trim(),i=r.getShaderInfoLog(C).trim(),a=r.getShaderInfoLog(P).trim();let s=!0,o=!0;if(!1===r.getProgramParameter(y,r.LINK_STATUS))if(s=!1,"function"==typeof t.debug.onShaderError)t.debug.onShaderError(r,y,C,P);else{const t=Cs(r,C,"vertex"),e=Cs(r,P,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(y,r.VALIDATE_STATUS)+"\n\nProgram Info Log: "+n+"\n"+t+"\n"+e)}else""!==n?console.warn("THREE.WebGLProgram: Program Info Log:",n):""!==i&&""!==a||(o=!1);o&&(e.diagnostics={runnable:s,programLog:n,vertexShader:{log:i,prefix:x},fragmentShader:{log:a,prefix:b}})}r.deleteShader(C),r.deleteShader(P),L=new Ts(r,y),D=function(t,e){const n={},i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r),a=i.name;let s=1;i.type===t.FLOAT_MAT2&&(s=2),i.type===t.FLOAT_MAT3&&(s=3),i.type===t.FLOAT_MAT4&&(s=4),n[a]={type:i.type,location:t.getAttribLocation(e,a),locationSize:s}}return n}(r,y)}let L,D;r.attachShader(y,C),r.attachShader(y,P),void 0!==n.index0AttributeName?r.bindAttribLocation(y,0,n.index0AttributeName):!0===n.morphTargets&&r.bindAttribLocation(y,0,"position"),r.linkProgram(y),this.getUniforms=function(){return void 0===L&&I(this),L},this.getAttributes=function(){return void 0===D&&I(this),D};let N=!1===n.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===N&&(N=r.getProgramParameter(y,As)),N},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(y),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=Rs++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=C,this.fragmentShader=P,this}let Ws=0;class js{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,i=this._getShaderStage(e),r=this._getShaderStage(n),a=this._getShaderCacheForMaterial(t);return!1===a.has(i)&&(a.add(i),i.usedTimes++),!1===a.has(r)&&(a.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;let n=e.get(t);return void 0===n&&(n=new Set,e.set(t,n)),n}_getShaderStage(t){const e=this.shaderCache;let n=e.get(t);return void 0===n&&(n=new Xs(t),e.set(t,n)),n}}class Xs{constructor(t){this.id=Ws++,this.code=t,this.usedTimes=0}}function qs(t,e,n,i,r,a,s){const o=new Jn,l=new js,c=[],h=r.isWebGL2,u=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function f(t){return 0===t?"uv":`uv${t}`}return{getParameters:function(a,o,c,g,v){const x=g.fog,b=v.geometry,w=a.isMeshStandardMaterial?g.environment:null,M=(a.isMeshStandardMaterial?n:e).get(a.envMap||w),S=M&&M.mapping===k?M.image.height:null,T=m[a.type];null!==a.precision&&(p=r.getMaxPrecision(a.precision),p!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead."));const A=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,R=void 0!==A?A.length:0;let C,P,I,L,D=0;if(void 0!==b.morphAttributes.position&&(D=1),void 0!==b.morphAttributes.normal&&(D=2),void 0!==b.morphAttributes.color&&(D=3),T){const t=kr[T];C=t.vertexShader,P=t.fragmentShader}else C=a.vertexShader,P=a.fragmentShader,l.update(a),I=l.getVertexShaderID(a),L=l.getFragmentShaderID(a);const N=t.getRenderTarget(),O=!0===v.isInstancedMesh,U=!0===v.isBatchedMesh,F=!!a.map,B=!!a.matcap,z=!!M,H=!!a.aoMap,G=!!a.lightMap,V=!!a.bumpMap,W=!!a.normalMap,j=!!a.displacementMap,X=!!a.emissiveMap,q=!!a.metalnessMap,Y=!!a.roughnessMap,Z=a.anisotropy>0,J=a.clearcoat>0,K=a.iridescence>0,Q=a.sheen>0,$=a.transmission>0,tt=Z&&!!a.anisotropyMap,et=J&&!!a.clearcoatMap,nt=J&&!!a.clearcoatNormalMap,it=J&&!!a.clearcoatRoughnessMap,rt=K&&!!a.iridescenceMap,at=K&&!!a.iridescenceThicknessMap,st=Q&&!!a.sheenColorMap,ot=Q&&!!a.sheenRoughnessMap,lt=!!a.specularMap,ct=!!a.specularColorMap,ht=!!a.specularIntensityMap,ut=$&&!!a.transmissionMap,dt=$&&!!a.thicknessMap,pt=!!a.gradientMap,mt=!!a.alphaMap,ft=a.alphaTest>0,gt=!!a.alphaHash,vt=!!a.extensions,_t=!!b.attributes.uv1,yt=!!b.attributes.uv2,xt=!!b.attributes.uv3;let bt=E;return a.toneMapped&&(null!==N&&!0!==N.isXRRenderTarget||(bt=t.toneMapping)),{isWebGL2:h,shaderID:T,shaderType:a.type,shaderName:a.name,vertexShader:C,fragmentShader:P,defines:a.defines,customVertexShaderID:I,customFragmentShaderID:L,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,batching:U,instancing:O,instancingColor:O&&null!==v.instanceColor,supportsVertexTextures:d,outputColorSpace:null===N?t.outputColorSpace:!0===N.isXRRenderTarget?N.texture.colorSpace:re,map:F,matcap:B,envMap:z,envMapMode:z&&M.mapping,envMapCubeUVHeight:S,aoMap:H,lightMap:G,bumpMap:V,normalMap:W,displacementMap:d&&j,emissiveMap:X,normalMapObjectSpace:W&&1===a.normalMapType,normalMapTangentSpace:W&&0===a.normalMapType,metalnessMap:q,roughnessMap:Y,anisotropy:Z,anisotropyMap:tt,clearcoat:J,clearcoatMap:et,clearcoatNormalMap:nt,clearcoatRoughnessMap:it,iridescence:K,iridescenceMap:rt,iridescenceThicknessMap:at,sheen:Q,sheenColorMap:st,sheenRoughnessMap:ot,specularMap:lt,specularColorMap:ct,specularIntensityMap:ht,transmission:$,transmissionMap:ut,thicknessMap:dt,gradientMap:pt,opaque:!1===a.transparent&&1===a.blending,alphaMap:mt,alphaTest:ft,alphaHash:gt,combine:a.combine,mapUv:F&&f(a.map.channel),aoMapUv:H&&f(a.aoMap.channel),lightMapUv:G&&f(a.lightMap.channel),bumpMapUv:V&&f(a.bumpMap.channel),normalMapUv:W&&f(a.normalMap.channel),displacementMapUv:j&&f(a.displacementMap.channel),emissiveMapUv:X&&f(a.emissiveMap.channel),metalnessMapUv:q&&f(a.metalnessMap.channel),roughnessMapUv:Y&&f(a.roughnessMap.channel),anisotropyMapUv:tt&&f(a.anisotropyMap.channel),clearcoatMapUv:et&&f(a.clearcoatMap.channel),clearcoatNormalMapUv:nt&&f(a.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:it&&f(a.clearcoatRoughnessMap.channel),iridescenceMapUv:rt&&f(a.iridescenceMap.channel),iridescenceThicknessMapUv:at&&f(a.iridescenceThicknessMap.channel),sheenColorMapUv:st&&f(a.sheenColorMap.channel),sheenRoughnessMapUv:ot&&f(a.sheenRoughnessMap.channel),specularMapUv:lt&&f(a.specularMap.channel),specularColorMapUv:ct&&f(a.specularColorMap.channel),specularIntensityMapUv:ht&&f(a.specularIntensityMap.channel),transmissionMapUv:ut&&f(a.transmissionMap.channel),thicknessMapUv:dt&&f(a.thicknessMap.channel),alphaMapUv:mt&&f(a.alphaMap.channel),vertexTangents:!!b.attributes.tangent&&(W||Z),vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,vertexUv1s:_t,vertexUv2s:yt,vertexUv3s:xt,pointsUvs:!0===v.isPoints&&!!b.attributes.uv&&(F||mt),fog:!!x,useFog:!0===a.fog,fogExp2:x&&x.isFogExp2,flatShading:!0===a.flatShading,sizeAttenuation:!0===a.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===v.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:R,morphTextureStride:D,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numSpotLightMaps:o.spotLightMap.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numSpotLightShadowsWithMaps:o.numSpotLightShadowsWithMaps,numLightProbes:o.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:a.dithering,shadowMapEnabled:t.shadowMap.enabled&&c.length>0,shadowMapType:t.shadowMap.type,toneMapping:bt,useLegacyLights:t._useLegacyLights,decodeVideoTexture:F&&!0===a.map.isVideoTexture&&je.getTransfer(a.map.colorSpace)===le,premultipliedAlpha:a.premultipliedAlpha,doubleSided:a.side===y,flipSided:a.side===_,useDepthPacking:a.depthPacking>=0,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionDerivatives:vt&&!0===a.extensions.derivatives,extensionFragDepth:vt&&!0===a.extensions.fragDepth,extensionDrawBuffers:vt&&!0===a.extensions.drawBuffers,extensionShaderTextureLOD:vt&&!0===a.extensions.shaderTextureLOD,extensionClipCullDistance:vt&&a.extensions.clipCullDistance&&i.has("WEBGL_clip_cull_distance"),rendererExtensionFragDepth:h||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||i.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:a.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(!function(t,e){t.push(e.precision),t.push(e.outputColorSpace),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.mapUv),t.push(e.alphaMapUv),t.push(e.lightMapUv),t.push(e.aoMapUv),t.push(e.bumpMapUv),t.push(e.normalMapUv),t.push(e.displacementMapUv),t.push(e.emissiveMapUv),t.push(e.metalnessMapUv),t.push(e.roughnessMapUv),t.push(e.anisotropyMapUv),t.push(e.clearcoatMapUv),t.push(e.clearcoatNormalMapUv),t.push(e.clearcoatRoughnessMapUv),t.push(e.iridescenceMapUv),t.push(e.iridescenceThicknessMapUv),t.push(e.sheenColorMapUv),t.push(e.sheenRoughnessMapUv),t.push(e.specularMapUv),t.push(e.specularColorMapUv),t.push(e.specularIntensityMapUv),t.push(e.transmissionMapUv),t.push(e.thicknessMapUv),t.push(e.combine),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numSpotLightMaps),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.numSpotLightShadowsWithMaps),t.push(e.numLightProbes),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){o.disableAll(),e.isWebGL2&&o.enable(0);e.supportsVertexTextures&&o.enable(1);e.instancing&&o.enable(2);e.instancingColor&&o.enable(3);e.matcap&&o.enable(4);e.envMap&&o.enable(5);e.normalMapObjectSpace&&o.enable(6);e.normalMapTangentSpace&&o.enable(7);e.clearcoat&&o.enable(8);e.iridescence&&o.enable(9);e.alphaTest&&o.enable(10);e.vertexColors&&o.enable(11);e.vertexAlphas&&o.enable(12);e.vertexUv1s&&o.enable(13);e.vertexUv2s&&o.enable(14);e.vertexUv3s&&o.enable(15);e.vertexTangents&&o.enable(16);e.anisotropy&&o.enable(17);e.alphaHash&&o.enable(18);e.batching&&o.enable(19);t.push(o.mask),o.disableAll(),e.fog&&o.enable(0);e.useFog&&o.enable(1);e.flatShading&&o.enable(2);e.logarithmicDepthBuffer&&o.enable(3);e.skinning&&o.enable(4);e.morphTargets&&o.enable(5);e.morphNormals&&o.enable(6);e.morphColors&&o.enable(7);e.premultipliedAlpha&&o.enable(8);e.shadowMapEnabled&&o.enable(9);e.useLegacyLights&&o.enable(10);e.doubleSided&&o.enable(11);e.flipSided&&o.enable(12);e.useDepthPacking&&o.enable(13);e.dithering&&o.enable(14);e.transmission&&o.enable(15);e.sheen&&o.enable(16);e.opaque&&o.enable(17);e.pointsUvs&&o.enable(18);e.decodeVideoTexture&&o.enable(19);t.push(o.mask)}(n,e),n.push(t.outputColorSpace)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=m[t.type];let n;if(e){const t=kr[e];n=xr.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let i;for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.cacheKey===n){i=e,++i.usedTimes;break}}return void 0===i&&(i=new Vs(t,n,e,a),c.push(i)),i},releaseProgram:function(t){if(0==--t.usedTimes){const e=c.indexOf(t);c[e]=c[c.length-1],c.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:c,dispose:function(){l.dispose()}}}function Ys(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,i){t.get(e)[n]=i},dispose:function(){t=new WeakMap}}}function Zs(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Js(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Ks(){const t=[];let e=0;const n=[],i=[],r=[];function a(n,i,r,a,s,o){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:i,material:r,groupOrder:a,renderOrder:n.renderOrder,z:s,group:o},t[e]=l):(l.id=n.id,l.object=n,l.geometry=i,l.material=r,l.groupOrder=a,l.renderOrder=n.renderOrder,l.z=s,l.group=o),e++,l}return{opaque:n,transmissive:i,transparent:r,init:function(){e=0,n.length=0,i.length=0,r.length=0},push:function(t,e,s,o,l,c){const h=a(t,e,s,o,l,c);s.transmission>0?i.push(h):!0===s.transparent?r.push(h):n.push(h)},unshift:function(t,e,s,o,l,c){const h=a(t,e,s,o,l,c);s.transmission>0?i.unshift(h):!0===s.transparent?r.unshift(h):n.unshift(h)},finish:function(){for(let n=e,i=t.length;n<i;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||Zs),i.length>1&&i.sort(e||Js),r.length>1&&r.sort(e||Js)}}}function Qs(){let t=new WeakMap;return{get:function(e,n){const i=t.get(e);let r;return void 0===i?(r=new Ks,t.set(e,[r])):n>=i.length?(r=new Ks,i.push(r)):r=i[n],r},dispose:function(){t=new WeakMap}}}function $s(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new cn,color:new Ai};break;case"SpotLight":n={position:new cn,direction:new cn,color:new Ai,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new cn,color:new Ai,distance:0,decay:0};break;case"HemisphereLight":n={direction:new cn,skyColor:new Ai,groundColor:new Ai};break;case"RectAreaLight":n={color:new Ai,position:new cn,halfWidth:new cn,halfHeight:new cn}}return t[e.id]=n,n}}}let to=0;function eo(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function no(t,e){const n=new $s,i=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ie};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ie,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let t=0;t<9;t++)r.probe.push(new cn);const a=new cn,s=new zn,o=new zn;return{setup:function(a,s){let o=0,l=0,c=0;for(let t=0;t<9;t++)r.probe[t].set(0,0,0);let h=0,u=0,d=0,p=0,m=0,f=0,g=0,v=0,_=0,y=0,x=0;a.sort(eo);const b=!0===s?Math.PI:1;for(let t=0,e=a.length;t<e;t++){const e=a[t],s=e.color,w=e.intensity,M=e.distance,S=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=s.r*w*b,l+=s.g*w*b,c+=s.b*w*b;else if(e.isLightProbe){for(let t=0;t<9;t++)r.probe[t].addScaledVector(e.sh.coefficients[t],w);x++}else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*b),e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,r.directionalShadow[h]=n,r.directionalShadowMap[h]=S,r.directionalShadowMatrix[h]=e.shadow.matrix,f++}r.directional[h]=t,h++}else if(e.isSpotLight){const t=n.get(e);t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(s).multiplyScalar(w*b),t.distance=M,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,r.spot[d]=t;const a=e.shadow;if(e.map&&(r.spotLightMap[_]=e.map,_++,a.updateMatrices(e),e.castShadow&&y++),r.spotLightMatrix[d]=a.matrix,e.castShadow){const t=i.get(e);t.shadowBias=a.bias,t.shadowNormalBias=a.normalBias,t.shadowRadius=a.radius,t.shadowMapSize=a.mapSize,r.spotShadow[d]=t,r.spotShadowMap[d]=S,v++}d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(s).multiplyScalar(w),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),r.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*b),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=i.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,r.pointShadow[u]=n,r.pointShadowMap[u]=S,r.pointShadowMatrix[u]=e.shadow.matrix,g++}r.point[u]=t,u++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(w*b),t.groundColor.copy(e.groundColor).multiplyScalar(w*b),r.hemi[m]=t,m++}}p>0&&(e.isWebGL2?!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=zr.LTC_FLOAT_1,r.rectAreaLTC2=zr.LTC_FLOAT_2):(r.rectAreaLTC1=zr.LTC_HALF_1,r.rectAreaLTC2=zr.LTC_HALF_2):!0===t.has("OES_texture_float_linear")?(r.rectAreaLTC1=zr.LTC_FLOAT_1,r.rectAreaLTC2=zr.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=zr.LTC_HALF_1,r.rectAreaLTC2=zr.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=o,r.ambient[1]=l,r.ambient[2]=c;const w=r.hash;w.directionalLength===h&&w.pointLength===u&&w.spotLength===d&&w.rectAreaLength===p&&w.hemiLength===m&&w.numDirectionalShadows===f&&w.numPointShadows===g&&w.numSpotShadows===v&&w.numSpotMaps===_&&w.numLightProbes===x||(r.directional.length=h,r.spot.length=d,r.rectArea.length=p,r.point.length=u,r.hemi.length=m,r.directionalShadow.length=f,r.directionalShadowMap.length=f,r.pointShadow.length=g,r.pointShadowMap.length=g,r.spotShadow.length=v,r.spotShadowMap.length=v,r.directionalShadowMatrix.length=f,r.pointShadowMatrix.length=g,r.spotLightMatrix.length=v+_-y,r.spotLightMap.length=_,r.numSpotLightShadowsWithMaps=y,r.numLightProbes=x,w.directionalLength=h,w.pointLength=u,w.spotLength=d,w.rectAreaLength=p,w.hemiLength=m,w.numDirectionalShadows=f,w.numPointShadows=g,w.numSpotShadows=v,w.numSpotMaps=_,w.numLightProbes=x,r.version=to++)},setupView:function(t,e){let n=0,i=0,l=0,c=0,h=0;const u=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=r.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(a),t.direction.transformDirection(u),n++}else if(d.isSpotLight){const t=r.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),t.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(a),t.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const t=r.rectArea[c];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),o.identity(),s.copy(d.matrixWorld),s.premultiply(u),o.extractRotation(s),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),c++}else if(d.isPointLight){const t=r.point[i];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(u),i++}else if(d.isHemisphereLight){const t=r.hemi[h];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(u),h++}}},state:r}}function io(t,e){const n=new no(t,e),i=[],r=[];return{init:function(){i.length=0,r.length=0},state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:function(t){n.setup(i,t)},setupLightsView:function(t){n.setupView(i,t)},pushLight:function(t){i.push(t)},pushShadow:function(t){r.push(t)}}}function ro(t,e){let n=new WeakMap;return{get:function(i,r=0){const a=n.get(i);let s;return void 0===a?(s=new io(t,e),n.set(i,[s])):r>=a.length?(s=new io(t,e),a.push(s)):s=a[r],s},dispose:function(){n=new WeakMap}}}class ao extends Pi{constructor(t){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}class so extends Pi{constructor(t){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function oo(t,e,n){let i=new Nr;const r=new Ie,a=new Ie,s=new en,o=new ao({depthPacking:3201}),l=new so,c={},h=n.maxTextureSize,u={[v]:_,[_]:v,[y]:y},d=new br({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ie},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Ji;f.setAttribute("position",new zi(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new mr(f,d),b=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=m;let w=this.type;function M(n,i){const a=e.update(x);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),null===n.mapPass&&(n.mapPass=new rn(r.x,r.y)),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(i,null,a,d,x,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(i,null,a,p,x,null)}function S(e,n,i,r){let a=null;const s=!0===i.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(void 0!==s)a=s;else if(a=!0===i.isPointLight?l:o,t.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0){const t=a.uuid,e=n.uuid;let i=c[t];void 0===i&&(i={},c[t]=i);let r=i[e];void 0===r&&(r=a.clone(),i[e]=r,n.addEventListener("dispose",E)),a=r}if(a.visible=n.visible,a.wireframe=n.wireframe,a.side=r===g?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:u[n.side],a.alphaMap=n.alphaMap,a.alphaTest=n.alphaTest,a.map=n.map,a.clipShadows=n.clipShadows,a.clippingPlanes=n.clippingPlanes,a.clipIntersection=n.clipIntersection,a.displacementMap=n.displacementMap,a.displacementScale=n.displacementScale,a.displacementBias=n.displacementBias,a.wireframeLinewidth=n.wireframeLinewidth,a.linewidth=n.linewidth,!0===i.isPointLight&&!0===a.isMeshDistanceMaterial){t.properties.get(a).light=i}return a}function T(n,r,a,s,o){if(!1===n.visible)return;if(n.layers.test(r.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&o===g)&&(!n.frustumCulled||i.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,n.matrixWorld);const i=e.update(n),l=n.material;if(Array.isArray(l)){const e=i.groups;for(let c=0,h=e.length;c<h;c++){const h=e[c],u=l[h.materialIndex];if(u&&u.visible){const e=S(n,u,s,o);n.onBeforeShadow(t,n,r,a,i,e,h),t.renderBufferDirect(a,null,i,e,n,h),n.onAfterShadow(t,n,r,a,i,e,h)}}}else if(l.visible){const e=S(n,l,s,o);n.onBeforeShadow(t,n,r,a,i,e,null),t.renderBufferDirect(a,null,i,e,n,null),n.onAfterShadow(t,n,r,a,i,e,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)T(l[t],r,a,s,o)}function E(t){t.target.removeEventListener("dispose",E);for(const e in c){const n=c[e],i=t.target.uuid;if(i in n){n[i].dispose(),delete n[i]}}}this.render=function(e,n,o){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),c=t.getActiveCubeFace(),u=t.getActiveMipmapLevel(),d=t.state;d.setBlending(0),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);const p=w!==g&&this.type===g,m=w===g&&this.type!==g;for(let l=0,c=e.length;l<c;l++){const c=e[l],u=c.shadow;if(void 0===u){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===u.autoUpdate&&!1===u.needsUpdate)continue;r.copy(u.mapSize);const f=u.getFrameExtents();if(r.multiply(f),a.copy(u.mapSize),(r.x>h||r.y>h)&&(r.x>h&&(a.x=Math.floor(h/f.x),r.x=a.x*f.x,u.mapSize.x=a.x),r.y>h&&(a.y=Math.floor(h/f.y),r.y=a.y*f.y,u.mapSize.y=a.y)),null===u.map||!0===p||!0===m){const t=this.type!==g?{minFilter:W,magFilter:W}:{};null!==u.map&&u.map.dispose(),u.map=new rn(r.x,r.y,t),u.map.texture.name=c.name+".shadowMap",u.camera.updateProjectionMatrix()}t.setRenderTarget(u.map),t.clear();const v=u.getViewportCount();for(let t=0;t<v;t++){const e=u.getViewport(t);s.set(a.x*e.x,a.y*e.y,a.x*e.z,a.y*e.w),d.viewport(s),u.updateMatrices(c,t),i=u.getFrustum(),T(n,o,u.camera,c,this.type)}!0!==u.isPointLightShadow&&this.type===g&&M(u,o),u.needsUpdate=!1}w=this.type,b.needsUpdate=!1,t.setRenderTarget(l,c,u)}}function lo(t,e,n){const i=n.isWebGL2;const r=new function(){let e=!1;const n=new en;let i=null;const r=new en(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,a,s,o){!0===o&&(e*=s,i*=s,a*=s),n.set(e,i,a,s),!1===r.equals(n)&&(t.clearColor(e,i,a,s),r.copy(n))},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}},a=new function(){let e=!1,n=null,i=null,r=null;return{setTest:function(e){e?q(t.DEPTH_TEST):Y(t.DEPTH_TEST)},setMask:function(i){n===i||e||(t.depthMask(i),n=i)},setFunc:function(e){if(i!==e){switch(e){case 0:t.depthFunc(t.NEVER);break;case 1:t.depthFunc(t.ALWAYS);break;case 2:t.depthFunc(t.LESS);break;case 3:default:t.depthFunc(t.LEQUAL);break;case 4:t.depthFunc(t.EQUAL);break;case 5:t.depthFunc(t.GEQUAL);break;case 6:t.depthFunc(t.GREATER);break;case 7:t.depthFunc(t.NOTEQUAL)}i=e}},setLocked:function(t){e=t},setClear:function(e){r!==e&&(t.clearDepth(e),r=e)},reset:function(){e=!1,n=null,i=null,r=null}}},s=new function(){let e=!1,n=null,i=null,r=null,a=null,s=null,o=null,l=null,c=null;return{setTest:function(n){e||(n?q(t.STENCIL_TEST):Y(t.STENCIL_TEST))},setMask:function(i){n===i||e||(t.stencilMask(i),n=i)},setFunc:function(e,n,s){i===e&&r===n&&a===s||(t.stencilFunc(e,n,s),i=e,r=n,a=s)},setOp:function(e,n,i){s===e&&o===n&&l===i||(t.stencilOp(e,n,i),s=e,o=n,l=i)},setLocked:function(t){e=t},setClear:function(e){c!==e&&(t.clearStencil(e),c=e)},reset:function(){e=!1,n=null,i=null,r=null,a=null,s=null,o=null,l=null,c=null}}},o=new WeakMap,l=new WeakMap;let c={},h={},u=new WeakMap,d=[],p=null,m=!1,f=null,g=null,v=null,M=null,S=null,T=null,E=null,A=new Ai(0,0,0),R=0,C=!1,P=null,I=null,L=null,D=null,N=null;const O=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let U=!1,F=0;const B=t.getParameter(t.VERSION);-1!==B.indexOf("WebGL")?(F=parseFloat(/^WebGL (\d)/.exec(B)[1]),U=F>=1):-1!==B.indexOf("OpenGL ES")&&(F=parseFloat(/^OpenGL ES (\d)/.exec(B)[1]),U=F>=2);let z=null,k={};const H=t.getParameter(t.SCISSOR_BOX),G=t.getParameter(t.VIEWPORT),V=(new en).fromArray(H),W=(new en).fromArray(G);function j(e,n,r,a){const s=new Uint8Array(4),o=t.createTexture();t.bindTexture(e,o),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let o=0;o<r;o++)!i||e!==t.TEXTURE_3D&&e!==t.TEXTURE_2D_ARRAY?t.texImage2D(n+o,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,s):t.texImage3D(n,0,t.RGBA,1,1,a,0,t.RGBA,t.UNSIGNED_BYTE,s);return o}const X={};function q(e){!0!==c[e]&&(t.enable(e),c[e]=!0)}function Y(e){!1!==c[e]&&(t.disable(e),c[e]=!1)}X[t.TEXTURE_2D]=j(t.TEXTURE_2D,t.TEXTURE_2D,1),X[t.TEXTURE_CUBE_MAP]=j(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),i&&(X[t.TEXTURE_2D_ARRAY]=j(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),X[t.TEXTURE_3D]=j(t.TEXTURE_3D,t.TEXTURE_3D,1,1)),r.setClear(0,0,0,1),a.setClear(1),s.setClear(0),q(t.DEPTH_TEST),a.setFunc(3),Q(!1),$(1),q(t.CULL_FACE),K(0);const Z={[x]:t.FUNC_ADD,101:t.FUNC_SUBTRACT,102:t.FUNC_REVERSE_SUBTRACT};if(i)Z[103]=t.MIN,Z[104]=t.MAX;else{const t=e.get("EXT_blend_minmax");null!==t&&(Z[103]=t.MIN_EXT,Z[104]=t.MAX_EXT)}const J={200:t.ZERO,201:t.ONE,202:t.SRC_COLOR,[b]:t.SRC_ALPHA,210:t.SRC_ALPHA_SATURATE,208:t.DST_COLOR,206:t.DST_ALPHA,203:t.ONE_MINUS_SRC_COLOR,[w]:t.ONE_MINUS_SRC_ALPHA,209:t.ONE_MINUS_DST_COLOR,207:t.ONE_MINUS_DST_ALPHA,211:t.CONSTANT_COLOR,212:t.ONE_MINUS_CONSTANT_COLOR,213:t.CONSTANT_ALPHA,214:t.ONE_MINUS_CONSTANT_ALPHA};function K(e,n,i,r,a,s,o,l,c,h){if(0!==e){if(!1===m&&(q(t.BLEND),m=!0),5===e)a=a||n,s=s||i,o=o||r,n===g&&a===S||(t.blendEquationSeparate(Z[n],Z[a]),g=n,S=a),i===v&&r===M&&s===T&&o===E||(t.blendFuncSeparate(J[i],J[r],J[s],J[o]),v=i,M=r,T=s,E=o),!1!==l.equals(A)&&c===R||(t.blendColor(l.r,l.g,l.b,c),A.copy(l),R=c),f=e,C=!1;else if(e!==f||h!==C){if(g===x&&S===x||(t.blendEquation(t.FUNC_ADD),g=x,S=x),h)switch(e){case 1:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.ONE,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case 2:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case 3:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case 4:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}v=null,M=null,T=null,E=null,A.set(0,0,0),R=0,f=e,C=h}}else!0===m&&(Y(t.BLEND),m=!1)}function Q(e){P!==e&&(e?t.frontFace(t.CW):t.frontFace(t.CCW),P=e)}function $(e){0!==e?(q(t.CULL_FACE),e!==I&&(1===e?t.cullFace(t.BACK):2===e?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):Y(t.CULL_FACE),I=e}function tt(e,n,i){e?(q(t.POLYGON_OFFSET_FILL),D===n&&N===i||(t.polygonOffset(n,i),D=n,N=i)):Y(t.POLYGON_OFFSET_FILL)}return{buffers:{color:r,depth:a,stencil:s},enable:q,disable:Y,bindFramebuffer:function(e,n){return h[e]!==n&&(t.bindFramebuffer(e,n),h[e]=n,i&&(e===t.DRAW_FRAMEBUFFER&&(h[t.FRAMEBUFFER]=n),e===t.FRAMEBUFFER&&(h[t.DRAW_FRAMEBUFFER]=n)),!0)},drawBuffers:function(i,r){let a=d,s=!1;if(i)if(a=u.get(r),void 0===a&&(a=[],u.set(r,a)),i.isWebGLMultipleRenderTargets){const e=i.texture;if(a.length!==e.length||a[0]!==t.COLOR_ATTACHMENT0){for(let n=0,i=e.length;n<i;n++)a[n]=t.COLOR_ATTACHMENT0+n;a.length=e.length,s=!0}}else a[0]!==t.COLOR_ATTACHMENT0&&(a[0]=t.COLOR_ATTACHMENT0,s=!0);else a[0]!==t.BACK&&(a[0]=t.BACK,s=!0);s&&(n.isWebGL2?t.drawBuffers(a):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))},useProgram:function(e){return p!==e&&(t.useProgram(e),p=e,!0)},setBlending:K,setMaterial:function(e,n){e.side===y?Y(t.CULL_FACE):q(t.CULL_FACE);let i=e.side===_;n&&(i=!i),Q(i),1===e.blending&&!1===e.transparent?K(0):K(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.blendColor,e.blendAlpha,e.premultipliedAlpha),a.setFunc(e.depthFunc),a.setTest(e.depthTest),a.setMask(e.depthWrite),r.setMask(e.colorWrite);const o=e.stencilWrite;s.setTest(o),o&&(s.setMask(e.stencilWriteMask),s.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),s.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),tt(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?q(t.SAMPLE_ALPHA_TO_COVERAGE):Y(t.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:Q,setCullFace:$,setLineWidth:function(e){e!==L&&(U&&t.lineWidth(e),L=e)},setPolygonOffset:tt,setScissorTest:function(e){e?q(t.SCISSOR_TEST):Y(t.SCISSOR_TEST)},activeTexture:function(e){void 0===e&&(e=t.TEXTURE0+O-1),z!==e&&(t.activeTexture(e),z=e)},bindTexture:function(e,n,i){void 0===i&&(i=null===z?t.TEXTURE0+O-1:z);let r=k[i];void 0===r&&(r={type:void 0,texture:void 0},k[i]=r),r.type===e&&r.texture===n||(z!==i&&(t.activeTexture(i),z=i),t.bindTexture(e,n||X[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=k[z];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexImage3D:function(){try{t.compressedTexImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function(e,n){let i=l.get(n);void 0===i&&(i=new WeakMap,l.set(n,i));let r=i.get(e);void 0===r&&(r=t.getUniformBlockIndex(n,e.name),i.set(e,r))},uniformBlockBinding:function(e,n){const i=l.get(n).get(e);o.get(n)!==i&&(t.uniformBlockBinding(n,i,e.__bindingPointIndex),o.set(n,i))},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage3D:function(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===V.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),V.copy(e))},viewport:function(e){!1===W.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),W.copy(e))},reset:function(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),!0===i&&(t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),c={},z=null,k={},h={},u=new WeakMap,d=[],p=null,m=!1,f=null,g=null,v=null,M=null,S=null,T=null,E=null,A=new Ai(0,0,0),R=0,C=!1,P=null,I=null,L=null,D=null,N=null,V.set(0,0,t.canvas.width,t.canvas.height),W.set(0,0,t.canvas.width,t.canvas.height),r.reset(),a.reset(),s.reset()}}}function co(t,e,n,i,r,a,s){const o=r.isWebGL2,l=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,c="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),h=new WeakMap;let u;const d=new WeakMap;let p=!1;try{p="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function m(t,e){return p?new OffscreenCanvas(t,e):Fe("canvas")}function f(t,e,n,i){let r=1;if((t.width>i||t.height>i)&&(r=i/Math.max(t.width,t.height)),r<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const i=e?Ae:Math.floor,a=i(r*t.width),s=i(r*t.height);void 0===u&&(u=m(a,s));const o=n?m(a,s):u;o.width=a,o.height=s;return o.getContext("2d").drawImage(t,0,0,a,s),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+a+"x"+s+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function g(t){return Ee(t.width)&&Ee(t.height)}function v(t,e){return t.generateMipmaps&&e&&t.minFilter!==W&&t.minFilter!==q}function _(e){t.generateMipmap(e)}function y(n,i,r,a,s=!1){if(!1===o)return i;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=i;if(i===t.RED&&(r===t.FLOAT&&(l=t.R32F),r===t.HALF_FLOAT&&(l=t.R16F),r===t.UNSIGNED_BYTE&&(l=t.R8)),i===t.RED_INTEGER&&(r===t.UNSIGNED_BYTE&&(l=t.R8UI),r===t.UNSIGNED_SHORT&&(l=t.R16UI),r===t.UNSIGNED_INT&&(l=t.R32UI),r===t.BYTE&&(l=t.R8I),r===t.SHORT&&(l=t.R16I),r===t.INT&&(l=t.R32I)),i===t.RG&&(r===t.FLOAT&&(l=t.RG32F),r===t.HALF_FLOAT&&(l=t.RG16F),r===t.UNSIGNED_BYTE&&(l=t.RG8)),i===t.RGBA){const e=s?oe:je.getTransfer(a);r===t.FLOAT&&(l=t.RGBA32F),r===t.HALF_FLOAT&&(l=t.RGBA16F),r===t.UNSIGNED_BYTE&&(l=e===le?t.SRGB8_ALPHA8:t.RGBA8),r===t.UNSIGNED_SHORT_4_4_4_4&&(l=t.RGBA4),r===t.UNSIGNED_SHORT_5_5_5_1&&(l=t.RGB5_A1)}return l!==t.R16F&&l!==t.R32F&&l!==t.RG16F&&l!==t.RG32F&&l!==t.RGBA16F&&l!==t.RGBA32F||e.get("EXT_color_buffer_float"),l}function x(t,e,n){return!0===v(t,n)||t.isFramebufferTexture&&t.minFilter!==W&&t.minFilter!==q?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function b(e){return e===W||e===j||e===X?t.NEAREST:t.LINEAR}function w(t){const e=t.target;e.removeEventListener("dispose",w),function(t){const e=i.get(t);if(void 0===e.__webglInit)return;const n=t.source,r=d.get(n);if(r){const i=r[e.__cacheKey];i.usedTimes--,0===i.usedTimes&&S(t),0===Object.keys(r).length&&d.delete(n)}i.remove(t)}(e),e.isVideoTexture&&h.delete(e)}function M(e){const n=e.target;n.removeEventListener("dispose",M),function(e){const n=e.texture,r=i.get(e),a=i.get(n);void 0!==a.__webglTexture&&(t.deleteTexture(a.__webglTexture),s.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++){if(Array.isArray(r.__webglFramebuffer[e]))for(let n=0;n<r.__webglFramebuffer[e].length;n++)t.deleteFramebuffer(r.__webglFramebuffer[e][n]);else t.deleteFramebuffer(r.__webglFramebuffer[e]);r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer[e])}else{if(Array.isArray(r.__webglFramebuffer))for(let e=0;e<r.__webglFramebuffer.length;e++)t.deleteFramebuffer(r.__webglFramebuffer[e]);else t.deleteFramebuffer(r.__webglFramebuffer);if(r.__webglDepthbuffer&&t.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&t.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer)for(let e=0;e<r.__webglColorRenderbuffer.length;e++)r.__webglColorRenderbuffer[e]&&t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);r.__webglDepthRenderbuffer&&t.deleteRenderbuffer(r.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);r.__webglTexture&&(t.deleteTexture(r.__webglTexture),s.memory.textures--),i.remove(n[e])}i.remove(n),i.remove(e)}(n)}function S(e){const n=i.get(e);t.deleteTexture(n.__webglTexture);const r=e.source;delete d.get(r)[n.__cacheKey],s.memory.textures--}let T=0;function E(e,r){const a=i.get(e);if(e.isVideoTexture&&function(t){const e=s.render.frame;h.get(t)!==e&&(h.set(t,e),t.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&a.__version!==e.version){const t=e.image;if(null===t)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==t.complete)return void L(a,e,r);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.bindTexture(t.TEXTURE_2D,a.__webglTexture,t.TEXTURE0+r)}const A={[H]:t.REPEAT,[G]:t.CLAMP_TO_EDGE,[V]:t.MIRRORED_REPEAT},R={[W]:t.NEAREST,[j]:t.NEAREST_MIPMAP_NEAREST,[X]:t.NEAREST_MIPMAP_LINEAR,[q]:t.LINEAR,[Y]:t.LINEAR_MIPMAP_NEAREST,[Z]:t.LINEAR_MIPMAP_LINEAR},C={512:t.NEVER,519:t.ALWAYS,513:t.LESS,515:t.LEQUAL,514:t.EQUAL,518:t.GEQUAL,516:t.GREATER,517:t.NOTEQUAL};function P(n,a,s){if(s?(t.texParameteri(n,t.TEXTURE_WRAP_S,A[a.wrapS]),t.texParameteri(n,t.TEXTURE_WRAP_T,A[a.wrapT]),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,A[a.wrapR]),t.texParameteri(n,t.TEXTURE_MAG_FILTER,R[a.magFilter]),t.texParameteri(n,t.TEXTURE_MIN_FILTER,R[a.minFilter])):(t.texParameteri(n,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(n,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),n!==t.TEXTURE_3D&&n!==t.TEXTURE_2D_ARRAY||t.texParameteri(n,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),a.wrapS===G&&a.wrapT===G||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,t.TEXTURE_MAG_FILTER,b(a.magFilter)),t.texParameteri(n,t.TEXTURE_MIN_FILTER,b(a.minFilter)),a.minFilter!==W&&a.minFilter!==q&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),a.compareFunction&&(t.texParameteri(n,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(n,t.TEXTURE_COMPARE_FUNC,C[a.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){const s=e.get("EXT_texture_filter_anisotropic");if(a.magFilter===W)return;if(a.minFilter!==X&&a.minFilter!==Z)return;if(a.type===nt&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&a.type===it&&!1===e.has("OES_texture_half_float_linear"))return;(a.anisotropy>1||i.get(a).__currentAnisotropy)&&(t.texParameterf(n,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,r.getMaxAnisotropy())),i.get(a).__currentAnisotropy=a.anisotropy)}}function I(e,n){let i=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",w));const r=n.source;let a=d.get(r);void 0===a&&(a={},d.set(r,a));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.wrapR||0),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.colorSpace),e.join()}(n);if(o!==e.__cacheKey){void 0===a[o]&&(a[o]={texture:t.createTexture(),usedTimes:0},s.memory.textures++,i=!0),a[o].usedTimes++;const r=a[e.__cacheKey];void 0!==r&&(a[e.__cacheKey].usedTimes--,0===r.usedTimes&&S(n)),e.__cacheKey=o,e.__webglTexture=a[o].texture}return i}function L(e,s,l){let c=t.TEXTURE_2D;(s.isDataArrayTexture||s.isCompressedArrayTexture)&&(c=t.TEXTURE_2D_ARRAY),s.isData3DTexture&&(c=t.TEXTURE_3D);const h=I(e,s),u=s.source;n.bindTexture(c,e.__webglTexture,t.TEXTURE0+l);const d=i.get(u);if(u.version!==d.__version||!0===h){n.activeTexture(t.TEXTURE0+l);const e=je.getPrimaries(je.workingColorSpace),i=s.colorSpace===ne?null:je.getPrimaries(s.colorSpace),p=s.colorSpace===ne||e===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,s.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,p);const m=function(t){return!o&&(t.wrapS!==G||t.wrapT!==G||t.minFilter!==W&&t.minFilter!==q)}(s)&&!1===g(s.image);let b=f(s.image,m,!1,r.maxTextureSize);b=B(s,b);const w=g(b)||o,M=a.convert(s.format,s.colorSpace);let S,T=a.convert(s.type),E=y(s.internalFormat,M,T,s.colorSpace,s.isVideoTexture);P(c,s,w);const A=s.mipmaps,R=o&&!0!==s.isVideoTexture&&E!==Mt,C=void 0===d.__version||!0===h,I=x(s,b,w);if(s.isDepthTexture)E=t.DEPTH_COMPONENT,o?E=s.type===nt?t.DEPTH_COMPONENT32F:s.type===et?t.DEPTH_COMPONENT24:s.type===st?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT16:s.type===nt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),s.format===lt&&E===t.DEPTH_COMPONENT&&s.type!==$&&s.type!==et&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),s.type=et,T=a.convert(s.type)),s.format===ct&&E===t.DEPTH_COMPONENT&&(E=t.DEPTH_STENCIL,s.type!==st&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),s.type=st,T=a.convert(s.type))),C&&(R?n.texStorage2D(t.TEXTURE_2D,1,E,b.width,b.height):n.texImage2D(t.TEXTURE_2D,0,E,b.width,b.height,0,M,T,null));else if(s.isDataTexture)if(A.length>0&&w){R&&C&&n.texStorage2D(t.TEXTURE_2D,I,E,A[0].width,A[0].height);for(let e=0,i=A.length;e<i;e++)S=A[e],R?n.texSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,M,T,S.data):n.texImage2D(t.TEXTURE_2D,e,E,S.width,S.height,0,M,T,S.data);s.generateMipmaps=!1}else R?(C&&n.texStorage2D(t.TEXTURE_2D,I,E,b.width,b.height),n.texSubImage2D(t.TEXTURE_2D,0,0,0,b.width,b.height,M,T,b.data)):n.texImage2D(t.TEXTURE_2D,0,E,b.width,b.height,0,M,T,b.data);else if(s.isCompressedTexture)if(s.isCompressedArrayTexture){R&&C&&n.texStorage3D(t.TEXTURE_2D_ARRAY,I,E,A[0].width,A[0].height,b.depth);for(let e=0,i=A.length;e<i;e++)S=A[e],s.format!==ot?null!==M?R?n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,S.width,S.height,b.depth,M,S.data,0,0):n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,e,E,S.width,S.height,b.depth,0,S.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):R?n.texSubImage3D(t.TEXTURE_2D_ARRAY,e,0,0,0,S.width,S.height,b.depth,M,T,S.data):n.texImage3D(t.TEXTURE_2D_ARRAY,e,E,S.width,S.height,b.depth,0,M,T,S.data)}else{R&&C&&n.texStorage2D(t.TEXTURE_2D,I,E,A[0].width,A[0].height);for(let e=0,i=A.length;e<i;e++)S=A[e],s.format!==ot?null!==M?R?n.compressedTexSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,M,S.data):n.compressedTexImage2D(t.TEXTURE_2D,e,E,S.width,S.height,0,S.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):R?n.texSubImage2D(t.TEXTURE_2D,e,0,0,S.width,S.height,M,T,S.data):n.texImage2D(t.TEXTURE_2D,e,E,S.width,S.height,0,M,T,S.data)}else if(s.isDataArrayTexture)R?(C&&n.texStorage3D(t.TEXTURE_2D_ARRAY,I,E,b.width,b.height,b.depth),n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,b.width,b.height,b.depth,M,T,b.data)):n.texImage3D(t.TEXTURE_2D_ARRAY,0,E,b.width,b.height,b.depth,0,M,T,b.data);else if(s.isData3DTexture)R?(C&&n.texStorage3D(t.TEXTURE_3D,I,E,b.width,b.height,b.depth),n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,b.width,b.height,b.depth,M,T,b.data)):n.texImage3D(t.TEXTURE_3D,0,E,b.width,b.height,b.depth,0,M,T,b.data);else if(s.isFramebufferTexture){if(C)if(R)n.texStorage2D(t.TEXTURE_2D,I,E,b.width,b.height);else{let e=b.width,i=b.height;for(let r=0;r<I;r++)n.texImage2D(t.TEXTURE_2D,r,E,e,i,0,M,T,null),e>>=1,i>>=1}}else if(A.length>0&&w){R&&C&&n.texStorage2D(t.TEXTURE_2D,I,E,A[0].width,A[0].height);for(let e=0,i=A.length;e<i;e++)S=A[e],R?n.texSubImage2D(t.TEXTURE_2D,e,0,0,M,T,S):n.texImage2D(t.TEXTURE_2D,e,E,M,T,S);s.generateMipmaps=!1}else R?(C&&n.texStorage2D(t.TEXTURE_2D,I,E,b.width,b.height),n.texSubImage2D(t.TEXTURE_2D,0,0,0,M,T,b)):n.texImage2D(t.TEXTURE_2D,0,E,M,T,b);v(s,w)&&_(c),d.__version=u.version,s.onUpdate&&s.onUpdate(s)}e.__version=s.version}function D(e,r,s,o,c,h){const u=a.convert(s.format,s.colorSpace),d=a.convert(s.type),p=y(s.internalFormat,u,d,s.colorSpace);if(!i.get(r).__hasExternalTextures){const e=Math.max(1,r.width>>h),i=Math.max(1,r.height>>h);c===t.TEXTURE_3D||c===t.TEXTURE_2D_ARRAY?n.texImage3D(c,h,p,e,i,r.depth,0,u,d,null):n.texImage2D(c,h,p,e,i,0,u,d,null)}n.bindFramebuffer(t.FRAMEBUFFER,e),F(r)?l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,o,c,i.get(s).__webglTexture,0,U(r)):(c===t.TEXTURE_2D||c>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,o,c,i.get(s).__webglTexture,h),n.bindFramebuffer(t.FRAMEBUFFER,null)}function N(e,n,i){if(t.bindRenderbuffer(t.RENDERBUFFER,e),n.depthBuffer&&!n.stencilBuffer){let r=!0===o?t.DEPTH_COMPONENT24:t.DEPTH_COMPONENT16;if(i||F(n)){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===nt?r=t.DEPTH_COMPONENT32F:e.type===et&&(r=t.DEPTH_COMPONENT24));const i=U(n);F(n)?l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,i,r,n.width,n.height):t.renderbufferStorageMultisample(t.RENDERBUFFER,i,r,n.width,n.height)}else t.renderbufferStorage(t.RENDERBUFFER,r,n.width,n.height);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,e)}else if(n.depthBuffer&&n.stencilBuffer){const r=U(n);i&&!1===F(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,r,t.DEPTH24_STENCIL8,n.width,n.height):F(n)?l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,r,t.DEPTH24_STENCIL8,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,n.width,n.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture];for(let r=0;r<e.length;r++){const s=e[r],o=a.convert(s.format,s.colorSpace),c=a.convert(s.type),h=y(s.internalFormat,o,c,s.colorSpace),u=U(n);i&&!1===F(n)?t.renderbufferStorageMultisample(t.RENDERBUFFER,u,h,n.width,n.height):F(n)?l.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,u,h,n.width,n.height):t.renderbufferStorage(t.RENDERBUFFER,h,n.width,n.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function O(e){const r=i.get(e),a=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!r.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");i.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),E(r.depthTexture,0);const a=i.get(r.depthTexture).__webglTexture,s=U(r);if(r.depthTexture.format===lt)F(r)?l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,a,0,s):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,a,0);else{if(r.depthTexture.format!==ct)throw new Error("Unknown depthTexture format");F(r)?l.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,a,0,s):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,a,0)}}(r.__webglFramebuffer,e)}else if(a){r.__webglDepthbuffer=[];for(let i=0;i<6;i++)n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=t.createRenderbuffer(),N(r.__webglDepthbuffer[i],e,!1)}else n.bindFramebuffer(t.FRAMEBUFFER,r.__webglFramebuffer),r.__webglDepthbuffer=t.createRenderbuffer(),N(r.__webglDepthbuffer,e,!1);n.bindFramebuffer(t.FRAMEBUFFER,null)}function U(t){return Math.min(r.maxSamples,t.samples)}function F(t){const n=i.get(t);return o&&t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function B(t,n){const i=t.colorSpace,r=t.format,a=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||t.format===me||i!==re&&i!==ne&&(je.getTransfer(i)===le?!1===o?!0===e.has("EXT_sRGB")&&r===ot?(t.format=me,t.minFilter=q,t.generateMipmaps=!1):n=Ze.sRGBToLinear(n):r===ot&&a===J||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",i)),n}this.allocateTextureUnit=function(){const t=T;return t>=r.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+r.maxTextures),T+=1,t},this.resetTextureUnits=function(){T=0},this.setTexture2D=E,this.setTexture2DArray=function(e,r){const a=i.get(e);e.version>0&&a.__version!==e.version?L(a,e,r):n.bindTexture(t.TEXTURE_2D_ARRAY,a.__webglTexture,t.TEXTURE0+r)},this.setTexture3D=function(e,r){const a=i.get(e);e.version>0&&a.__version!==e.version?L(a,e,r):n.bindTexture(t.TEXTURE_3D,a.__webglTexture,t.TEXTURE0+r)},this.setTextureCube=function(e,s){const l=i.get(e);e.version>0&&l.__version!==e.version?function(e,s,l){if(6!==s.image.length)return;const c=I(e,s),h=s.source;n.bindTexture(t.TEXTURE_CUBE_MAP,e.__webglTexture,t.TEXTURE0+l);const u=i.get(h);if(h.version!==u.__version||!0===c){n.activeTexture(t.TEXTURE0+l);const e=je.getPrimaries(je.workingColorSpace),i=s.colorSpace===ne?null:je.getPrimaries(s.colorSpace),d=s.colorSpace===ne||e===i?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,s.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,d);const p=s.isCompressedTexture||s.image[0].isCompressedTexture,m=s.image[0]&&s.image[0].isDataTexture,b=[];for(let t=0;t<6;t++)b[t]=p||m?m?s.image[t].image:s.image[t]:f(s.image[t],!1,!0,r.maxCubemapSize),b[t]=B(s,b[t]);const w=b[0],M=g(w)||o,S=a.convert(s.format,s.colorSpace),T=a.convert(s.type),E=y(s.internalFormat,S,T,s.colorSpace),A=o&&!0!==s.isVideoTexture,R=void 0===u.__version||!0===c;let C,I=x(s,w,M);if(P(t.TEXTURE_CUBE_MAP,s,M),p){A&&R&&n.texStorage2D(t.TEXTURE_CUBE_MAP,I,E,w.width,w.height);for(let e=0;e<6;e++){C=b[e].mipmaps;for(let i=0;i<C.length;i++){const r=C[i];s.format!==ot?null!==S?A?n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,r.width,r.height,S,r.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,E,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):A?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0,0,r.width,r.height,S,T,r.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,E,r.width,r.height,0,S,T,r.data)}}}else{C=s.mipmaps,A&&R&&(C.length>0&&I++,n.texStorage2D(t.TEXTURE_CUBE_MAP,I,E,b[0].width,b[0].height));for(let e=0;e<6;e++)if(m){A?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,b[e].width,b[e].height,S,T,b[e].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,E,b[e].width,b[e].height,0,S,T,b[e].data);for(let i=0;i<C.length;i++){const r=C[i].image[e].image;A?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,r.width,r.height,S,T,r.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,E,r.width,r.height,0,S,T,r.data)}}else{A?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,0,0,S,T,b[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,E,S,T,b[e]);for(let i=0;i<C.length;i++){const r=C[i];A?n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,0,0,S,T,r.image[e]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+e,i+1,E,S,T,r.image[e])}}}v(s,M)&&_(t.TEXTURE_CUBE_MAP),u.__version=h.version,s.onUpdate&&s.onUpdate(s)}e.__version=s.version}(l,e,s):n.bindTexture(t.TEXTURE_CUBE_MAP,l.__webglTexture,t.TEXTURE0+s)},this.rebindTextures=function(e,n,r){const a=i.get(e);void 0!==n&&D(a.__webglFramebuffer,e,e.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),void 0!==r&&O(e)},this.setupRenderTarget=function(e){const l=e.texture,c=i.get(e),h=i.get(l);e.addEventListener("dispose",M),!0!==e.isWebGLMultipleRenderTargets&&(void 0===h.__webglTexture&&(h.__webglTexture=t.createTexture()),h.__version=l.version,s.memory.textures++);const u=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=g(e)||o;if(u){c.__webglFramebuffer=[];for(let e=0;e<6;e++)if(o&&l.mipmaps&&l.mipmaps.length>0){c.__webglFramebuffer[e]=[];for(let n=0;n<l.mipmaps.length;n++)c.__webglFramebuffer[e][n]=t.createFramebuffer()}else c.__webglFramebuffer[e]=t.createFramebuffer()}else{if(o&&l.mipmaps&&l.mipmaps.length>0){c.__webglFramebuffer=[];for(let e=0;e<l.mipmaps.length;e++)c.__webglFramebuffer[e]=t.createFramebuffer()}else c.__webglFramebuffer=t.createFramebuffer();if(d)if(r.drawBuffers){const n=e.texture;for(let e=0,r=n.length;e<r;e++){const r=i.get(n[e]);void 0===r.__webglTexture&&(r.__webglTexture=t.createTexture(),s.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&e.samples>0&&!1===F(e)){const i=d?l:[l];c.__webglMultisampledFramebuffer=t.createFramebuffer(),c.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,c.__webglMultisampledFramebuffer);for(let n=0;n<i.length;n++){const r=i[n];c.__webglColorRenderbuffer[n]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,c.__webglColorRenderbuffer[n]);const s=a.convert(r.format,r.colorSpace),o=a.convert(r.type),l=y(r.internalFormat,s,o,r.colorSpace,!0===e.isXRRenderTarget),h=U(e);t.renderbufferStorageMultisample(t.RENDERBUFFER,h,l,e.width,e.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+n,t.RENDERBUFFER,c.__webglColorRenderbuffer[n])}t.bindRenderbuffer(t.RENDERBUFFER,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=t.createRenderbuffer(),N(c.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if(u){n.bindTexture(t.TEXTURE_CUBE_MAP,h.__webglTexture),P(t.TEXTURE_CUBE_MAP,l,p);for(let n=0;n<6;n++)if(o&&l.mipmaps&&l.mipmaps.length>0)for(let i=0;i<l.mipmaps.length;i++)D(c.__webglFramebuffer[n][i],e,l,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,i);else D(c.__webglFramebuffer[n],e,l,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+n,0);v(l,p)&&_(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(d){const r=e.texture;for(let a=0,s=r.length;a<s;a++){const s=r[a],o=i.get(s);n.bindTexture(t.TEXTURE_2D,o.__webglTexture),P(t.TEXTURE_2D,s,p),D(c.__webglFramebuffer,e,s,t.COLOR_ATTACHMENT0+a,t.TEXTURE_2D,0),v(s,p)&&_(t.TEXTURE_2D)}n.unbindTexture()}else{let i=t.TEXTURE_2D;if((e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(o?i=e.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(i,h.__webglTexture),P(i,l,p),o&&l.mipmaps&&l.mipmaps.length>0)for(let n=0;n<l.mipmaps.length;n++)D(c.__webglFramebuffer[n],e,l,t.COLOR_ATTACHMENT0,i,n);else D(c.__webglFramebuffer,e,l,t.COLOR_ATTACHMENT0,i,0);v(l,p)&&_(i),n.unbindTexture()}e.depthBuffer&&O(e)},this.updateRenderTargetMipmap=function(e){const r=g(e)||o,a=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,o=a.length;s<o;s++){const o=a[s];if(v(o,r)){const r=e.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:t.TEXTURE_2D,a=i.get(o).__webglTexture;n.bindTexture(r,a),_(r),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(o&&e.samples>0&&!1===F(e)){const r=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],a=e.width,s=e.height;let o=t.COLOR_BUFFER_BIT;const l=[],h=e.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,u=i.get(e),d=!0===e.isWebGLMultipleRenderTargets;if(d)for(let e=0;e<r.length;e++)n.bindFramebuffer(t.FRAMEBUFFER,u.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,u.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,u.__webglMultisampledFramebuffer),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,u.__webglFramebuffer);for(let n=0;n<r.length;n++){l.push(t.COLOR_ATTACHMENT0+n),e.depthBuffer&&l.push(h);const p=void 0!==u.__ignoreDepthValues&&u.__ignoreDepthValues;if(!1===p&&(e.depthBuffer&&(o|=t.DEPTH_BUFFER_BIT),e.stencilBuffer&&(o|=t.STENCIL_BUFFER_BIT)),d&&t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,u.__webglColorRenderbuffer[n]),!0===p&&(t.invalidateFramebuffer(t.READ_FRAMEBUFFER,[h]),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[h])),d){const e=i.get(r[n]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)}t.blitFramebuffer(0,0,a,s,0,0,a,s,o,t.NEAREST),c&&t.invalidateFramebuffer(t.READ_FRAMEBUFFER,l)}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),d)for(let e=0;e<r.length;e++){n.bindFramebuffer(t.FRAMEBUFFER,u.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.RENDERBUFFER,u.__webglColorRenderbuffer[e]);const a=i.get(r[e]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,u.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+e,t.TEXTURE_2D,a,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,u.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=O,this.setupFrameBufferTexture=D,this.useMultisampledRTT=F}function ho(t,e,n){const i=n.isWebGL2;return{convert:function(n,r=""){let a;const s=je.getTransfer(r);if(n===J)return t.UNSIGNED_BYTE;if(n===rt)return t.UNSIGNED_SHORT_4_4_4_4;if(n===at)return t.UNSIGNED_SHORT_5_5_5_1;if(n===K)return t.BYTE;if(n===Q)return t.SHORT;if(n===$)return t.UNSIGNED_SHORT;if(n===tt)return t.INT;if(n===et)return t.UNSIGNED_INT;if(n===nt)return t.FLOAT;if(n===it)return i?t.HALF_FLOAT:(a=e.get("OES_texture_half_float"),null!==a?a.HALF_FLOAT_OES:null);if(1021===n)return t.ALPHA;if(n===ot)return t.RGBA;if(1024===n)return t.LUMINANCE;if(1025===n)return t.LUMINANCE_ALPHA;if(n===lt)return t.DEPTH_COMPONENT;if(n===ct)return t.DEPTH_STENCIL;if(n===me)return a=e.get("EXT_sRGB"),null!==a?a.SRGB_ALPHA_EXT:null;if(n===ht)return t.RED;if(n===ut)return t.RED_INTEGER;if(n===dt)return t.RG;if(n===pt)return t.RG_INTEGER;if(n===mt)return t.RGBA_INTEGER;if(n===ft||n===gt||n===vt||n===_t)if(s===le){if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===a)return null;if(n===ft)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===gt)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===vt)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===_t)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(a=e.get("WEBGL_compressed_texture_s3tc"),null===a)return null;if(n===ft)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===gt)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===vt)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===_t)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===yt||n===xt||n===bt||n===wt){if(a=e.get("WEBGL_compressed_texture_pvrtc"),null===a)return null;if(n===yt)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===xt)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===bt)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===wt)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===Mt)return a=e.get("WEBGL_compressed_texture_etc1"),null!==a?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===St||n===Tt){if(a=e.get("WEBGL_compressed_texture_etc"),null===a)return null;if(n===St)return s===le?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(n===Tt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}if(n===Et||n===At||n===Rt||n===Ct||n===Pt||n===It||n===Lt||n===Dt||n===Nt||n===Ot||n===Ut||n===Ft||n===Bt||n===zt){if(a=e.get("WEBGL_compressed_texture_astc"),null===a)return null;if(n===Et)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===At)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Rt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===Ct)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Pt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===It)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===Lt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===Dt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===Nt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===Ot)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Ut)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Ft)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===Bt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===zt)return s===le?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===kt||n===Ht||n===Gt){if(a=e.get("EXT_texture_compression_bptc"),null===a)return null;if(n===kt)return s===le?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===Ht)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===Gt)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(36283===n||n===Vt||n===Wt||n===jt){if(a=e.get("EXT_texture_compression_rgtc"),null===a)return null;if(n===kt)return a.COMPRESSED_RED_RGTC1_EXT;if(n===Vt)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Wt)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===jt)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===st?i?t.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),null!==a?a.UNSIGNED_INT_24_8_WEBGL:null):void 0!==t[n]?t[n]:null}}}class uo extends Mr{constructor(t=[]){super(),this.isArrayCamera=!0,this.cameras=t}}class po extends hi{constructor(){super(),this.isGroup=!0,this.type="Group"}}const mo={type:"move"};class fo{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new po,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new po,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new cn,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new cn),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new po,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new cn,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new cn),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}connect(t){if(t&&t.hand){const e=this._hand;if(e)for(const n of t.hand.values())this._getHandJoint(e,n)}return this.dispatchEvent({type:"connected",data:t}),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let i=null,r=null,a=null;const s=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState){if(l&&t.hand){a=!0;for(const i of t.hand.values()){const t=e.getJointPose(i,n),r=this._getHandJoint(l,i);null!==t&&(r.matrix.fromArray(t.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,r.jointRadius=t.radius),r.visible=null!==t}const i=l.joints["index-finger-tip"],r=l.joints["thumb-tip"],s=i.position.distanceTo(r.position),o=.02,c=.005;l.inputState.pinching&&s>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&s<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(r=e.getPose(t.gripSpace,n),null!==r&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,r.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(r.linearVelocity)):o.hasLinearVelocity=!1,r.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(r.angularVelocity)):o.hasAngularVelocity=!1));null!==s&&(i=e.getPose(t.targetRaySpace,n),null===i&&null!==r&&(i=r),null!==i&&(s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,i.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(i.linearVelocity)):s.hasLinearVelocity=!1,i.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(i.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(mo)))}return null!==s&&(s.visible=null!==i),null!==o&&(o.visible=null!==r),null!==l&&(l.visible=null!==a),this}_getHandJoint(t,e){if(void 0===t.joints[e.jointName]){const n=new po;n.matrixAutoUpdate=!1,n.visible=!1,t.joints[e.jointName]=n,t.add(n)}return t.joints[e.jointName]}}class go extends ve{constructor(t,e){super();const n=this;let i=null,r=1,a=null,s="local-floor",o=1,l=null,c=null,h=null,u=null,d=null,p=null;const m=e.getContextAttributes();let f=null,g=null;const v=[],_=[],y=new Ie;let x=null;const b=new Mr;b.layers.enable(1),b.viewport=new en;const w=new Mr;w.layers.enable(2),w.viewport=new en;const M=[b,w],S=new uo;S.layers.enable(1),S.layers.enable(2);let T=null,E=null;function A(t){const e=_.indexOf(t.inputSource);if(-1===e)return;const n=v[e];void 0!==n&&(n.update(t.inputSource,t.frame,l||a),n.dispatchEvent({type:t.type,data:t.inputSource}))}function R(){i.removeEventListener("select",A),i.removeEventListener("selectstart",A),i.removeEventListener("selectend",A),i.removeEventListener("squeeze",A),i.removeEventListener("squeezestart",A),i.removeEventListener("squeezeend",A),i.removeEventListener("end",R),i.removeEventListener("inputsourceschange",C);for(let t=0;t<v.length;t++){const e=_[t];null!==e&&(_[t]=null,v[t].disconnect(e))}T=null,E=null,t.setRenderTarget(f),d=null,u=null,h=null,i=null,g=null,N.stop(),n.isPresenting=!1,t.setPixelRatio(x),t.setSize(y.width,y.height,!1),n.dispatchEvent({type:"sessionend"})}function C(t){for(let e=0;e<t.removed.length;e++){const n=t.removed[e],i=_.indexOf(n);i>=0&&(_[i]=null,v[i].disconnect(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e];let i=_.indexOf(n);if(-1===i){for(let t=0;t<v.length;t++){if(t>=_.length){_.push(n),i=t;break}if(null===_[t]){_[t]=n,i=t;break}}if(-1===i)break}const r=v[i];r&&r.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=v[t];return void 0===e&&(e=new fo,v[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=v[t];return void 0===e&&(e=new fo,v[t]=e),e.getGripSpace()},this.getHand=function(t){let e=v[t];return void 0===e&&(e=new fo,v[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(t){l=t},this.getBaseLayer=function(){return null!==u?u:d},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(c){if(i=c,null!==i){if(f=t.getRenderTarget(),i.addEventListener("select",A),i.addEventListener("selectstart",A),i.addEventListener("selectend",A),i.addEventListener("squeeze",A),i.addEventListener("squeezestart",A),i.addEventListener("squeezeend",A),i.addEventListener("end",R),i.addEventListener("inputsourceschange",C),!0!==m.xrCompatible&&await e.makeXRCompatible(),x=t.getPixelRatio(),t.getSize(y),void 0===i.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==i.renderState.layers||m.antialias,alpha:!0,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(i,e,n),i.updateRenderState({baseLayer:d}),t.setPixelRatio(1),t.setSize(d.framebufferWidth,d.framebufferHeight,!1),g=new rn(d.framebufferWidth,d.framebufferHeight,{format:ot,type:J,colorSpace:t.outputColorSpace,stencilBuffer:m.stencil})}else{let n=null,a=null,s=null;m.depth&&(s=m.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,n=m.stencil?ct:lt,a=m.stencil?st:et);const o={colorFormat:e.RGBA8,depthFormat:s,scaleFactor:r};h=new XRWebGLBinding(i,e),u=h.createProjectionLayer(o),i.updateRenderState({layers:[u]}),t.setPixelRatio(1),t.setSize(u.textureWidth,u.textureHeight,!1),g=new rn(u.textureWidth,u.textureHeight,{format:ot,type:J,depthTexture:new xa(u.textureWidth,u.textureHeight,a,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:m.stencil,colorSpace:t.outputColorSpace,samples:m.antialias?4:0});t.properties.get(g).__ignoreDepthValues=u.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(o),l=null,a=await i.requestReferenceSpace(s),N.setContext(i),N.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==i)return i.environmentBlendMode};const P=new cn,I=new cn;function L(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===i)return;S.near=w.near=b.near=t.near,S.far=w.far=b.far=t.far,T===S.near&&E===S.far||(i.updateRenderState({depthNear:S.near,depthFar:S.far}),T=S.near,E=S.far);const e=t.parent,n=S.cameras;L(S,e);for(let t=0;t<n.length;t++)L(n[t],e);2===n.length?function(t,e,n){P.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(n.matrixWorld);const i=P.distanceTo(I),r=e.projectionMatrix.elements,a=n.projectionMatrix.elements,s=r[14]/(r[10]-1),o=r[14]/(r[10]+1),l=(r[9]+1)/r[5],c=(r[9]-1)/r[5],h=(r[8]-1)/r[0],u=(a[8]+1)/a[0],d=s*h,p=s*u,m=i/(-h+u),f=m*-h;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(f),t.translateZ(m),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=s+m,v=o+m,_=d-f,y=p+(i-f),x=l*o/v*g,b=c*o/v*g;t.projectionMatrix.makePerspective(_,y,x,b,g,v),t.projectionMatrixInverse.copy(t.projectionMatrix).invert()}(S,b,w):S.projectionMatrix.copy(b.projectionMatrix),function(t,e,n){null===n?t.matrix.copy(e.matrixWorld):(t.matrix.copy(n.matrixWorld),t.matrix.invert(),t.matrix.multiply(e.matrixWorld));t.matrix.decompose(t.position,t.quaternion,t.scale),t.updateMatrixWorld(!0),t.projectionMatrix.copy(e.projectionMatrix),t.projectionMatrixInverse.copy(e.projectionMatrixInverse),t.isPerspectiveCamera&&(t.fov=2*be*Math.atan(1/t.projectionMatrix.elements[5]),t.zoom=1)}(t,S,e)},this.getCamera=function(){return S},this.getFoveation=function(){if(null!==u||null!==d)return o},this.setFoveation=function(t){o=t,null!==u&&(u.fixedFoveation=t),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=t)};let D=null;const N=new Or;N.setAnimationLoop((function(e,i){if(c=i.getViewerPose(l||a),p=i,null!==c){const e=c.views;null!==d&&(t.setRenderTargetFramebuffer(g,d.framebuffer),t.setRenderTarget(g));let n=!1;e.length!==S.cameras.length&&(S.cameras.length=0,n=!0);for(let i=0;i<e.length;i++){const r=e[i];let a=null;if(null!==d)a=d.getViewport(r);else{const e=h.getViewSubImage(u,r);a=e.viewport,0===i&&(t.setRenderTargetTextures(g,e.colorTexture,u.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(g))}let s=M[i];void 0===s&&(s=new Mr,s.layers.enable(i),s.viewport=new en,M[i]=s),s.matrix.fromArray(r.transform.matrix),s.matrix.decompose(s.position,s.quaternion,s.scale),s.projectionMatrix.fromArray(r.projectionMatrix),s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),s.viewport.set(a.x,a.y,a.width,a.height),0===i&&(S.matrix.copy(s.matrix),S.matrix.decompose(S.position,S.quaternion,S.scale)),!0===n&&S.cameras.push(s)}}for(let t=0;t<v.length;t++){const e=_[t],n=v[t];null!==e&&void 0!==n&&n.update(e,i,l||a)}D&&D(e,i),i.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:i}),p=null})),this.setAnimationLoop=function(t){D=t},this.dispose=function(){}}}function vo(t,e){function n(t,e){!0===t.matrixAutoUpdate&&t.updateMatrix(),e.value.copy(t.matrix)}function i(i,r){i.opacity.value=r.opacity,r.color&&i.diffuse.value.copy(r.color),r.emissive&&i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(i.map.value=r.map,n(r.map,i.mapTransform)),r.alphaMap&&(i.alphaMap.value=r.alphaMap,n(r.alphaMap,i.alphaMapTransform)),r.bumpMap&&(i.bumpMap.value=r.bumpMap,n(r.bumpMap,i.bumpMapTransform),i.bumpScale.value=r.bumpScale,r.side===_&&(i.bumpScale.value*=-1)),r.normalMap&&(i.normalMap.value=r.normalMap,n(r.normalMap,i.normalMapTransform),i.normalScale.value.copy(r.normalScale),r.side===_&&i.normalScale.value.negate()),r.displacementMap&&(i.displacementMap.value=r.displacementMap,n(r.displacementMap,i.displacementMapTransform),i.displacementScale.value=r.displacementScale,i.displacementBias.value=r.displacementBias),r.emissiveMap&&(i.emissiveMap.value=r.emissiveMap,n(r.emissiveMap,i.emissiveMapTransform)),r.specularMap&&(i.specularMap.value=r.specularMap,n(r.specularMap,i.specularMapTransform)),r.alphaTest>0&&(i.alphaTest.value=r.alphaTest);const a=e.get(r).envMap;if(a&&(i.envMap.value=a,i.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,i.reflectivity.value=r.reflectivity,i.ior.value=r.ior,i.refractionRatio.value=r.refractionRatio),r.lightMap){i.lightMap.value=r.lightMap;const e=!0===t._useLegacyLights?Math.PI:1;i.lightMapIntensity.value=r.lightMapIntensity*e,n(r.lightMap,i.lightMapTransform)}r.aoMap&&(i.aoMap.value=r.aoMap,i.aoMapIntensity.value=r.aoMapIntensity,n(r.aoMap,i.aoMapTransform))}return{refreshFogUniforms:function(e,n){n.color.getRGB(e.fogColor.value,yr(t)),n.isFog?(e.fogNear.value=n.near,e.fogFar.value=n.far):n.isFogExp2&&(e.fogDensity.value=n.density)},refreshMaterialUniforms:function(t,r,a,s,o){r.isMeshBasicMaterial||r.isMeshLambertMaterial?i(t,r):r.isMeshToonMaterial?(i(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,r)):r.isMeshPhongMaterial?(i(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,r)):r.isMeshStandardMaterial?(i(t,r),function(t,i){t.metalness.value=i.metalness,i.metalnessMap&&(t.metalnessMap.value=i.metalnessMap,n(i.metalnessMap,t.metalnessMapTransform));t.roughness.value=i.roughness,i.roughnessMap&&(t.roughnessMap.value=i.roughnessMap,n(i.roughnessMap,t.roughnessMapTransform));const r=e.get(i).envMap;r&&(t.envMapIntensity.value=i.envMapIntensity)}(t,r),r.isMeshPhysicalMaterial&&function(t,e,i){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap,n(e.sheenColorMap,t.sheenColorMapTransform)),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap,n(e.sheenRoughnessMap,t.sheenRoughnessMapTransform)));e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap,n(e.clearcoatMap,t.clearcoatMapTransform)),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap,n(e.clearcoatRoughnessMap,t.clearcoatRoughnessMapTransform)),e.clearcoatNormalMap&&(t.clearcoatNormalMap.value=e.clearcoatNormalMap,n(e.clearcoatNormalMap,t.clearcoatNormalMapTransform),t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),e.side===_&&t.clearcoatNormalScale.value.negate()));e.iridescence>0&&(t.iridescence.value=e.iridescence,t.iridescenceIOR.value=e.iridescenceIOR,t.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],t.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(t.iridescenceMap.value=e.iridescenceMap,n(e.iridescenceMap,t.iridescenceMapTransform)),e.iridescenceThicknessMap&&(t.iridescenceThicknessMap.value=e.iridescenceThicknessMap,n(e.iridescenceThicknessMap,t.iridescenceThicknessMapTransform)));e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=i.texture,t.transmissionSamplerSize.value.set(i.width,i.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap,n(e.transmissionMap,t.transmissionMapTransform)),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap,n(e.thicknessMap,t.thicknessMapTransform)),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor));e.anisotropy>0&&(t.anisotropyVector.value.set(e.anisotropy*Math.cos(e.anisotropyRotation),e.anisotropy*Math.sin(e.anisotropyRotation)),e.anisotropyMap&&(t.anisotropyMap.value=e.anisotropyMap,n(e.anisotropyMap,t.anisotropyMapTransform)));t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap,n(e.specularColorMap,t.specularColorMapTransform));e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap,n(e.specularIntensityMap,t.specularIntensityMapTransform))}(t,r,o)):r.isMeshMatcapMaterial?(i(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,r)):r.isMeshDepthMaterial?i(t,r):r.isMeshDistanceMaterial?(i(t,r),function(t,n){const i=e.get(n).light;t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),t.nearDistance.value=i.shadow.camera.near,t.farDistance.value=i.shadow.camera.far}(t,r)):r.isMeshNormalMaterial?i(t,r):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform))}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,i,r){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*i,t.scale.value=.5*r,e.map&&(t.map.value=e.map,n(e.map,t.uvTransform));e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform));e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r,a,s):r.isSpriteMaterial?function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map,n(e.map,t.mapTransform));e.alphaMap&&(t.alphaMap.value=e.alphaMap,n(e.alphaMap,t.alphaMapTransform));e.alphaTest>0&&(t.alphaTest.value=e.alphaTest)}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function _o(t,e,n,i){let r={},a={},s=[];const o=n.isWebGL2?t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(t,e,n,i){const r=t.value,a=e+"_"+n;if(void 0===i[a])return i[a]="number"==typeof r||"boolean"==typeof r?r:r.clone(),!0;{const t=i[a];if("number"==typeof r||"boolean"==typeof r){if(t!==r)return i[a]=r,!0}else if(!1===t.equals(r))return t.copy(r),!0}return!1}function c(t){const e={boundary:0,storage:0};return"number"==typeof t||"boolean"==typeof t?(e.boundary=4,e.storage=4):t.isVector2?(e.boundary=8,e.storage=8):t.isVector3||t.isColor?(e.boundary=16,e.storage=12):t.isVector4?(e.boundary=16,e.storage=16):t.isMatrix3?(e.boundary=48,e.storage=48):t.isMatrix4?(e.boundary=64,e.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),e}function h(e){const n=e.target;n.removeEventListener("dispose",h);const i=s.indexOf(n.__bindingPointIndex);s.splice(i,1),t.deleteBuffer(r[n.id]),delete r[n.id],delete a[n.id]}return{bind:function(t,e){const n=e.program;i.uniformBlockBinding(t,n)},update:function(n,u){let d=r[n.id];void 0===d&&(!function(t){const e=t.uniforms;let n=0;const i=16;for(let t=0,r=e.length;t<r;t++){const r=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0,e=r.length;t<e;t++){const e=r[t],a=Array.isArray(e.value)?e.value:[e.value];for(let t=0,r=a.length;t<r;t++){const r=c(a[t]),s=n%i;0!==s&&i-s<r.boundary&&(n+=i-s),e.__data=new Float32Array(r.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=n,n+=r.storage}}}const r=n%i;r>0&&(n+=i-r);t.__size=n,t.__cache={}}(n),d=function(e){const n=function(){for(let t=0;t<o;t++)if(-1===s.indexOf(t))return s.push(t),t;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=n;const i=t.createBuffer(),r=e.__size,a=e.usage;return t.bindBuffer(t.UNIFORM_BUFFER,i),t.bufferData(t.UNIFORM_BUFFER,r,a),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,n,i),i}(n),r[n.id]=d,n.addEventListener("dispose",h));const p=u.program;i.updateUBOMapping(n,p);const m=e.render.frame;a[n.id]!==m&&(!function(e){const n=r[e.id],i=e.uniforms,a=e.__cache;t.bindBuffer(t.UNIFORM_BUFFER,n);for(let e=0,n=i.length;e<n;e++){const n=Array.isArray(i[e])?i[e]:[i[e]];for(let i=0,r=n.length;i<r;i++){const r=n[i];if(!0===l(r,e,i,a)){const e=r.__offset,n=Array.isArray(r.value)?r.value:[r.value];let i=0;for(let a=0;a<n.length;a++){const s=n[a],o=c(s);"number"==typeof s||"boolean"==typeof s?(r.__data[0]=s,t.bufferSubData(t.UNIFORM_BUFFER,e+i,r.__data)):s.isMatrix3?(r.__data[0]=s.elements[0],r.__data[1]=s.elements[1],r.__data[2]=s.elements[2],r.__data[3]=0,r.__data[4]=s.elements[3],r.__data[5]=s.elements[4],r.__data[6]=s.elements[5],r.__data[7]=0,r.__data[8]=s.elements[6],r.__data[9]=s.elements[7],r.__data[10]=s.elements[8],r.__data[11]=0):(s.toArray(r.__data,i),i+=o.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,e,r.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}(n),a[n.id]=m)},dispose:function(){for(const e in r)t.deleteBuffer(r[e]);s=[],r={},a={}}}}class yo{constructor(t={}){const{canvas:e=Be(),context:n=null,depth:i=!0,stencil:r=!0,alpha:a=!1,antialias:s=!1,premultipliedAlpha:o=!0,preserveDrawingBuffer:l=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:h=!1}=t;let d;this.isWebGLRenderer=!0,d=null!==n?n.getContextAttributes().alpha:a;const p=new Uint32Array(4),m=new Int32Array(4);let f=null,g=null;const x=[],b=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=ie,this._useLegacyLights=!1,this.toneMapping=E,this.toneMappingExposure=1;const w=this;let M=!1,S=0,T=0,A=null,R=-1,C=null;const P=new en,I=new en;let L=null;const D=new Ai(0);let N=0,O=e.width,U=e.height,F=1,B=null,z=null;const k=new en(0,0,O,U),H=new en(0,0,O,U);let G=!1;const V=new Nr;let W=!1,j=!1,X=null;const q=new zn,Y=new Ie,K=new cn,Q={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function tt(){return null===A?F:1}let lt,ct,ht,dt,ft,gt,vt,_t,yt,xt,bt,wt,Mt,St,Tt,Et,At,Rt,Ct,Pt,It,Lt,Dt,Nt,Ot=n;function Ut(t,n){for(let i=0;i<t.length;i++){const r=t[i],a=e.getContext(r,n);if(null!==a)return a}return null}try{const t={alpha:!0,depth:i,stencil:r,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${u}`),e.addEventListener("webglcontextlost",zt,!1),e.addEventListener("webglcontextrestored",kt,!1),e.addEventListener("webglcontextcreationerror",Ht,!1),null===Ot){const e=["webgl2","webgl","experimental-webgl"];if(!0===w.isWebGL1Renderer&&e.shift(),Ot=Ut(e,t),null===Ot)throw Ut(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}"undefined"!=typeof WebGLRenderingContext&&Ot instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),void 0===Ot.getShaderPrecisionFormat&&(Ot.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function Ft(){lt=new da(Ot),ct=new jr(Ot,lt,t),lt.init(ct),Lt=new ho(Ot,lt,ct),ht=new lo(Ot,lt,ct),dt=new fa(Ot),ft=new Ys,gt=new co(Ot,lt,ht,ft,ct,Lt,dt),vt=new qr(w),_t=new ua(w),yt=new Ur(Ot,ct),Dt=new Vr(Ot,lt,yt,ct),xt=new pa(Ot,yt,dt,Dt),bt=new ya(Ot,xt,yt,dt),Ct=new _a(Ot,ct,gt),Et=new Xr(ft),wt=new qs(w,vt,_t,lt,ct,Dt,Et),Mt=new vo(w,ft),St=new Qs,Tt=new ro(lt,ct),Rt=new Gr(w,vt,_t,ht,bt,d,o),At=new oo(w,bt,ct),Nt=new _o(Ot,dt,ct,ht),Pt=new Wr(Ot,lt,dt,ct),It=new ma(Ot,lt,dt,ct),dt.programs=wt.programs,w.capabilities=ct,w.extensions=lt,w.properties=ft,w.renderLists=St,w.shadowMap=At,w.state=ht,w.info=dt}Ft();const Bt=new go(w,Ot);function zt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),M=!0}function kt(){console.log("THREE.WebGLRenderer: Context Restored."),M=!1;const t=dt.autoReset,e=At.enabled,n=At.autoUpdate,i=At.needsUpdate,r=At.type;Ft(),dt.autoReset=t,At.enabled=e,At.autoUpdate=n,At.needsUpdate=i,At.type=r}function Ht(t){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",t.statusMessage)}function Gt(t){const e=t.target;e.removeEventListener("dispose",Gt),function(t){(function(t){const e=ft.get(t).programs;void 0!==e&&(e.forEach((function(t){wt.releaseProgram(t)})),t.isShaderMaterial&&wt.releaseShaderCache(t))})(t),ft.remove(t)}(e)}function Vt(t,e,n){!0===t.transparent&&t.side===y&&!1===t.forceSinglePass?(t.side=_,t.needsUpdate=!0,Qt(t,e,n),t.side=v,t.needsUpdate=!0,Qt(t,e,n),t.side=y):Qt(t,e,n)}this.xr=Bt,this.getContext=function(){return Ot},this.getContextAttributes=function(){return Ot.getContextAttributes()},this.forceContextLoss=function(){const t=lt.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=lt.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(t){void 0!==t&&(F=t,this.setSize(O,U,!1))},this.getSize=function(t){return t.set(O,U)},this.setSize=function(t,n,i=!0){Bt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(O=t,U=n,e.width=Math.floor(t*F),e.height=Math.floor(n*F),!0===i&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(O*F,U*F).floor()},this.setDrawingBufferSize=function(t,n,i){O=t,U=n,F=i,e.width=Math.floor(t*i),e.height=Math.floor(n*i),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(P)},this.getViewport=function(t){return t.copy(k)},this.setViewport=function(t,e,n,i){t.isVector4?k.set(t.x,t.y,t.z,t.w):k.set(t,e,n,i),ht.viewport(P.copy(k).multiplyScalar(F).floor())},this.getScissor=function(t){return t.copy(H)},this.setScissor=function(t,e,n,i){t.isVector4?H.set(t.x,t.y,t.z,t.w):H.set(t,e,n,i),ht.scissor(I.copy(H).multiplyScalar(F).floor())},this.getScissorTest=function(){return G},this.setScissorTest=function(t){ht.setScissorTest(G=t)},this.setOpaqueSort=function(t){B=t},this.setTransparentSort=function(t){z=t},this.getClearColor=function(t){return t.copy(Rt.getClearColor())},this.setClearColor=function(){Rt.setClearColor.apply(Rt,arguments)},this.getClearAlpha=function(){return Rt.getClearAlpha()},this.setClearAlpha=function(){Rt.setClearAlpha.apply(Rt,arguments)},this.clear=function(t=!0,e=!0,n=!0){let i=0;if(t){let t=!1;if(null!==A){const e=A.texture.format;t=e===mt||e===pt||e===ut}if(t){const t=A.texture.type,e=t===J||t===et||t===$||t===st||t===rt||t===at,n=Rt.getClearColor(),i=Rt.getClearAlpha(),r=n.r,a=n.g,s=n.b;e?(p[0]=r,p[1]=a,p[2]=s,p[3]=i,Ot.clearBufferuiv(Ot.COLOR,0,p)):(m[0]=r,m[1]=a,m[2]=s,m[3]=i,Ot.clearBufferiv(Ot.COLOR,0,m))}else i|=Ot.COLOR_BUFFER_BIT}e&&(i|=Ot.DEPTH_BUFFER_BIT),n&&(i|=Ot.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Ot.clear(i)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",zt,!1),e.removeEventListener("webglcontextrestored",kt,!1),e.removeEventListener("webglcontextcreationerror",Ht,!1),St.dispose(),Tt.dispose(),ft.dispose(),vt.dispose(),_t.dispose(),bt.dispose(),Dt.dispose(),Nt.dispose(),wt.dispose(),Bt.dispose(),Bt.removeEventListener("sessionstart",jt),Bt.removeEventListener("sessionend",Xt),X&&(X.dispose(),X=null),qt.stop()},this.renderBufferDirect=function(t,e,n,i,r,a){null===e&&(e=Q);const s=r.isMesh&&r.matrixWorld.determinant()<0,o=function(t,e,n,i,r){!0!==e.isScene&&(e=Q);gt.resetTextureUnits();const a=e.fog,s=i.isMeshStandardMaterial?e.environment:null,o=null===A?w.outputColorSpace:!0===A.isXRRenderTarget?A.texture.colorSpace:re,l=(i.isMeshStandardMaterial?_t:vt).get(i.envMap||s),c=!0===i.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,h=!!n.attributes.tangent&&(!!i.normalMap||i.anisotropy>0),u=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,p=!!n.morphAttributes.color;let m=E;i.toneMapped&&(null!==A&&!0!==A.isXRRenderTarget||(m=w.toneMapping));const f=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,v=void 0!==f?f.length:0,_=ft.get(i),y=g.state.lights;if(!0===W&&(!0===j||t!==C)){const e=t===C&&i.id===R;Et.setState(i,t,e)}let x=!1;i.version===_.__version?_.needsLights&&_.lightsStateVersion!==y.state.version||_.outputColorSpace!==o||r.isBatchedMesh&&!1===_.batching?x=!0:r.isBatchedMesh||!0!==_.batching?r.isInstancedMesh&&!1===_.instancing?x=!0:r.isInstancedMesh||!0!==_.instancing?r.isSkinnedMesh&&!1===_.skinning?x=!0:r.isSkinnedMesh||!0!==_.skinning?r.isInstancedMesh&&!0===_.instancingColor&&null===r.instanceColor||r.isInstancedMesh&&!1===_.instancingColor&&null!==r.instanceColor||_.envMap!==l||!0===i.fog&&_.fog!==a?x=!0:void 0===_.numClippingPlanes||_.numClippingPlanes===Et.numPlanes&&_.numIntersection===Et.numIntersection?(_.vertexAlphas!==c||_.vertexTangents!==h||_.morphTargets!==u||_.morphNormals!==d||_.morphColors!==p||_.toneMapping!==m||!0===ct.isWebGL2&&_.morphTargetsCount!==v)&&(x=!0):x=!0:x=!0:x=!0:x=!0:(x=!0,_.__version=i.version);let b=_.currentProgram;!0===x&&(b=Qt(i,e,r));let M=!1,S=!1,T=!1;const P=b.getUniforms(),I=_.uniforms;ht.useProgram(b.program)&&(M=!0,S=!0,T=!0);i.id!==R&&(R=i.id,S=!0);if(M||C!==t){P.setValue(Ot,"projectionMatrix",t.projectionMatrix),P.setValue(Ot,"viewMatrix",t.matrixWorldInverse);const e=P.map.cameraPosition;void 0!==e&&e.setValue(Ot,K.setFromMatrixPosition(t.matrixWorld)),ct.logarithmicDepthBuffer&&P.setValue(Ot,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),(i.isMeshPhongMaterial||i.isMeshToonMaterial||i.isMeshLambertMaterial||i.isMeshBasicMaterial||i.isMeshStandardMaterial||i.isShaderMaterial)&&P.setValue(Ot,"isOrthographic",!0===t.isOrthographicCamera),C!==t&&(C=t,S=!0,T=!0)}if(r.isSkinnedMesh){P.setOptional(Ot,r,"bindMatrix"),P.setOptional(Ot,r,"bindMatrixInverse");const t=r.skeleton;t&&(ct.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),P.setValue(Ot,"boneTexture",t.boneTexture,gt)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}r.isBatchedMesh&&(P.setOptional(Ot,r,"batchingTexture"),P.setValue(Ot,"batchingTexture",r._matricesTexture,gt));const L=n.morphAttributes;(void 0!==L.position||void 0!==L.normal||void 0!==L.color&&!0===ct.isWebGL2)&&Ct.update(r,n,b);(S||_.receiveShadow!==r.receiveShadow)&&(_.receiveShadow=r.receiveShadow,P.setValue(Ot,"receiveShadow",r.receiveShadow));i.isMeshGouraudMaterial&&null!==i.envMap&&(I.envMap.value=l,I.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1);S&&(P.setValue(Ot,"toneMappingExposure",w.toneMappingExposure),_.needsLights&&(N=T,(D=I).ambientLightColor.needsUpdate=N,D.lightProbe.needsUpdate=N,D.directionalLights.needsUpdate=N,D.directionalLightShadows.needsUpdate=N,D.pointLights.needsUpdate=N,D.pointLightShadows.needsUpdate=N,D.spotLights.needsUpdate=N,D.spotLightShadows.needsUpdate=N,D.rectAreaLights.needsUpdate=N,D.hemisphereLights.needsUpdate=N),a&&!0===i.fog&&Mt.refreshFogUniforms(I,a),Mt.refreshMaterialUniforms(I,i,F,U,X),Ts.upload(Ot,$t(_),I,gt));var D,N;i.isShaderMaterial&&!0===i.uniformsNeedUpdate&&(Ts.upload(Ot,$t(_),I,gt),i.uniformsNeedUpdate=!1);i.isSpriteMaterial&&P.setValue(Ot,"center",r.center);if(P.setValue(Ot,"modelViewMatrix",r.modelViewMatrix),P.setValue(Ot,"normalMatrix",r.normalMatrix),P.setValue(Ot,"modelMatrix",r.matrixWorld),i.isShaderMaterial||i.isRawShaderMaterial){const t=i.uniformsGroups;for(let e=0,n=t.length;e<n;e++)if(ct.isWebGL2){const n=t[e];Nt.update(n,b),Nt.bind(n,b)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return b}(t,e,n,i,r);ht.setMaterial(i,s);let l=n.index,c=1;if(!0===i.wireframe){if(l=xt.getWireframeAttribute(n),void 0===l)return;c=2}const h=n.drawRange,u=n.attributes.position;let d=h.start*c,p=(h.start+h.count)*c;null!==a&&(d=Math.max(d,a.start*c),p=Math.min(p,(a.start+a.count)*c)),null!==l?(d=Math.max(d,0),p=Math.min(p,l.count)):null!=u&&(d=Math.max(d,0),p=Math.min(p,u.count));const m=p-d;if(m<0||m===1/0)return;let f;Dt.setup(r,i,o,n,l);let v=Pt;if(null!==l&&(f=yt.get(l),v=It,v.setIndex(f)),r.isMesh)!0===i.wireframe?(ht.setLineWidth(i.wireframeLinewidth*tt()),v.setMode(Ot.LINES)):v.setMode(Ot.TRIANGLES);else if(r.isLine){let t=i.linewidth;void 0===t&&(t=1),ht.setLineWidth(t*tt()),r.isLineSegments?v.setMode(Ot.LINES):r.isLineLoop?v.setMode(Ot.LINE_LOOP):v.setMode(Ot.LINE_STRIP)}else r.isPoints?v.setMode(Ot.POINTS):r.isSprite&&v.setMode(Ot.TRIANGLES);if(r.isBatchedMesh)v.renderMultiDraw(r._multiDrawStarts,r._multiDrawCounts,r._multiDrawCount);else if(r.isInstancedMesh)v.renderInstances(d,m,r.count);else if(n.isInstancedBufferGeometry){const t=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,e=Math.min(n.instanceCount,t);v.renderInstances(d,m,e)}else v.render(d,m)},this.compile=function(t,e,n=null){null===n&&(n=t),g=Tt.get(n),g.init(),b.push(g),n.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(g.pushLight(t),t.castShadow&&g.pushShadow(t))})),t!==n&&t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(g.pushLight(t),t.castShadow&&g.pushShadow(t))})),g.setupLights(w._useLegacyLights);const i=new Set;return t.traverse((function(t){const e=t.material;if(e)if(Array.isArray(e))for(let r=0;r<e.length;r++){const a=e[r];Vt(a,n,t),i.add(a)}else Vt(e,n,t),i.add(e)})),b.pop(),g=null,i},this.compileAsync=function(t,e,n=null){const i=this.compile(t,e,n);return new Promise((e=>{function n(){i.forEach((function(t){ft.get(t).currentProgram.isReady()&&i.delete(t)})),0!==i.size?setTimeout(n,10):e(t)}null!==lt.get("KHR_parallel_shader_compile")?n():setTimeout(n,10)}))};let Wt=null;function jt(){qt.stop()}function Xt(){qt.start()}const qt=new Or;function Yt(t,e,n,i){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)g.pushLight(t),t.castShadow&&g.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||V.intersectsSprite(t)){i&&K.setFromMatrixPosition(t.matrixWorld).applyMatrix4(q);const e=bt.update(t),r=t.material;r.visible&&f.push(t,e,r,n,K.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||V.intersectsObject(t))){const e=bt.update(t),r=t.material;if(i&&(void 0!==t.boundingSphere?(null===t.boundingSphere&&t.computeBoundingSphere(),K.copy(t.boundingSphere.center)):(null===e.boundingSphere&&e.computeBoundingSphere(),K.copy(e.boundingSphere.center)),K.applyMatrix4(t.matrixWorld).applyMatrix4(q)),Array.isArray(r)){const i=e.groups;for(let a=0,s=i.length;a<s;a++){const s=i[a],o=r[s.materialIndex];o&&o.visible&&f.push(t,e,o,n,K.z,s)}}else r.visible&&f.push(t,e,r,n,K.z,null)}const r=t.children;for(let t=0,a=r.length;t<a;t++)Yt(r[t],e,n,i)}function Zt(t,e,n,i){const r=t.opaque,a=t.transmissive,s=t.transparent;g.setupLightsView(n),!0===W&&Et.setGlobalState(w.clippingPlanes,n),a.length>0&&function(t,e,n,i){const r=!0===n.isScene?n.overrideMaterial:null;if(null!==r)return;const a=ct.isWebGL2;null===X&&(X=new rn(1,1,{generateMipmaps:!0,type:lt.has("EXT_color_buffer_half_float")?it:J,minFilter:Z,samples:a?4:0}));w.getDrawingBufferSize(Y),a?X.setSize(Y.x,Y.y):X.setSize(Ae(Y.x),Ae(Y.y));const s=w.getRenderTarget();w.setRenderTarget(X),w.getClearColor(D),N=w.getClearAlpha(),N<1&&w.setClearColor(16777215,.5);w.clear();const o=w.toneMapping;w.toneMapping=E,Jt(t,n,i),gt.updateMultisampleRenderTarget(X),gt.updateRenderTargetMipmap(X);let l=!1;for(let t=0,r=e.length;t<r;t++){const r=e[t],a=r.object,s=r.geometry,o=r.material,c=r.group;if(o.side===y&&a.layers.test(i.layers)){const t=o.side;o.side=_,o.needsUpdate=!0,Kt(a,n,i,s,o,c),o.side=t,o.needsUpdate=!0,l=!0}}!0===l&&(gt.updateMultisampleRenderTarget(X),gt.updateRenderTargetMipmap(X));w.setRenderTarget(s),w.setClearColor(D,N),w.toneMapping=o}(r,a,e,n),i&&ht.viewport(P.copy(i)),r.length>0&&Jt(r,e,n),a.length>0&&Jt(a,e,n),s.length>0&&Jt(s,e,n),ht.buffers.depth.setTest(!0),ht.buffers.depth.setMask(!0),ht.buffers.color.setMask(!0),ht.setPolygonOffset(!1)}function Jt(t,e,n){const i=!0===e.isScene?e.overrideMaterial:null;for(let r=0,a=t.length;r<a;r++){const a=t[r],s=a.object,o=a.geometry,l=null===i?a.material:i,c=a.group;s.layers.test(n.layers)&&Kt(s,e,n,o,l,c)}}function Kt(t,e,n,i,r,a){t.onBeforeRender(w,e,n,i,r,a),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),r.onBeforeRender(w,e,n,i,t,a),!0===r.transparent&&r.side===y&&!1===r.forceSinglePass?(r.side=_,r.needsUpdate=!0,w.renderBufferDirect(n,e,i,r,t,a),r.side=v,r.needsUpdate=!0,w.renderBufferDirect(n,e,i,r,t,a),r.side=y):w.renderBufferDirect(n,e,i,r,t,a),t.onAfterRender(w,e,n,i,r,a)}function Qt(t,e,n){!0!==e.isScene&&(e=Q);const i=ft.get(t),r=g.state.lights,a=g.state.shadowsArray,s=r.state.version,o=wt.getParameters(t,r.state,a,e,n),l=wt.getProgramCacheKey(o);let c=i.programs;i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=(t.isMeshStandardMaterial?_t:vt).get(t.envMap||i.environment),void 0===c&&(t.addEventListener("dispose",Gt),c=new Map,i.programs=c);let h=c.get(l);if(void 0!==h){if(i.currentProgram===h&&i.lightsStateVersion===s)return te(t,o),h}else o.uniforms=wt.getUniforms(t),t.onBuild(n,o,w),t.onBeforeCompile(o,w),h=wt.acquireProgram(o,l),c.set(l,h),i.uniforms=o.uniforms;const u=i.uniforms;return(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(u.clippingPlanes=Et.uniform),te(t,o),i.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),i.lightsStateVersion=s,i.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotLightMatrix.value=r.state.spotLightMatrix,u.spotLightMap.value=r.state.spotLightMap,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix),i.currentProgram=h,i.uniformsList=null,h}function $t(t){if(null===t.uniformsList){const e=t.currentProgram.getUniforms();t.uniformsList=Ts.seqWithValue(e.seq,t.uniforms)}return t.uniformsList}function te(t,e){const n=ft.get(t);n.outputColorSpace=e.outputColorSpace,n.batching=e.batching,n.instancing=e.instancing,n.instancingColor=e.instancingColor,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}qt.setAnimationLoop((function(t){Wt&&Wt(t)})),"undefined"!=typeof self&&qt.setContext(self),this.setAnimationLoop=function(t){Wt=t,Bt.setAnimationLoop(t),null===t?qt.stop():qt.start()},Bt.addEventListener("sessionstart",jt),Bt.addEventListener("sessionend",Xt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===M)return;!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Bt.enabled&&!0===Bt.isPresenting&&(!0===Bt.cameraAutoUpdate&&Bt.updateCamera(e),e=Bt.getCamera()),!0===t.isScene&&t.onBeforeRender(w,t,e,A),g=Tt.get(t,b.length),g.init(),b.push(g),q.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),V.setFromProjectionMatrix(q),j=this.localClippingEnabled,W=Et.init(this.clippingPlanes,j),f=St.get(t,x.length),f.init(),x.push(f),Yt(t,e,0,w.sortObjects),f.finish(),!0===w.sortObjects&&f.sort(B,z),this.info.render.frame++,!0===W&&Et.beginShadows();const n=g.state.shadowsArray;if(At.render(n,t,e),!0===W&&Et.endShadows(),!0===this.info.autoReset&&this.info.reset(),Rt.render(f,t),g.setupLights(w._useLegacyLights),e.isArrayCamera){const n=e.cameras;for(let e=0,i=n.length;e<i;e++){const i=n[e];Zt(f,t,i,i.viewport)}}else Zt(f,t,e);null!==A&&(gt.updateMultisampleRenderTarget(A),gt.updateRenderTargetMipmap(A)),!0===t.isScene&&t.onAfterRender(w,t,e),Dt.resetDefaultState(),R=-1,C=null,b.pop(),g=b.length>0?b[b.length-1]:null,x.pop(),f=x.length>0?x[x.length-1]:null},this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return T},this.getRenderTarget=function(){return A},this.setRenderTargetTextures=function(t,e,n){ft.get(t.texture).__webglTexture=e,ft.get(t.depthTexture).__webglTexture=n;const i=ft.get(t);i.__hasExternalTextures=!0,i.__hasExternalTextures&&(i.__autoAllocateDepthBuffer=void 0===n,i.__autoAllocateDepthBuffer||!0===lt.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),i.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(t,e){const n=ft.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){A=t,S=e,T=n;let i=!0,r=null,a=!1,s=!1;if(t){const o=ft.get(t);void 0!==o.__useDefaultFramebuffer?(ht.bindFramebuffer(Ot.FRAMEBUFFER,null),i=!1):void 0===o.__webglFramebuffer?gt.setupRenderTarget(t):o.__hasExternalTextures&&gt.rebindTextures(t,ft.get(t.texture).__webglTexture,ft.get(t.depthTexture).__webglTexture);const l=t.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(s=!0);const c=ft.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(r=Array.isArray(c[e])?c[e][n]:c[e],a=!0):r=ct.isWebGL2&&t.samples>0&&!1===gt.useMultisampledRTT(t)?ft.get(t).__webglMultisampledFramebuffer:Array.isArray(c)?c[n]:c,P.copy(t.viewport),I.copy(t.scissor),L=t.scissorTest}else P.copy(k).multiplyScalar(F).floor(),I.copy(H).multiplyScalar(F).floor(),L=G;if(ht.bindFramebuffer(Ot.FRAMEBUFFER,r)&&ct.drawBuffers&&i&&ht.drawBuffers(t,r),ht.viewport(P),ht.scissor(I),ht.setScissorTest(L),a){const i=ft.get(t.texture);Ot.framebufferTexture2D(Ot.FRAMEBUFFER,Ot.COLOR_ATTACHMENT0,Ot.TEXTURE_CUBE_MAP_POSITIVE_X+e,i.__webglTexture,n)}else if(s){const i=ft.get(t.texture),r=e||0;Ot.framebufferTextureLayer(Ot.FRAMEBUFFER,Ot.COLOR_ATTACHMENT0,i.__webglTexture,n||0,r)}R=-1},this.readRenderTargetPixels=function(t,e,n,i,r,a,s){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=ft.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==s&&(o=o[s]),o){ht.bindFramebuffer(Ot.FRAMEBUFFER,o);try{const s=t.texture,o=s.format,l=s.type;if(o!==ot&&Lt.convert(o)!==Ot.getParameter(Ot.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===it&&(lt.has("EXT_color_buffer_half_float")||ct.isWebGL2&&lt.has("EXT_color_buffer_float"));if(!(l===J||Lt.convert(l)===Ot.getParameter(Ot.IMPLEMENTATION_COLOR_READ_TYPE)||l===nt&&(ct.isWebGL2||lt.has("OES_texture_float")||lt.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&Ot.readPixels(e,n,i,r,Lt.convert(o),Lt.convert(l),a)}finally{const t=null!==A?ft.get(A).__webglFramebuffer:null;ht.bindFramebuffer(Ot.FRAMEBUFFER,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){const i=Math.pow(2,-n),r=Math.floor(e.image.width*i),a=Math.floor(e.image.height*i);gt.setTexture2D(e,0),Ot.copyTexSubImage2D(Ot.TEXTURE_2D,n,0,0,t.x,t.y,r,a),ht.unbindTexture()},this.copyTextureToTexture=function(t,e,n,i=0){const r=e.image.width,a=e.image.height,s=Lt.convert(n.format),o=Lt.convert(n.type);gt.setTexture2D(n,0),Ot.pixelStorei(Ot.UNPACK_FLIP_Y_WEBGL,n.flipY),Ot.pixelStorei(Ot.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),Ot.pixelStorei(Ot.UNPACK_ALIGNMENT,n.unpackAlignment),e.isDataTexture?Ot.texSubImage2D(Ot.TEXTURE_2D,i,t.x,t.y,r,a,s,o,e.image.data):e.isCompressedTexture?Ot.compressedTexSubImage2D(Ot.TEXTURE_2D,i,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,s,e.mipmaps[0].data):Ot.texSubImage2D(Ot.TEXTURE_2D,i,t.x,t.y,s,o,e.image),0===i&&n.generateMipmaps&&Ot.generateMipmap(Ot.TEXTURE_2D),ht.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,i,r=0){if(w.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const a=t.max.x-t.min.x+1,s=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=Lt.convert(i.format),c=Lt.convert(i.type);let h;if(i.isData3DTexture)gt.setTexture3D(i,0),h=Ot.TEXTURE_3D;else{if(!i.isDataArrayTexture&&!i.isCompressedArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");gt.setTexture2DArray(i,0),h=Ot.TEXTURE_2D_ARRAY}Ot.pixelStorei(Ot.UNPACK_FLIP_Y_WEBGL,i.flipY),Ot.pixelStorei(Ot.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),Ot.pixelStorei(Ot.UNPACK_ALIGNMENT,i.unpackAlignment);const u=Ot.getParameter(Ot.UNPACK_ROW_LENGTH),d=Ot.getParameter(Ot.UNPACK_IMAGE_HEIGHT),p=Ot.getParameter(Ot.UNPACK_SKIP_PIXELS),m=Ot.getParameter(Ot.UNPACK_SKIP_ROWS),f=Ot.getParameter(Ot.UNPACK_SKIP_IMAGES),g=n.isCompressedTexture?n.mipmaps[r]:n.image;Ot.pixelStorei(Ot.UNPACK_ROW_LENGTH,g.width),Ot.pixelStorei(Ot.UNPACK_IMAGE_HEIGHT,g.height),Ot.pixelStorei(Ot.UNPACK_SKIP_PIXELS,t.min.x),Ot.pixelStorei(Ot.UNPACK_SKIP_ROWS,t.min.y),Ot.pixelStorei(Ot.UNPACK_SKIP_IMAGES,t.min.z),n.isDataTexture||n.isData3DTexture?Ot.texSubImage3D(h,r,e.x,e.y,e.z,a,s,o,l,c,g.data):n.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Ot.compressedTexSubImage3D(h,r,e.x,e.y,e.z,a,s,o,l,g.data)):Ot.texSubImage3D(h,r,e.x,e.y,e.z,a,s,o,l,c,g),Ot.pixelStorei(Ot.UNPACK_ROW_LENGTH,u),Ot.pixelStorei(Ot.UNPACK_IMAGE_HEIGHT,d),Ot.pixelStorei(Ot.UNPACK_SKIP_PIXELS,p),Ot.pixelStorei(Ot.UNPACK_SKIP_ROWS,m),Ot.pixelStorei(Ot.UNPACK_SKIP_IMAGES,f),0===r&&i.generateMipmaps&&Ot.generateMipmap(h),ht.unbindTexture()},this.initTexture=function(t){t.isCubeTexture?gt.setTextureCube(t,0):t.isData3DTexture?gt.setTexture3D(t,0):t.isDataArrayTexture||t.isCompressedArrayTexture?gt.setTexture2DArray(t,0):gt.setTexture2D(t,0),ht.unbindTexture()},this.resetState=function(){S=0,T=0,A=null,ht.reset(),Dt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return fe}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(t){this._outputColorSpace=t;const e=this.getContext();e.drawingBufferColorSpace=t===ae?"display-p3":"srgb",e.unpackColorSpace=je.workingColorSpace===se?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===ie?ee:te}set outputEncoding(t){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=t===ee?ie:re}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(t){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=t}}class xo extends yo{}xo.prototype.isWebGL1Renderer=!0;class bo{constructor(t,e=25e-5){this.isFogExp2=!0,this.name="",this.color=new Ai(t),this.density=e}clone(){return new bo(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class wo{constructor(t,e=1,n=1e3){this.isFog=!0,this.name="",this.color=new Ai(t),this.near=e,this.far=n}clone(){return new wo(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Mo extends hi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(e.object.backgroundIntensity=this.backgroundIntensity),e}}class So{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=de,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=we()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}get updateRange(){return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=we()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=we()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const To=new cn;class Eo{constructor(t,e,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)To.fromBufferAttribute(this,e),To.applyMatrix4(t),this.setXYZ(e,To.x,To.y,To.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)To.fromBufferAttribute(this,e),To.applyNormalMatrix(t),this.setXYZ(e,To.x,To.y,To.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)To.fromBufferAttribute(this,e),To.transformDirection(t),this.setXYZ(e,To.x,To.y,To.z);return this}setX(t,e){return this.normalized&&(e=Ce(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Ce(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Ce(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Ce(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Re(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Re(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Re(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Re(e,this.array)),e}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this}setXYZW(t,e,n,i,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array),r=Ce(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=i,this.data.array[t+3]=r,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new zi(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Eo(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Ao extends Pi{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Ai(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let Ro;const Co=new cn,Po=new cn,Io=new cn,Lo=new Ie,Do=new Ie,No=new zn,Oo=new cn,Uo=new cn,Fo=new cn,Bo=new Ie,zo=new Ie,ko=new Ie;class Ho extends hi{constructor(t=new Ao){if(super(),this.isSprite=!0,this.type="Sprite",void 0===Ro){Ro=new Ji;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new So(t,5);Ro.setIndex([0,1,2,0,2,3]),Ro.setAttribute("position",new Eo(e,3,0,!1)),Ro.setAttribute("uv",new Eo(e,2,3,!1))}this.geometry=Ro,this.material=t,this.center=new Ie(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Po.setFromMatrixScale(this.matrixWorld),No.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Io.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Po.multiplyScalar(-Io.z);const n=this.material.rotation;let i,r;0!==n&&(r=Math.cos(n),i=Math.sin(n));const a=this.center;Go(Oo.set(-.5,-.5,0),Io,a,Po,i,r),Go(Uo.set(.5,-.5,0),Io,a,Po,i,r),Go(Fo.set(.5,.5,0),Io,a,Po,i,r),Bo.set(0,0),zo.set(1,0),ko.set(1,1);let s=t.ray.intersectTriangle(Oo,Uo,Fo,!1,Co);if(null===s&&(Go(Uo.set(-.5,.5,0),Io,a,Po,i,r),zo.set(0,1),s=t.ray.intersectTriangle(Oo,Fo,Uo,!1,Co),null===s))return;const o=t.ray.origin.distanceTo(Co);o<t.near||o>t.far||e.push({distance:o,point:Co.clone(),uv:wi.getInterpolation(Co,Oo,Uo,Fo,Bo,zo,ko,new Ie),face:null,object:this})}copy(t,e){return super.copy(t,e),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Go(t,e,n,i,r,a){Lo.subVectors(t,n).addScalar(.5).multiply(i),void 0!==r?(Do.x=a*Lo.x-r*Lo.y,Do.y=r*Lo.x+a*Lo.y):Do.copy(Lo),t.copy(e),t.x+=Do.x,t.y+=Do.y,t.applyMatrix4(No)}const Vo=new cn,Wo=new cn;class jo extends hi{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance,n.hysteresis)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0,n=0){e=Math.abs(e);const i=this.levels;let r;for(r=0;r<i.length&&!(e<i[r].distance);r++);return i.splice(r,0,{distance:e,hysteresis:n,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,i;for(n=1,i=e.length;n<i;n++){let i=e[n].distance;if(e[n].object.visible&&(i-=i*e[n].hysteresis),t<i)break}return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Vo.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Vo);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Vo.setFromMatrixPosition(t.matrixWorld),Wo.setFromMatrixPosition(this.matrixWorld);const n=Vo.distanceTo(Wo)/t.zoom;let i,r;for(e[0].object.visible=!0,i=1,r=e.length;i<r;i++){let t=e[i].distance;if(e[i].object.visible&&(t-=t*e[i].hysteresis),!(n>=t))break;e[i-1].object.visible=!1,e[i].object.visible=!0}for(this._currentLevel=i-1;i<r;i++)e[i].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,i=n.length;t<i;t++){const i=n[t];e.object.levels.push({object:i.object.uuid,distance:i.distance,hysteresis:i.hysteresis})}return e}}const Xo=new cn,qo=new en,Yo=new en,Zo=new cn,Jo=new zn,Ko=new cn,Qo=new Pn,$o=new zn,tl=new Bn;class el extends mr{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=D,this.bindMatrix=new zn,this.bindMatrixInverse=new zn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;null===this.boundingBox&&(this.boundingBox=new dn),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Ko),this.boundingBox.expandByPoint(Ko)}computeBoundingSphere(){const t=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Pn),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Ko),this.boundingSphere.expandByPoint(Ko)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const n=this.material,i=this.matrixWorld;void 0!==n&&(null===this.boundingSphere&&this.computeBoundingSphere(),Qo.copy(this.boundingSphere),Qo.applyMatrix4(i),!1!==t.ray.intersectsSphere(Qo)&&($o.copy(i).invert(),tl.copy(t.ray).applyMatrix4($o),null!==this.boundingBox&&!1===tl.intersectsBox(this.boundingBox)||this._computeIntersections(t,e,tl)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new en,e=this.geometry.attributes.skinWeight;for(let n=0,i=e.count;n<i;n++){t.fromBufferAttribute(e,n);const i=1/t.manhattanLength();i!==1/0?t.multiplyScalar(i):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===D?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===N?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const n=this.skeleton,i=this.geometry;qo.fromBufferAttribute(i.attributes.skinIndex,t),Yo.fromBufferAttribute(i.attributes.skinWeight,t),Xo.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=Yo.getComponent(t);if(0!==i){const r=qo.getComponent(t);Jo.multiplyMatrices(n.bones[r].matrixWorld,n.boneInverses[r]),e.addScaledVector(Zo.copy(Xo).applyMatrix4(Jo),i)}}return e.applyMatrix4(this.bindMatrixInverse)}boneTransform(t,e){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(t,e)}}class nl extends hi{constructor(){super(),this.isBone=!0,this.type="Bone"}}class il extends tn{constructor(t=null,e=1,n=1,i,r,a,s,o,l=1003,c=1003,h,u){super(null,a,s,o,l,c,i,r,h,u),this.isDataTexture=!0,this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const rl=new zn,al=new zn;class sl{constructor(t=[],e=[]){this.uuid=we(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new zn)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new zn;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let i=0,r=t.length;i<r;i++){const r=t[i]?t[i].matrixWorld:al;rl.multiplyMatrices(r,e[i]),rl.toArray(n,16*i)}null!==i&&(i.needsUpdate=!0)}clone(){return new sl(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new il(e,t,t,ot,nt);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,i=t.bones.length;n<i;n++){const i=t.bones[n];let r=e[i];void 0===r&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),r=new nl),this.bones.push(r),this.boneInverses.push((new zn).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let i=0,r=e.length;i<r;i++){const r=e[i];t.bones.push(r.uuid);const a=n[i];t.boneInverses.push(a.toArray())}return t}}class ol extends zi{constructor(t,e,n,i=1){super(t,e,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const ll=new zn,cl=new zn,hl=[],ul=new dn,dl=new zn,pl=new mr,ml=new Pn;class fl extends mr{constructor(t,e,n){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new ol(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let t=0;t<n;t++)this.setMatrixAt(t,dl)}computeBoundingBox(){const t=this.geometry,e=this.count;null===this.boundingBox&&(this.boundingBox=new dn),null===t.boundingBox&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,ll),ul.copy(t.boundingBox).applyMatrix4(ll),this.boundingBox.union(ul)}computeBoundingSphere(){const t=this.geometry,e=this.count;null===this.boundingSphere&&(this.boundingSphere=new Pn),null===t.boundingSphere&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<e;n++)this.getMatrixAt(n,ll),ml.copy(t.boundingSphere).applyMatrix4(ll),this.boundingSphere.union(ml)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone()),null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,i=this.count;if(pl.geometry=this.geometry,pl.material=this.material,void 0!==pl.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),ml.copy(this.boundingSphere),ml.applyMatrix4(n),!1!==t.ray.intersectsSphere(ml)))for(let r=0;r<i;r++){this.getMatrixAt(r,ll),cl.multiplyMatrices(n,ll),pl.matrixWorld=cl,pl.raycast(t,hl);for(let t=0,n=hl.length;t<n;t++){const n=hl[t];n.instanceId=r,n.object=this,e.push(n)}hl.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new ol(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function gl(t,e){return t.z-e.z}function vl(t,e){return e.z-t.z}class _l{constructor(){this.index=0,this.pool=[],this.list=[]}push(t,e){const n=this.pool,i=this.list;this.index>=n.length&&n.push({start:-1,count:-1,z:-1});const r=n[this.index];i.push(r),this.index++,r.start=t.start,r.count=t.count,r.z=e}reset(){this.list.length=0,this.index=0}}const yl="batchId",xl=new zn,bl=new zn,wl=new zn,Ml=new zn,Sl=new Nr,Tl=new dn,El=new Pn,Al=new cn,Rl=new _l,Cl=new mr,Pl=[];function Il(t,e,n=0){const i=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const r=t.count;for(let a=0;a<r;a++)for(let r=0;r<i;r++)e.setComponent(a+n,r,t.getComponent(a,r))}else e.array.set(t.array,n*i);e.needsUpdate=!0}class Ll extends mr{get maxGeometryCount(){return this._maxGeometryCount}constructor(t,e,n=2*e,i){super(new Ji,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=t,this._maxVertexCount=e,this._maxIndexCount=n,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(t),this._multiDrawStarts=new Int32Array(t),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let t=Math.sqrt(4*this._maxGeometryCount);t=4*Math.ceil(t/4),t=Math.max(t,4);const e=new Float32Array(t*t*4),n=new il(e,t,t,ot,nt);this._matricesTexture=n}_initializeGeometry(t){const e=this.geometry,n=this._maxVertexCount,i=this._maxGeometryCount,r=this._maxIndexCount;if(!1===this._geometryInitialized){for(const i in t.attributes){const r=t.getAttribute(i),{array:a,itemSize:s,normalized:o}=r,l=new a.constructor(n*s),c=new r.constructor(l,s,o);c.setUsage(r.usage),e.setAttribute(i,c)}if(null!==t.getIndex()){const t=n>65536?new Uint32Array(r):new Uint16Array(r);e.setIndex(new zi(t,1))}const a=i>65536?new Uint32Array(n):new Uint16Array(n);e.setAttribute(yl,new zi(a,1)),this._geometryInitialized=!0}}_validateGeometry(t){if(t.getAttribute(yl))throw new Error(`BatchedMesh: Geometry cannot use attribute "${yl}"`);const e=this.geometry;if(Boolean(t.getIndex())!==Boolean(e.getIndex()))throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const n in e.attributes){if(n===yl)continue;if(!t.hasAttribute(n))throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);const i=t.getAttribute(n),r=e.getAttribute(n);if(i.itemSize!==r.itemSize||i.normalized!==r.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(t){return this.customSort=t,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new dn);const t=this._geometryCount,e=this.boundingBox,n=this._active;e.makeEmpty();for(let i=0;i<t;i++)!1!==n[i]&&(this.getMatrixAt(i,xl),this.getBoundingBoxAt(i,Tl).applyMatrix4(xl),e.union(Tl))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Pn);const t=this._geometryCount,e=this.boundingSphere,n=this._active;e.makeEmpty();for(let i=0;i<t;i++)!1!==n[i]&&(this.getMatrixAt(i,xl),this.getBoundingSphereAt(i,El).applyMatrix4(xl),e.union(El))}addGeometry(t,e=-1,n=-1){if(this._initializeGeometry(t),this._validateGeometry(t),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const i={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let r=null;const a=this._reservedRanges,s=this._drawRanges,o=this._bounds;0!==this._geometryCount&&(r=a[a.length-1]),i.vertexCount=-1===e?t.getAttribute("position").count:e,i.vertexStart=null===r?0:r.vertexStart+r.vertexCount;const l=t.getIndex(),c=null!==l;if(c&&(i.indexCount=-1===n?l.count:n,i.indexStart=null===r?0:r.indexStart+r.indexCount),-1!==i.indexStart&&i.indexStart+i.indexCount>this._maxIndexCount||i.vertexStart+i.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const h=this._visibility,u=this._active,d=this._matricesTexture,p=this._matricesTexture.image.data;h.push(!0),u.push(!0);const m=this._geometryCount;this._geometryCount++,wl.toArray(p,16*m),d.needsUpdate=!0,a.push(i),s.push({start:c?i.indexStart:i.vertexStart,count:-1}),o.push({boxInitialized:!1,box:new dn,sphereInitialized:!1,sphere:new Pn});const f=this.geometry.getAttribute(yl);for(let t=0;t<i.vertexCount;t++)f.setX(i.vertexStart+t,m);return f.needsUpdate=!0,this.setGeometryAt(m,t),m}setGeometryAt(t,e){if(t>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(e);const n=this.geometry,i=null!==n.getIndex(),r=n.getIndex(),a=e.getIndex(),s=this._reservedRanges[t];if(i&&a.count>s.indexCount||e.attributes.position.count>s.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const o=s.vertexStart,l=s.vertexCount;for(const t in n.attributes){if(t===yl)continue;const i=e.getAttribute(t),r=n.getAttribute(t);Il(i,r,o);const a=i.itemSize;for(let t=i.count,e=l;t<e;t++){const e=o+t;for(let t=0;t<a;t++)r.setComponent(e,t,0)}r.needsUpdate=!0}if(i){const t=s.indexStart;for(let e=0;e<a.count;e++)r.setX(t+e,o+a.getX(e));for(let e=a.count,n=s.indexCount;e<n;e++)r.setX(t+e,o);r.needsUpdate=!0}const c=this._bounds[t];null!==e.boundingBox?(c.box.copy(e.boundingBox),c.boxInitialized=!0):c.boxInitialized=!1,null!==e.boundingSphere?(c.sphere.copy(e.boundingSphere),c.sphereInitialized=!0):c.sphereInitialized=!1;const h=this._drawRanges[t],u=e.getAttribute("position");return h.count=i?a.count:u.count,this._visibilityChanged=!0,t}deleteGeometry(t){const e=this._active;return t>=e.length||!1===e[t]||(e[t]=!1,this._visibilityChanged=!0),this}getBoundingBoxAt(t,e){if(!1===this._active[t])return this;const n=this._bounds[t],i=n.box,r=this.geometry;if(!1===n.boxInitialized){i.makeEmpty();const e=r.index,a=r.attributes.position,s=this._drawRanges[t];for(let t=s.start,n=s.start+s.count;t<n;t++){let n=t;e&&(n=e.getX(n)),i.expandByPoint(Al.fromBufferAttribute(a,n))}n.boxInitialized=!0}return e.copy(i),e}getBoundingSphereAt(t,e){if(!1===this._active[t])return this;const n=this._bounds[t],i=n.sphere,r=this.geometry;if(!1===n.sphereInitialized){i.makeEmpty(),this.getBoundingBoxAt(t,Tl),Tl.getCenter(i.center);const e=r.index,a=r.attributes.position,s=this._drawRanges[t];let o=0;for(let t=s.start,n=s.start+s.count;t<n;t++){let n=t;e&&(n=e.getX(n)),Al.fromBufferAttribute(a,n),o=Math.max(o,i.center.distanceToSquared(Al))}i.radius=Math.sqrt(o),n.sphereInitialized=!0}return e.copy(i),e}setMatrixAt(t,e){const n=this._active,i=this._matricesTexture,r=this._matricesTexture.image.data;return t>=this._geometryCount||!1===n[t]||(e.toArray(r,16*t),i.needsUpdate=!0),this}getMatrixAt(t,e){const n=this._active,i=this._matricesTexture.image.data;return t>=this._geometryCount||!1===n[t]?null:e.fromArray(i,16*t)}setVisibleAt(t,e){const n=this._visibility,i=this._active;return t>=this._geometryCount||!1===i[t]||n[t]===e||(n[t]=e,this._visibilityChanged=!0),this}getVisibleAt(t){const e=this._visibility,n=this._active;return!(t>=this._geometryCount||!1===n[t])&&e[t]}raycast(t,e){const n=this._visibility,i=this._active,r=this._drawRanges,a=this._geometryCount,s=this.matrixWorld,o=this.geometry;Cl.material=this.material,Cl.geometry.index=o.index,Cl.geometry.attributes=o.attributes,null===Cl.geometry.boundingBox&&(Cl.geometry.boundingBox=new dn),null===Cl.geometry.boundingSphere&&(Cl.geometry.boundingSphere=new Pn);for(let o=0;o<a;o++){if(!n[o]||!i[o])continue;const a=r[o];Cl.geometry.setDrawRange(a.start,a.count),this.getMatrixAt(o,Cl.matrixWorld).premultiply(s),this.getBoundingBoxAt(o,Cl.geometry.boundingBox),this.getBoundingSphereAt(o,Cl.geometry.boundingSphere),Cl.raycast(t,Pl);for(let t=0,n=Pl.length;t<n;t++){const n=Pl[t];n.object=this,n.batchId=o,e.push(n)}Pl.length=0}Cl.material=null,Cl.geometry.index=null,Cl.geometry.attributes={},Cl.geometry.setDrawRange(0,1/0)}copy(t){return super.copy(t),this.geometry=t.geometry.clone(),this.perObjectFrustumCulled=t.perObjectFrustumCulled,this.sortObjects=t.sortObjects,this.boundingBox=null!==t.boundingBox?t.boundingBox.clone():null,this.boundingSphere=null!==t.boundingSphere?t.boundingSphere.clone():null,this._drawRanges=t._drawRanges.map((t=>({...t}))),this._reservedRanges=t._reservedRanges.map((t=>({...t}))),this._visibility=t._visibility.slice(),this._active=t._active.slice(),this._bounds=t._bounds.map((t=>({boxInitialized:t.boxInitialized,box:t.box.clone(),sphereInitialized:t.sphereInitialized,sphere:t.sphere.clone()}))),this._maxGeometryCount=t._maxGeometryCount,this._maxVertexCount=t._maxVertexCount,this._maxIndexCount=t._maxIndexCount,this._geometryInitialized=t._geometryInitialized,this._geometryCount=t._geometryCount,this._multiDrawCounts=t._multiDrawCounts.slice(),this._multiDrawStarts=t._multiDrawStarts.slice(),this._matricesTexture=t._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(t,e,n,i,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const a=i.getIndex(),s=null===a?1:a.array.BYTES_PER_ELEMENT,o=this._visibility,l=this._multiDrawStarts,c=this._multiDrawCounts,h=this._drawRanges,u=this.perObjectFrustumCulled;u&&(Ml.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse).multiply(this.matrixWorld),Sl.setFromProjectionMatrix(Ml,t.isWebGPURenderer?ge:fe));let d=0;if(this.sortObjects){bl.copy(this.matrixWorld).invert(),Al.setFromMatrixPosition(n.matrixWorld).applyMatrix4(bl);for(let t=0,e=o.length;t<e;t++)if(o[t]){this.getMatrixAt(t,xl),this.getBoundingSphereAt(t,El).applyMatrix4(xl);let e=!1;if(u&&(e=!Sl.intersectsSphere(El)),!e){const e=Al.distanceTo(El.center);Rl.push(h[t],e)}}const t=Rl.list,e=this.customSort;null===e?t.sort(r.transparent?vl:gl):e.call(this,t,n);for(let e=0,n=t.length;e<n;e++){const n=t[e];l[d]=n.start*s,c[d]=n.count,d++}Rl.reset()}else for(let t=0,e=o.length;t<e;t++)if(o[t]){let e=!1;if(u&&(this.getMatrixAt(t,xl),this.getBoundingSphereAt(t,El).applyMatrix4(xl),e=!Sl.intersectsSphere(El)),!e){const e=h[t];l[d]=e.start*s,c[d]=e.count,d++}}this._multiDrawCount=d,this._visibilityChanged=!1}onBeforeShadow(t,e,n,i,r,a){this.onBeforeRender(t,null,i,r,a)}}class Dl extends Pi{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Ai(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Nl=new cn,Ol=new cn,Ul=new zn,Fl=new Bn,Bl=new Pn;class zl extends hi{constructor(t=new Ji,e=new Dl){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,i=e.count;t<i;t++)Nl.fromBufferAttribute(e,t-1),Ol.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Nl.distanceTo(Ol);t.setAttribute("lineDistance",new Gi(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Bl.copy(n.boundingSphere),Bl.applyMatrix4(i),Bl.radius+=r,!1===t.ray.intersectsSphere(Bl))return;Ul.copy(i).invert(),Fl.copy(t.ray).applyMatrix4(Ul);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=new cn,c=new cn,h=new cn,u=new cn,d=this.isLineSegments?2:1,p=n.index,m=n.attributes.position;if(null!==p){for(let n=Math.max(0,a.start),i=Math.min(p.count,a.start+a.count)-1;n<i;n+=d){const i=p.getX(n),r=p.getX(n+1);l.fromBufferAttribute(m,i),c.fromBufferAttribute(m,r);if(Fl.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const a=t.ray.origin.distanceTo(u);a<t.near||a>t.far||e.push({distance:a,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else{for(let n=Math.max(0,a.start),i=Math.min(m.count,a.start+a.count)-1;n<i;n+=d){l.fromBufferAttribute(m,n),c.fromBufferAttribute(m,n+1);if(Fl.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const i=t.ray.origin.distanceTo(u);i<t.near||i>t.far||e.push({distance:i,point:h.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}const kl=new cn,Hl=new cn;class Gl extends zl{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,i=e.count;t<i;t+=2)kl.fromBufferAttribute(e,t),Hl.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+kl.distanceTo(Hl);t.setAttribute("lineDistance",new Gi(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Vl extends zl{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class Wl extends Pi{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Ai(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const jl=new zn,Xl=new Bn,ql=new Pn,Yl=new cn;class Zl extends hi{constructor(t=new Ji,e=new Wl){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),ql.copy(n.boundingSphere),ql.applyMatrix4(i),ql.radius+=r,!1===t.ray.intersectsSphere(ql))return;jl.copy(i).invert(),Xl.copy(t.ray).applyMatrix4(jl);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,l=n.index,c=n.attributes.position;if(null!==l){for(let n=Math.max(0,a.start),r=Math.min(l.count,a.start+a.count);n<r;n++){const r=l.getX(n);Yl.fromBufferAttribute(c,r),Jl(Yl,r,o,i,t,e,this)}}else{for(let n=Math.max(0,a.start),r=Math.min(c.count,a.start+a.count);n<r;n++)Yl.fromBufferAttribute(c,n),Jl(Yl,n,o,i,t,e,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const n=t[e[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,e=n.length;t<e;t++){const e=n[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[e]=t}}}}}function Jl(t,e,n,i,r,a,s){const o=Xl.distanceSqToPoint(t);if(o<n){const n=new cn;Xl.closestPointToPoint(t,n),n.applyMatrix4(i);const l=r.ray.origin.distanceTo(n);if(l<r.near||l>r.far)return;a.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:s})}}class Kl extends tn{constructor(t,e,n,i,r,a,s,o,l,c,h,u){super(null,a,s,o,l,c,i,r,h,u),this.isCompressedTexture=!0,this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}class Ql{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,i=this.getPoint(0),r=0;e.push(0);for(let a=1;a<=t;a++)n=this.getPoint(a/t),r+=n.distanceTo(i),e.push(r),i=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let i=0;const r=n.length;let a;a=e||t*n[r-1];let s,o=0,l=r-1;for(;o<=l;)if(i=Math.floor(o+(l-o)/2),s=n[i]-a,s<0)o=i+1;else{if(!(s>0)){l=i;break}l=i-1}if(i=l,n[i]===a)return i/(r-1);const c=n[i];return(i+(a-c)/(n[i+1]-c))/(r-1)}getTangent(t,e){const n=1e-4;let i=t-n,r=t+n;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),s=this.getPoint(r),o=e||(a.isVector2?new Ie:new cn);return o.copy(s).sub(a).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new cn,i=[],r=[],a=[],s=new cn,o=new zn;for(let e=0;e<=t;e++){const n=e/t;i[e]=this.getTangentAt(n,new cn)}r[0]=new cn,a[0]=new cn;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),h=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),u<=l&&n.set(0,0,1),s.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],s),a[0].crossVectors(i[0],r[0]);for(let e=1;e<=t;e++){if(r[e]=r[e-1].clone(),a[e]=a[e-1].clone(),s.crossVectors(i[e-1],i[e]),s.length()>Number.EPSILON){s.normalize();const t=Math.acos(Me(i[e-1].dot(i[e]),-1,1));r[e].applyMatrix4(o.makeRotationAxis(s,t))}a[e].crossVectors(i[e],r[e])}if(!0===e){let e=Math.acos(Me(r[0].dot(r[t]),-1,1));e/=t,i[0].dot(s.crossVectors(r[0],r[t]))>0&&(e=-e);for(let n=1;n<=t;n++)r[n].applyMatrix4(o.makeRotationAxis(i[n],e*n)),a[n].crossVectors(i[n],r[n])}return{tangents:i,normals:r,binormals:a}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class $l extends Ql{constructor(t=0,e=0,n=1,i=1,r=0,a=2*Math.PI,s=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=s,this.aRotation=o}getPoint(t,e){const n=e||new Ie,i=2*Math.PI;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(r=a?0:i),!0!==this.aClockwise||a||(r===i?r=-i:r-=i);const s=this.aStartAngle+t*r;let o=this.aX+this.xRadius*Math.cos(s),l=this.aY+this.yRadius*Math.sin(s);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,i=l-this.aY;o=n*t-i*e+this.aX,l=n*e+i*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}class tc extends $l{constructor(t,e,n,i,r,a){super(t,e,n,n,i,r,a),this.isArcCurve=!0,this.type="ArcCurve"}}function ec(){let t=0,e=0,n=0,i=0;function r(r,a,s,o){t=r,e=s,n=-3*r+3*a-2*s-o,i=2*r-2*a+s+o}return{initCatmullRom:function(t,e,n,i,a){r(e,n,a*(n-t),a*(i-e))},initNonuniformCatmullRom:function(t,e,n,i,a,s,o){let l=(e-t)/a-(n-t)/(a+s)+(n-e)/s,c=(n-e)/s-(i-e)/(s+o)+(i-n)/o;l*=s,c*=s,r(e,n,l,c)},calc:function(r){const a=r*r;return t+e*r+n*a+i*(a*r)}}}const nc=new cn,ic=new ec,rc=new ec,ac=new ec;class sc extends Ql{constructor(t=[],e=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}getPoint(t,e=new cn){const n=e,i=this.points,r=i.length,a=(r-(this.closed?0:1))*t;let s,o,l=Math.floor(a),c=a-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:0===c&&l===r-1&&(l=r-2,c=1),this.closed||l>0?s=i[(l-1)%r]:(nc.subVectors(i[0],i[1]).add(i[0]),s=nc);const h=i[l%r],u=i[(l+1)%r];if(this.closed||l+2<r?o=i[(l+2)%r]:(nc.subVectors(i[r-1],i[r-2]).add(i[r-1]),o=nc),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(s.distanceToSquared(h),t),n=Math.pow(h.distanceToSquared(u),t),i=Math.pow(u.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),i<1e-4&&(i=n),ic.initNonuniformCatmullRom(s.x,h.x,u.x,o.x,e,n,i),rc.initNonuniformCatmullRom(s.y,h.y,u.y,o.y,e,n,i),ac.initNonuniformCatmullRom(s.z,h.z,u.z,o.z,e,n,i)}else"catmullrom"===this.curveType&&(ic.initCatmullRom(s.x,h.x,u.x,o.x,this.tension),rc.initCatmullRom(s.y,h.y,u.y,o.y,this.tension),ac.initCatmullRom(s.z,h.z,u.z,o.z,this.tension));return n.set(ic.calc(c),rc.calc(c),ac.calc(c)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new cn).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function oc(t,e,n,i,r){const a=.5*(i-e),s=.5*(r-n),o=t*t;return(2*n-2*i+a+s)*(t*o)+(-3*n+3*i-2*a-s)*o+a*t+n}function lc(t,e,n,i){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,i)}function cc(t,e,n,i,r){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,i)+function(t,e){return t*t*t*e}(t,r)}class hc extends Ql{constructor(t=new Ie,e=new Ie,n=new Ie,i=new Ie){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new Ie){const n=e,i=this.v0,r=this.v1,a=this.v2,s=this.v3;return n.set(cc(t,i.x,r.x,a.x,s.x),cc(t,i.y,r.y,a.y,s.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class uc extends Ql{constructor(t=new cn,e=new cn,n=new cn,i=new cn){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}getPoint(t,e=new cn){const n=e,i=this.v0,r=this.v1,a=this.v2,s=this.v3;return n.set(cc(t,i.x,r.x,a.x,s.x),cc(t,i.y,r.y,a.y,s.y),cc(t,i.z,r.z,a.z,s.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}class dc extends Ql{constructor(t=new Ie,e=new Ie){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Ie){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new Ie){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class pc extends Ql{constructor(t=new cn,e=new cn){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=t,this.v2=e}getPoint(t,e=new cn){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e=new cn){return e.subVectors(this.v2,this.v1).normalize()}getTangentAt(t,e){return this.getTangent(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class mc extends Ql{constructor(t=new Ie,e=new Ie,n=new Ie){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Ie){const n=e,i=this.v0,r=this.v1,a=this.v2;return n.set(lc(t,i.x,r.x,a.x),lc(t,i.y,r.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class fc extends Ql{constructor(t=new cn,e=new cn,n=new cn){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new cn){const n=e,i=this.v0,r=this.v1,a=this.v2;return n.set(lc(t,i.x,r.x,a.x),lc(t,i.y,r.y,a.y),lc(t,i.z,r.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class gc extends Ql{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,e=new Ie){const n=e,i=this.points,r=(i.length-1)*t,a=Math.floor(r),s=r-a,o=i[0===a?a:a-1],l=i[a],c=i[a>i.length-2?i.length-1:a+1],h=i[a>i.length-3?i.length-1:a+2];return n.set(oc(s,o.x,l.x,c.x,h.x),oc(s,o.y,l.y,c.y,h.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new Ie).fromArray(n))}return this}}var vc=Object.freeze({__proto__:null,ArcCurve:tc,CatmullRomCurve3:sc,CubicBezierCurve:hc,CubicBezierCurve3:uc,EllipseCurve:$l,LineCurve:dc,LineCurve3:pc,QuadraticBezierCurve:mc,QuadraticBezierCurve3:fc,SplineCurve:gc});class _c extends Ql{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);if(!t.equals(e)){const n=!0===t.isVector2?"LineCurve":"LineCurve3";this.curves.push(new vc[n](e,t))}return this}getPoint(t,e){const n=t*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const t=i[r]-n,a=this.curves[r],s=a.getLength(),o=0===s?0:1-t/s;return a.getPointAt(o,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,i=this.curves.length;n<i;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],s=a.isEllipseCurve?2*t:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?t*a.points.length:t,o=a.getPoints(s);for(let t=0;t<o.length;t++){const i=o[t];n&&n.equals(i)||(e.push(i),n=i)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new vc[n.type]).fromJSON(n))}return this}}class yc extends _c{constructor(t){super(),this.type="Path",this.currentPoint=new Ie,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new dc(this.currentPoint.clone(),new Ie(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,i){const r=new mc(this.currentPoint.clone(),new Ie(t,e),new Ie(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(t,e,n,i,r,a){const s=new hc(this.currentPoint.clone(),new Ie(t,e),new Ie(n,i),new Ie(r,a));return this.curves.push(s),this.currentPoint.set(r,a),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new gc(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,i,r,a){const s=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+s,e+o,n,i,r,a),this}absarc(t,e,n,i,r,a){return this.absellipse(t,e,n,n,i,r,a),this}ellipse(t,e,n,i,r,a,s,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(t+l,e+c,n,i,r,a,s,o),this}absellipse(t,e,n,i,r,a,s,o){const l=new $l(t,e,n,i,r,a,s,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class xc extends Ji{constructor(t=[new Ie(0,-.5),new Ie(.5,0),new Ie(0,.5)],e=12,n=0,i=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:i},e=Math.floor(e),i=Me(i,0,2*Math.PI);const r=[],a=[],s=[],o=[],l=[],c=1/e,h=new cn,u=new Ie,d=new cn,p=new cn,m=new cn;let f=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:f=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-f,d.z=0*g,m.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(m.x,m.y,m.z);break;default:f=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-f,d.z=0*g,p.copy(d),d.x+=m.x,d.y+=m.y,d.z+=m.z,d.normalize(),o.push(d.x,d.y,d.z),m.copy(p)}for(let r=0;r<=e;r++){const d=n+r*c*i,p=Math.sin(d),m=Math.cos(d);for(let n=0;n<=t.length-1;n++){h.x=t[n].x*p,h.y=t[n].y,h.z=t[n].x*m,a.push(h.x,h.y,h.z),u.x=r/e,u.y=n/(t.length-1),s.push(u.x,u.y);const i=o[3*n+0]*p,c=o[3*n+1],d=o[3*n+0]*m;l.push(i,c,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const i=e+n*t.length,a=i,s=i+t.length,o=i+t.length+1,l=i+1;r.push(a,s,l),r.push(o,l,s)}this.setIndex(r),this.setAttribute("position",new Gi(a,3)),this.setAttribute("uv",new Gi(s,2)),this.setAttribute("normal",new Gi(l,3))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new xc(t.points,t.segments,t.phiStart,t.phiLength)}}class bc extends xc{constructor(t=1,e=1,n=4,i=8){const r=new yc;r.absarc(0,-e/2,t,1.5*Math.PI,0),r.absarc(0,e/2,t,0,.5*Math.PI),super(r.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:t,length:e,capSegments:n,radialSegments:i}}static fromJSON(t){return new bc(t.radius,t.length,t.capSegments,t.radialSegments)}}class wc extends Ji{constructor(t=1,e=32,n=0,i=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:i},e=Math.max(3,e);const r=[],a=[],s=[],o=[],l=new cn,c=new Ie;a.push(0,0,0),s.push(0,0,1),o.push(.5,.5);for(let r=0,h=3;r<=e;r++,h+=3){const u=n+r/e*i;l.x=t*Math.cos(u),l.y=t*Math.sin(u),a.push(l.x,l.y,l.z),s.push(0,0,1),c.x=(a[h]/t+1)/2,c.y=(a[h+1]/t+1)/2,o.push(c.x,c.y)}for(let t=1;t<=e;t++)r.push(t,t+1,0);this.setIndex(r),this.setAttribute("position",new Gi(a,3)),this.setAttribute("normal",new Gi(s,3)),this.setAttribute("uv",new Gi(o,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new wc(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Mc extends Ji{constructor(t=1,e=1,n=1,i=32,r=1,a=!1,s=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:s,thetaLength:o};const l=this;i=Math.floor(i),r=Math.floor(r);const c=[],h=[],u=[],d=[];let p=0;const m=[],f=n/2;let g=0;function v(n){const r=p,a=new Ie,m=new cn;let v=0;const _=!0===n?t:e,y=!0===n?1:-1;for(let t=1;t<=i;t++)h.push(0,f*y,0),u.push(0,y,0),d.push(.5,.5),p++;const x=p;for(let t=0;t<=i;t++){const e=t/i*o+s,n=Math.cos(e),r=Math.sin(e);m.x=_*r,m.y=f*y,m.z=_*n,h.push(m.x,m.y,m.z),u.push(0,y,0),a.x=.5*n+.5,a.y=.5*r*y+.5,d.push(a.x,a.y),p++}for(let t=0;t<i;t++){const e=r+t,i=x+t;!0===n?c.push(i,i+1,e):c.push(i+1,i,e),v+=3}l.addGroup(g,v,!0===n?1:2),g+=v}!function(){const a=new cn,v=new cn;let _=0;const y=(e-t)/n;for(let l=0;l<=r;l++){const c=[],g=l/r,_=g*(e-t)+t;for(let t=0;t<=i;t++){const e=t/i,r=e*o+s,l=Math.sin(r),m=Math.cos(r);v.x=_*l,v.y=-g*n+f,v.z=_*m,h.push(v.x,v.y,v.z),a.set(l,y,m).normalize(),u.push(a.x,a.y,a.z),d.push(e,1-g),c.push(p++)}m.push(c)}for(let t=0;t<i;t++)for(let e=0;e<r;e++){const n=m[e][t],i=m[e+1][t],r=m[e+1][t+1],a=m[e][t+1];c.push(n,i,a),c.push(i,r,a),_+=6}l.addGroup(g,_,0),g+=_}(),!1===a&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(c),this.setAttribute("position",new Gi(h,3)),this.setAttribute("normal",new Gi(u,3)),this.setAttribute("uv",new Gi(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Mc(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Sc extends Mc{constructor(t=1,e=1,n=32,i=1,r=!1,a=0,s=2*Math.PI){super(0,t,e,n,i,r,a,s),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:i,openEnded:r,thetaStart:a,thetaLength:s}}static fromJSON(t){return new Sc(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class Tc extends Ji{constructor(t=[],e=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:i};const r=[],a=[];function s(t,e,n,i){const r=i+1,a=[];for(let i=0;i<=r;i++){a[i]=[];const s=t.clone().lerp(n,i/r),o=e.clone().lerp(n,i/r),l=r-i;for(let t=0;t<=l;t++)a[i][t]=0===t&&i===r?s:s.clone().lerp(o,t/l)}for(let t=0;t<r;t++)for(let e=0;e<2*(r-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(a[t][n+1]),o(a[t+1][n]),o(a[t][n])):(o(a[t][n+1]),o(a[t+1][n+1]),o(a[t+1][n]))}}function o(t){r.push(t.x,t.y,t.z)}function l(e,n){const i=3*e;n.x=t[i+0],n.y=t[i+1],n.z=t[i+2]}function c(t,e,n,i){i<0&&1===t.x&&(a[e]=t.x-1),0===n.x&&0===n.z&&(a[e]=i/2/Math.PI+.5)}function h(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new cn,i=new cn,r=new cn;for(let a=0;a<e.length;a+=3)l(e[a+0],n),l(e[a+1],i),l(e[a+2],r),s(n,i,r,t)}(i),function(t){const e=new cn;for(let n=0;n<r.length;n+=3)e.x=r[n+0],e.y=r[n+1],e.z=r[n+2],e.normalize().multiplyScalar(t),r[n+0]=e.x,r[n+1]=e.y,r[n+2]=e.z}(n),function(){const t=new cn;for(let n=0;n<r.length;n+=3){t.x=r[n+0],t.y=r[n+1],t.z=r[n+2];const i=h(t)/2/Math.PI+.5,s=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);a.push(i,1-s)}var e;(function(){const t=new cn,e=new cn,n=new cn,i=new cn,s=new Ie,o=new Ie,l=new Ie;for(let u=0,d=0;u<r.length;u+=9,d+=6){t.set(r[u+0],r[u+1],r[u+2]),e.set(r[u+3],r[u+4],r[u+5]),n.set(r[u+6],r[u+7],r[u+8]),s.set(a[d+0],a[d+1]),o.set(a[d+2],a[d+3]),l.set(a[d+4],a[d+5]),i.copy(t).add(e).add(n).divideScalar(3);const p=h(i);c(s,d+0,t,p),c(o,d+2,e,p),c(l,d+4,n,p)}})(),function(){for(let t=0;t<a.length;t+=6){const e=a[t+0],n=a[t+2],i=a[t+4],r=Math.max(e,n,i),s=Math.min(e,n,i);r>.9&&s<.1&&(e<.2&&(a[t+0]+=1),n<.2&&(a[t+2]+=1),i<.2&&(a[t+4]+=1))}}()}(),this.setAttribute("position",new Gi(r,3)),this.setAttribute("normal",new Gi(r.slice(),3)),this.setAttribute("uv",new Gi(a,2)),0===i?this.computeVertexNormals():this.normalizeNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Tc(t.vertices,t.indices,t.radius,t.details)}}class Ec extends Tc{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,i=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ec(t.radius,t.detail)}}const Ac=new cn,Rc=new cn,Cc=new cn,Pc=new wi;class Ic extends Ji{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,i=Math.pow(10,n),r=Math.cos(xe*e),a=t.getIndex(),s=t.getAttribute("position"),o=a?a.count:s.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let t=0;t<o;t+=3){a?(l[0]=a.getX(t),l[1]=a.getX(t+1),l[2]=a.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:o}=Pc;if(e.fromBufferAttribute(s,l[0]),n.fromBufferAttribute(s,l[1]),o.fromBufferAttribute(s,l[2]),Pc.getNormal(Cc),h[0]=`${Math.round(e.x*i)},${Math.round(e.y*i)},${Math.round(e.z*i)}`,h[1]=`${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`,h[2]=`${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=h[t],i=h[e],a=Pc[c[t]],s=Pc[c[e]],o=`${n}_${i}`,p=`${i}_${n}`;p in u&&u[p]?(Cc.dot(u[p].normal)<=r&&(d.push(a.x,a.y,a.z),d.push(s.x,s.y,s.z)),u[p]=null):o in u||(u[o]={index0:l[t],index1:l[e],normal:Cc.clone()})}}for(const t in u)if(u[t]){const{index0:e,index1:n}=u[t];Ac.fromBufferAttribute(s,e),Rc.fromBufferAttribute(s,n),d.push(Ac.x,Ac.y,Ac.z),d.push(Rc.x,Rc.y,Rc.z)}this.setAttribute("position",new Gi(d,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}class Lc extends yc{constructor(t){super(t),this.uuid=we(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,i=this.holes.length;n<i;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new yc).fromJSON(n))}return this}}const Dc=function(t,e,n=2){const i=e&&e.length,r=i?e[0]*n:t.length;let a=Nc(t,0,r,n,!0);const s=[];if(!a||a.next===a.prev)return s;let o,l,c,h,u,d,p;if(i&&(a=function(t,e,n,i){const r=[];let a,s,o,l,c;for(a=0,s=e.length;a<s;a++)o=e[a]*i,l=a<s-1?e[a+1]*i:t.length,c=Nc(t,o,l,i,!1),c===c.next&&(c.steiner=!0),r.push(jc(c));for(r.sort(Hc),a=0;a<r.length;a++)n=Gc(r[a],n);return n}(t,e,a,n)),t.length>80*n){o=c=t[0],l=h=t[1];for(let e=n;e<r;e+=n)u=t[e],d=t[e+1],u<o&&(o=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-o,h-l),p=0!==p?32767/p:0}return Uc(a,s,n,o,l,p,0),s};function Nc(t,e,n,i,r){let a,s;if(r===function(t,e,n,i){let r=0;for(let a=e,s=n-i;a<n;a+=i)r+=(t[s]-t[a])*(t[a+1]+t[s+1]),s=a;return r}(t,e,n,i)>0)for(a=e;a<n;a+=i)s=eh(a,t[a],t[a+1],s);else for(a=n-i;a>=e;a-=i)s=eh(a,t[a],t[a+1],s);return s&&Zc(s,s.next)&&(nh(s),s=s.next),s}function Oc(t,e){if(!t)return t;e||(e=t);let n,i=t;do{if(n=!1,i.steiner||!Zc(i,i.next)&&0!==Yc(i.prev,i,i.next))i=i.next;else{if(nh(i),i=e=i.prev,i===i.next)break;n=!0}}while(n||i!==e);return e}function Uc(t,e,n,i,r,a,s){if(!t)return;!s&&a&&function(t,e,n,i){let r=t;do{0===r.z&&(r.z=Wc(r.x,r.y,e,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==t);r.prevZ.nextZ=null,r.prevZ=null,function(t){let e,n,i,r,a,s,o,l,c=1;do{for(n=t,t=null,a=null,s=0;n;){for(s++,i=n,o=0,e=0;e<c&&(o++,i=i.nextZ,i);e++);for(l=c;o>0||l>0&&i;)0!==o&&(0===l||!i||n.z<=i.z)?(r=n,n=n.nextZ,o--):(r=i,i=i.nextZ,l--),a?a.nextZ=r:t=r,r.prevZ=a,a=r;n=i}a.nextZ=null,c*=2}while(s>1)}(r)}(t,i,r,a);let o,l,c=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,a?Bc(t,i,r,a):Fc(t))e.push(o.i/n|0),e.push(t.i/n|0),e.push(l.i/n|0),nh(t),t=l.next,c=l.next;else if((t=l)===c){s?1===s?Uc(t=zc(Oc(t),e,n),e,n,i,r,a,2):2===s&&kc(t,e,n,i,r,a):Uc(Oc(t),e,n,i,r,a,1);break}}function Fc(t){const e=t.prev,n=t,i=t.next;if(Yc(e,n,i)>=0)return!1;const r=e.x,a=n.x,s=i.x,o=e.y,l=n.y,c=i.y,h=r<a?r<s?r:s:a<s?a:s,u=o<l?o<c?o:c:l<c?l:c,d=r>a?r>s?r:s:a>s?a:s,p=o>l?o>c?o:c:l>c?l:c;let m=i.next;for(;m!==e;){if(m.x>=h&&m.x<=d&&m.y>=u&&m.y<=p&&Xc(r,o,a,l,s,c,m.x,m.y)&&Yc(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Bc(t,e,n,i){const r=t.prev,a=t,s=t.next;if(Yc(r,a,s)>=0)return!1;const o=r.x,l=a.x,c=s.x,h=r.y,u=a.y,d=s.y,p=o<l?o<c?o:c:l<c?l:c,m=h<u?h<d?h:d:u<d?u:d,f=o>l?o>c?o:c:l>c?l:c,g=h>u?h>d?h:d:u>d?u:d,v=Wc(p,m,e,n,i),_=Wc(f,g,e,n,i);let y=t.prevZ,x=t.nextZ;for(;y&&y.z>=v&&x&&x.z<=_;){if(y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==r&&y!==s&&Xc(o,h,l,u,c,d,y.x,y.y)&&Yc(y.prev,y,y.next)>=0)return!1;if(y=y.prevZ,x.x>=p&&x.x<=f&&x.y>=m&&x.y<=g&&x!==r&&x!==s&&Xc(o,h,l,u,c,d,x.x,x.y)&&Yc(x.prev,x,x.next)>=0)return!1;x=x.nextZ}for(;y&&y.z>=v;){if(y.x>=p&&y.x<=f&&y.y>=m&&y.y<=g&&y!==r&&y!==s&&Xc(o,h,l,u,c,d,y.x,y.y)&&Yc(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;x&&x.z<=_;){if(x.x>=p&&x.x<=f&&x.y>=m&&x.y<=g&&x!==r&&x!==s&&Xc(o,h,l,u,c,d,x.x,x.y)&&Yc(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function zc(t,e,n){let i=t;do{const r=i.prev,a=i.next.next;!Zc(r,a)&&Jc(r,i,i.next,a)&&$c(r,a)&&$c(a,r)&&(e.push(r.i/n|0),e.push(i.i/n|0),e.push(a.i/n|0),nh(i),nh(i.next),i=t=a),i=i.next}while(i!==t);return Oc(i)}function kc(t,e,n,i,r,a){let s=t;do{let t=s.next.next;for(;t!==s.prev;){if(s.i!==t.i&&qc(s,t)){let o=th(s,t);return s=Oc(s,s.next),o=Oc(o,o.next),Uc(s,e,n,i,r,a,0),void Uc(o,e,n,i,r,a,0)}t=t.next}s=s.next}while(s!==t)}function Hc(t,e){return t.x-e.x}function Gc(t,e){const n=function(t,e){let n,i=e,r=-1/0;const a=t.x,s=t.y;do{if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){const t=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(t<=a&&t>r&&(r=t,n=i.x<i.next.x?i:i.next,t===a))return n}i=i.next}while(i!==e);if(!n)return null;const o=n,l=n.x,c=n.y;let h,u=1/0;i=n;do{a>=i.x&&i.x>=l&&a!==i.x&&Xc(s<c?a:r,s,l,c,s<c?r:a,s,i.x,i.y)&&(h=Math.abs(s-i.y)/(a-i.x),$c(i,t)&&(h<u||h===u&&(i.x>n.x||i.x===n.x&&Vc(n,i)))&&(n=i,u=h)),i=i.next}while(i!==o);return n}(t,e);if(!n)return e;const i=th(n,t);return Oc(i,i.next),Oc(n,n.next)}function Vc(t,e){return Yc(t.prev,t,e.prev)<0&&Yc(e.next,t,t.next)<0}function Wc(t,e,n,i,r){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*r|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-i)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function jc(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function Xc(t,e,n,i,r,a,s,o){return(r-s)*(e-o)>=(t-s)*(a-o)&&(t-s)*(i-o)>=(n-s)*(e-o)&&(n-s)*(a-o)>=(r-s)*(i-o)}function qc(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&Jc(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&($c(t,e)&&$c(e,t)&&function(t,e){let n=t,i=!1;const r=(t.x+e.x)/2,a=(t.y+e.y)/2;do{n.y>a!=n.next.y>a&&n.next.y!==n.y&&r<(n.next.x-n.x)*(a-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)&&(Yc(t.prev,t,e.prev)||Yc(t,e.prev,e))||Zc(t,e)&&Yc(t.prev,t,t.next)>0&&Yc(e.prev,e,e.next)>0)}function Yc(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function Zc(t,e){return t.x===e.x&&t.y===e.y}function Jc(t,e,n,i){const r=Qc(Yc(t,e,n)),a=Qc(Yc(t,e,i)),s=Qc(Yc(n,i,t)),o=Qc(Yc(n,i,e));return r!==a&&s!==o||(!(0!==r||!Kc(t,n,e))||(!(0!==a||!Kc(t,i,e))||(!(0!==s||!Kc(n,t,i))||!(0!==o||!Kc(n,e,i)))))}function Kc(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function Qc(t){return t>0?1:t<0?-1:0}function $c(t,e){return Yc(t.prev,t,t.next)<0?Yc(t,e,t.next)>=0&&Yc(t,t.prev,e)>=0:Yc(t,e,t.prev)<0||Yc(t,t.next,e)<0}function th(t,e){const n=new ih(t.i,t.x,t.y),i=new ih(e.i,e.x,e.y),r=t.next,a=e.prev;return t.next=e,e.prev=t,n.next=r,r.prev=n,i.next=n,n.prev=i,a.next=i,i.prev=a,i}function eh(t,e,n,i){const r=new ih(t,e,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function nh(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function ih(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class rh{static area(t){const e=t.length;let n=0;for(let i=e-1,r=0;r<e;i=r++)n+=t[i].x*t[r].y-t[r].x*t[i].y;return.5*n}static isClockWise(t){return rh.area(t)<0}static triangulateShape(t,e){const n=[],i=[],r=[];ah(t),sh(n,t);let a=t.length;e.forEach(ah);for(let t=0;t<e.length;t++)i.push(a),a+=e[t].length,sh(n,e[t]);const s=Dc(n,i);for(let t=0;t<s.length;t+=3)r.push(s.slice(t,t+3));return r}}function ah(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function sh(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class oh extends Ji{constructor(t=new Lc([new Ie(.5,.5),new Ie(-.5,.5),new Ie(-.5,-.5),new Ie(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,i=[],r=[];for(let e=0,n=t.length;e<n;e++){a(t[e])}function a(t){const a=[],s=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1,l=void 0!==e.depth?e.depth:1;let c=void 0===e.bevelEnabled||e.bevelEnabled,h=void 0!==e.bevelThickness?e.bevelThickness:.2,u=void 0!==e.bevelSize?e.bevelSize:h-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const m=e.extrudePath,f=void 0!==e.UVGenerator?e.UVGenerator:lh;let g,v,_,y,x,b=!1;m&&(g=m.getSpacedPoints(o),b=!0,c=!1,v=m.computeFrenetFrames(o,!1),_=new cn,y=new cn,x=new cn),c||(p=0,h=0,u=0,d=0);const w=t.extractPoints(s);let M=w.shape;const S=w.holes;if(!rh.isClockWise(M)){M=M.reverse();for(let t=0,e=S.length;t<e;t++){const e=S[t];rh.isClockWise(e)&&(S[t]=e.reverse())}}const T=rh.triangulateShape(M,S),E=M;for(let t=0,e=S.length;t<e;t++){const e=S[t];M=M.concat(e)}function A(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().addScaledVector(e,n)}const R=M.length,C=T.length;function P(t,e,n){let i,r,a;const s=t.x-e.x,o=t.y-e.y,l=n.x-t.x,c=n.y-t.y,h=s*s+o*o,u=s*c-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=e.x-o/u,m=e.y+s/u,f=((n.x-c/d-p)*c-(n.y+l/d-m)*l)/(s*c-o*l);i=p+s*f-t.x,r=m+o*f-t.y;const g=i*i+r*r;if(g<=2)return new Ie(i,r);a=Math.sqrt(g/2)}else{let t=!1;s>Number.EPSILON?l>Number.EPSILON&&(t=!0):s<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(c)&&(t=!0),t?(i=-o,r=s,a=Math.sqrt(h)):(i=s,r=o,a=Math.sqrt(h/2))}return new Ie(i/a,r/a)}const I=[];for(let t=0,e=E.length,n=e-1,i=t+1;t<e;t++,n++,i++)n===e&&(n=0),i===e&&(i=0),I[t]=P(E[t],E[n],E[i]);const L=[];let D,N=I.concat();for(let t=0,e=S.length;t<e;t++){const e=S[t];D=[];for(let t=0,n=e.length,i=n-1,r=t+1;t<n;t++,i++,r++)i===n&&(i=0),r===n&&(r=0),D[t]=P(e[t],e[i],e[r]);L.push(D),N=N.concat(D)}for(let t=0;t<p;t++){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=A(E[t],I[t],i);F(e.x,e.y,-n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];D=L[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],D[t],i);F(r.x,r.y,-n)}}}const O=u+d;for(let t=0;t<R;t++){const e=c?A(M[t],N[t],O):M[t];b?(y.copy(v.normals[0]).multiplyScalar(e.x),_.copy(v.binormals[0]).multiplyScalar(e.y),x.copy(g[0]).add(y).add(_),F(x.x,x.y,x.z)):F(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<R;e++){const n=c?A(M[e],N[e],O):M[e];b?(y.copy(v.normals[t]).multiplyScalar(n.x),_.copy(v.binormals[t]).multiplyScalar(n.y),x.copy(g[t]).add(y).add(_),F(x.x,x.y,x.z)):F(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=h*Math.cos(e*Math.PI/2),i=u*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=A(E[t],I[t],i);F(e.x,e.y,l+n)}for(let t=0,e=S.length;t<e;t++){const e=S[t];D=L[t];for(let t=0,r=e.length;t<r;t++){const r=A(e[t],D[t],i);b?F(r.x,r.y+g[o-1].y,g[o-1].x+n):F(r.x,r.y,l+n)}}}function U(t,e){let n=t.length;for(;--n>=0;){const i=n;let r=n-1;r<0&&(r=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=R*t,a=R*(t+1);z(e+i+n,e+r+n,e+r+a,e+i+a)}}}function F(t,e,n){a.push(t),a.push(e),a.push(n)}function B(t,e,r){k(t),k(e),k(r);const a=i.length/3,s=f.generateTopUV(n,i,a-3,a-2,a-1);H(s[0]),H(s[1]),H(s[2])}function z(t,e,r,a){k(t),k(e),k(a),k(e),k(r),k(a);const s=i.length/3,o=f.generateSideWallUV(n,i,s-6,s-3,s-2,s-1);H(o[0]),H(o[1]),H(o[3]),H(o[1]),H(o[2]),H(o[3])}function k(t){i.push(a[3*t+0]),i.push(a[3*t+1]),i.push(a[3*t+2])}function H(t){r.push(t.x),r.push(t.y)}!function(){const t=i.length/3;if(c){let t=0,e=R*t;for(let t=0;t<C;t++){const n=T[t];B(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=R*t;for(let t=0;t<C;t++){const n=T[t];B(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<C;t++){const e=T[t];B(e[2],e[1],e[0])}for(let t=0;t<C;t++){const e=T[t];B(e[0]+R*o,e[1]+R*o,e[2]+R*o)}}n.addGroup(t,i.length/3-t,0)}(),function(){const t=i.length/3;let e=0;U(E,e),e+=E.length;for(let t=0,n=S.length;t<n;t++){const n=S[t];U(n,e),e+=n.length}n.addGroup(t,i.length/3-t,1)}()}this.setAttribute("position",new Gi(i,3)),this.setAttribute("uv",new Gi(r,2)),this.computeVertexNormals()}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,i=t.length;e<i;e++){const i=t[e];n.shapes.push(i.uuid)}else n.shapes.push(t.uuid);n.options=Object.assign({},e),void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON());return n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}const i=t.options.extrudePath;return void 0!==i&&(t.options.extrudePath=(new vc[i.type]).fromJSON(i)),new oh(n,t.options)}}const lh={generateTopUV:function(t,e,n,i,r){const a=e[3*n],s=e[3*n+1],o=e[3*i],l=e[3*i+1],c=e[3*r],h=e[3*r+1];return[new Ie(a,s),new Ie(o,l),new Ie(c,h)]},generateSideWallUV:function(t,e,n,i,r,a){const s=e[3*n],o=e[3*n+1],l=e[3*n+2],c=e[3*i],h=e[3*i+1],u=e[3*i+2],d=e[3*r],p=e[3*r+1],m=e[3*r+2],f=e[3*a],g=e[3*a+1],v=e[3*a+2];return Math.abs(o-h)<Math.abs(s-c)?[new Ie(s,1-l),new Ie(c,1-u),new Ie(d,1-m),new Ie(f,1-v)]:[new Ie(o,1-l),new Ie(h,1-u),new Ie(p,1-m),new Ie(g,1-v)]}};class ch extends Tc{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new ch(t.radius,t.detail)}}class hh extends Tc{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new hh(t.radius,t.detail)}}class uh extends Ji{constructor(t=.5,e=1,n=32,i=1,r=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:i,thetaStart:r,thetaLength:a},n=Math.max(3,n);const s=[],o=[],l=[],c=[];let h=t;const u=(e-t)/(i=Math.max(1,i)),d=new cn,p=new Ie;for(let t=0;t<=i;t++){for(let t=0;t<=n;t++){const i=r+t/n*a;d.x=h*Math.cos(i),d.y=h*Math.sin(i),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,c.push(p.x,p.y)}h+=u}for(let t=0;t<i;t++){const e=t*(n+1);for(let t=0;t<n;t++){const i=t+e,r=i,a=i+n+1,o=i+n+2,l=i+1;s.push(r,a,l),s.push(a,o,l)}}this.setIndex(s),this.setAttribute("position",new Gi(o,3)),this.setAttribute("normal",new Gi(l,3)),this.setAttribute("uv",new Gi(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new uh(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class dh extends Ji{constructor(t=new Lc([new Ie(0,.5),new Ie(-.5,-.5),new Ie(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],i=[],r=[],a=[];let s=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(s,o,e),s+=o,o=0;function l(t){const s=i.length/3,l=t.extractPoints(e);let c=l.shape;const h=l.holes;!1===rh.isClockWise(c)&&(c=c.reverse());for(let t=0,e=h.length;t<e;t++){const e=h[t];!0===rh.isClockWise(e)&&(h[t]=e.reverse())}const u=rh.triangulateShape(c,h);for(let t=0,e=h.length;t<e;t++){const e=h[t];c=c.concat(e)}for(let t=0,e=c.length;t<e;t++){const e=c[t];i.push(e.x,e.y,0),r.push(0,0,1),a.push(e.x,e.y)}for(let t=0,e=u.length;t<e;t++){const e=u[t],i=e[0]+s,r=e[1]+s,a=e[2]+s;n.push(i,r,a),o+=3}}this.setIndex(n),this.setAttribute("position",new Gi(i,3)),this.setAttribute("normal",new Gi(r,3)),this.setAttribute("uv",new Gi(a,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,i=t.length;n<i;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let i=0,r=t.shapes.length;i<r;i++){const r=e[t.shapes[i]];n.push(r)}return new dh(n,t.curveSegments)}}class ph extends Ji{constructor(t=1,e=32,n=16,i=0,r=2*Math.PI,a=0,s=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:r,thetaStart:a,thetaLength:s},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(a+s,Math.PI);let l=0;const c=[],h=new cn,u=new cn,d=[],p=[],m=[],f=[];for(let d=0;d<=n;d++){const g=[],v=d/n;let _=0;0===d&&0===a?_=.5/e:d===n&&o===Math.PI&&(_=-.5/e);for(let n=0;n<=e;n++){const o=n/e;h.x=-t*Math.cos(i+o*r)*Math.sin(a+v*s),h.y=t*Math.cos(a+v*s),h.z=t*Math.sin(i+o*r)*Math.sin(a+v*s),p.push(h.x,h.y,h.z),u.copy(h).normalize(),m.push(u.x,u.y,u.z),f.push(o+_,1-v),g.push(l++)}c.push(g)}for(let t=0;t<n;t++)for(let i=0;i<e;i++){const e=c[t][i+1],r=c[t][i],s=c[t+1][i],l=c[t+1][i+1];(0!==t||a>0)&&d.push(e,r,l),(t!==n-1||o<Math.PI)&&d.push(r,s,l)}this.setIndex(d),this.setAttribute("position",new Gi(p,3)),this.setAttribute("normal",new Gi(m,3)),this.setAttribute("uv",new Gi(f,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new ph(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class mh extends Tc{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new mh(t.radius,t.detail)}}class fh extends Ji{constructor(t=1,e=.4,n=12,i=48,r=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:r},n=Math.floor(n),i=Math.floor(i);const a=[],s=[],o=[],l=[],c=new cn,h=new cn,u=new cn;for(let a=0;a<=n;a++)for(let d=0;d<=i;d++){const p=d/i*r,m=a/n*Math.PI*2;h.x=(t+e*Math.cos(m))*Math.cos(p),h.y=(t+e*Math.cos(m))*Math.sin(p),h.z=e*Math.sin(m),s.push(h.x,h.y,h.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),u.subVectors(h,c).normalize(),o.push(u.x,u.y,u.z),l.push(d/i),l.push(a/n)}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*t+e-1,r=(i+1)*(t-1)+e-1,s=(i+1)*(t-1)+e,o=(i+1)*t+e;a.push(n,r,o),a.push(r,s,o)}this.setIndex(a),this.setAttribute("position",new Gi(s,3)),this.setAttribute("normal",new Gi(o,3)),this.setAttribute("uv",new Gi(l,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new fh(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class gh extends Ji{constructor(t=1,e=.4,n=64,i=8,r=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:i,p:r,q:a},n=Math.floor(n),i=Math.floor(i);const s=[],o=[],l=[],c=[],h=new cn,u=new cn,d=new cn,p=new cn,m=new cn,f=new cn,g=new cn;for(let s=0;s<=n;++s){const _=s/n*r*Math.PI*2;v(_,r,a,t,d),v(_+.01,r,a,t,p),f.subVectors(p,d),g.addVectors(p,d),m.crossVectors(f,g),g.crossVectors(m,f),m.normalize(),g.normalize();for(let t=0;t<=i;++t){const r=t/i*Math.PI*2,a=-e*Math.cos(r),p=e*Math.sin(r);h.x=d.x+(a*g.x+p*m.x),h.y=d.y+(a*g.y+p*m.y),h.z=d.z+(a*g.z+p*m.z),o.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(s/n),c.push(t/i)}}for(let t=1;t<=n;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),a=(i+1)*t+e,o=(i+1)*(t-1)+e;s.push(n,r,o),s.push(r,a,o)}function v(t,e,n,i,r){const a=Math.cos(t),s=Math.sin(t),o=n/e*t,l=Math.cos(o);r.x=i*(2+l)*.5*a,r.y=i*(2+l)*s*.5,r.z=i*Math.sin(o)*.5}this.setIndex(s),this.setAttribute("position",new Gi(o,3)),this.setAttribute("normal",new Gi(l,3)),this.setAttribute("uv",new Gi(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new gh(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class vh extends Ji{constructor(t=new fc(new cn(-1,-1,0),new cn(-1,1,0),new cn(1,1,0)),e=64,n=1,i=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:i,closed:r};const a=t.computeFrenetFrames(e,r);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const s=new cn,o=new cn,l=new Ie;let c=new cn;const h=[],u=[],d=[],p=[];function m(r){c=t.getPointAt(r/e,c);const l=a.normals[r],d=a.binormals[r];for(let t=0;t<=i;t++){const e=t/i*Math.PI*2,r=Math.sin(e),a=-Math.cos(e);o.x=a*l.x+r*d.x,o.y=a*l.y+r*d.y,o.z=a*l.z+r*d.z,o.normalize(),u.push(o.x,o.y,o.z),s.x=c.x+n*o.x,s.y=c.y+n*o.y,s.z=c.z+n*o.z,h.push(s.x,s.y,s.z)}}!function(){for(let t=0;t<e;t++)m(t);m(!1===r?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=i;n++)l.x=t/e,l.y=n/i,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=i;e++){const n=(i+1)*(t-1)+(e-1),r=(i+1)*t+(e-1),a=(i+1)*t+e,s=(i+1)*(t-1)+e;p.push(n,r,s),p.push(r,a,s)}}()}(),this.setIndex(p),this.setAttribute("position",new Gi(h,3)),this.setAttribute("normal",new Gi(u,3)),this.setAttribute("uv",new Gi(d,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new vh((new vc[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class _h extends Ji{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,i=new cn,r=new cn;if(null!==t.index){const a=t.attributes.position,s=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:s.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],c=l.start;for(let t=c,o=c+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=s.getX(t+o),c=s.getX(t+(o+1)%3);i.fromBufferAttribute(a,l),r.fromBufferAttribute(a,c),!0===yh(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}}else{const a=t.attributes.position;for(let t=0,s=a.count/3;t<s;t++)for(let s=0;s<3;s++){const o=3*t+s,l=3*t+(s+1)%3;i.fromBufferAttribute(a,o),r.fromBufferAttribute(a,l),!0===yh(i,r,n)&&(e.push(i.x,i.y,i.z),e.push(r.x,r.y,r.z))}}this.setAttribute("position",new Gi(e,3))}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}}function yh(t,e,n){const i=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(i)&&!0!==n.has(r)&&(n.add(i),n.add(r),!0)}var xh=Object.freeze({__proto__:null,BoxGeometry:gr,CapsuleGeometry:bc,CircleGeometry:wc,ConeGeometry:Sc,CylinderGeometry:Mc,DodecahedronGeometry:Ec,EdgesGeometry:Ic,ExtrudeGeometry:oh,IcosahedronGeometry:ch,LatheGeometry:xc,OctahedronGeometry:hh,PlaneGeometry:Fr,PolyhedronGeometry:Tc,RingGeometry:uh,ShapeGeometry:dh,SphereGeometry:ph,TetrahedronGeometry:mh,TorusGeometry:fh,TorusKnotGeometry:gh,TubeGeometry:vh,WireframeGeometry:_h});class bh extends Pi{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Ai(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class wh extends br{constructor(t){super(t),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Mh extends Pi{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ai(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ai(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Sh extends Mh{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ie(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Me(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Ai(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Ai(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Ai(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class Th extends Pi{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Ai(16777215),this.specular=new Ai(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ai(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=M,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Eh extends Pi{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ai(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ai(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class Ah extends Pi{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class Rh extends Pi{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Ai(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ai(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=M,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Ch extends Pi{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ai(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Ie(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Ph extends Dl{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function Ih(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)}function Lh(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Dh(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n}function Nh(t,e,n){const i=t.length,r=new t.constructor(i);for(let a=0,s=0;s!==i;++a){const i=n[a]*e;for(let n=0;n!==e;++n)r[s++]=t[i+n]}return r}function Oh(t,e,n,i){let r=1,a=t[0];for(;void 0!==a&&void 0===a[i];)a=t[r++];if(void 0===a)return;let s=a[i];if(void 0!==s)if(Array.isArray(s))do{s=a[i],void 0!==s&&(e.push(a.time),n.push.apply(n,s)),a=t[r++]}while(void 0!==a);else if(void 0!==s.toArray)do{s=a[i],void 0!==s&&(e.push(a.time),s.toArray(n,n.length)),a=t[r++]}while(void 0!==a);else do{s=a[i],void 0!==s&&(e.push(a.time),n.push(s)),a=t[r++]}while(void 0!==a)}const Uh={convertArray:Ih,isTypedArray:Lh,getKeyframeOrder:Dh,sortedArray:Nh,flattenJSON:Oh,subclip:function(t,e,n,i,r=30){const a=t.clone();a.name=e;const s=[];for(let t=0;t<a.tracks.length;++t){const e=a.tracks[t],o=e.getValueSize(),l=[],c=[];for(let t=0;t<e.times.length;++t){const a=e.times[t]*r;if(!(a<n||a>=i)){l.push(e.times[t]);for(let n=0;n<o;++n)c.push(e.values[t*o+n])}}0!==l.length&&(e.times=Ih(l,e.times.constructor),e.values=Ih(c,e.values.constructor),s.push(e))}a.tracks=s;let o=1/0;for(let t=0;t<a.tracks.length;++t)o>a.tracks[t].times[0]&&(o=a.tracks[t].times[0]);for(let t=0;t<a.tracks.length;++t)a.tracks[t].shift(-1*o);return a.resetDuration(),a},makeClipAdditive:function(t,e=0,n=t,i=30){i<=0&&(i=30);const r=n.tracks.length,a=e/i;for(let e=0;e<r;++e){const i=n.tracks[e],r=i.ValueTypeName;if("bool"===r||"string"===r)continue;const s=t.tracks.find((function(t){return t.name===i.name&&t.ValueTypeName===r}));if(void 0===s)continue;let o=0;const l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const h=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=i.times.length-1;let d;if(a<=i.times[0]){const t=o,e=l-o;d=i.values.slice(t,e)}else if(a>=i.times[u]){const t=u*l+o,e=t+l-o;d=i.values.slice(t,e)}else{const t=i.createInterpolant(),e=o,n=l-o;t.evaluate(a),d=t.resultBuffer.slice(e,n)}if("quaternion"===r){(new ln).fromArray(d).normalize().conjugate().toArray(d)}const p=s.times.length;for(let t=0;t<p;++t){const e=t*h+c;if("quaternion"===r)ln.multiplyQuaternionsFlat(s.values,e,d,0,s.values,e);else{const t=h-2*c;for(let n=0;n<t;++n)s.values[e+n]-=d[n]}}}return t.blendMode=$t,t}};class Fh{constructor(t,e,n,i){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==i?i:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,i=e[n],r=e[n-1];t:{e:{let a;n:{i:if(!(t<i)){for(let a=n+2;;){if(void 0===i){if(t<r)break i;return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===a)break;if(r=i,i=e[++n],t<i)break e}a=e.length;break n}if(t>=r)break t;{const s=e[1];t<s&&(n=2,r=s);for(let a=n-2;;){if(void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(n===a)break;if(i=r,r=e[--n-1],t>=r)break e}a=n,n=0}}for(;n<a;){const i=n+a>>>1;t<e[i]?a=i:n=i+1}if(i=e[n],r=e[n-1],void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===i)return n=e.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,t,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=t*i;for(let t=0;t!==i;++t)e[t]=n[r+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Bh extends Fh{constructor(t,e,n,i){super(t,e,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Zt,endingEnd:Zt}}intervalChanged_(t,e,n){const i=this.parameterPositions;let r=t-2,a=t+1,s=i[r],o=i[a];if(void 0===s)switch(this.getSettings_().endingStart){case Jt:r=t,s=2*e-n;break;case Kt:r=i.length-2,s=e+i[r]-i[r+1];break;default:r=t,s=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Jt:a=t,o=2*n-e;break;case Kt:a=1,o=n+i[1]-i[0];break;default:a=t-1,o=e}const l=.5*(n-e),c=this.valueSize;this._weightPrev=l/(e-s),this._weightNext=l/(o-n),this._offsetPrev=r*c,this._offsetNext=a*c}interpolate_(t,e,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=t*s,l=o-s,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-e)/(i-e),m=p*p,f=m*p,g=-u*f+2*u*m-u*p,v=(1+u)*f+(-1.5-2*u)*m+(-.5+u)*p+1,_=(-1-d)*f+(1.5+d)*m+.5*p,y=d*f-d*m;for(let t=0;t!==s;++t)r[t]=g*a[c+t]+v*a[l+t]+_*a[o+t]+y*a[h+t];return r}}class zh extends Fh{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=t*s,l=o-s,c=(n-e)/(i-e),h=1-c;for(let t=0;t!==s;++t)r[t]=a[l+t]*h+a[o+t]*c;return r}}class kh extends Fh{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t){return this.copySampleValue_(t-1)}}class Hh{constructor(t,e,n,i){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ih(e,this.TimeBufferType),this.values=Ih(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Ih(t.times,Array),values:Ih(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new kh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new zh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Bh(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Xt:e=this.InterpolantFactoryMethodDiscrete;break;case qt:e=this.InterpolantFactoryMethodLinear;break;case Yt:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Xt;case this.InterpolantFactoryMethodLinear:return qt;case this.InterpolantFactoryMethodSmooth:return Yt}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,i=e.length;n!==i;++n)e[n]*=t}return this}trim(t,e){const n=this.times,i=n.length;let r=0,a=i-1;for(;r!==i&&n[r]<t;)++r;for(;-1!==a&&n[a]>e;)--a;if(++a,0!==r||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const t=this.getValueSize();this.times=n.slice(r,a),this.values=this.values.slice(r*t,a*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,i=this.values,r=n.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let a=null;for(let e=0;e!==r;e++){const i=n[e];if("number"==typeof i&&isNaN(i)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,i),t=!1;break}if(null!==a&&a>i){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,i,a),t=!1;break}a=i}if(void 0!==i&&Lh(i))for(let e=0,n=i.length;e!==n;++e){const n=i[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===Yt,r=t.length-1;let a=1;for(let s=1;s<r;++s){let r=!1;const o=t[s];if(o!==t[s+1]&&(1!==s||o!==t[0]))if(i)r=!0;else{const t=s*n,i=t-n,a=t+n;for(let s=0;s!==n;++s){const n=e[t+s];if(n!==e[i+s]||n!==e[a+s]){r=!0;break}}}if(r){if(s!==a){t[a]=t[s];const i=s*n,r=a*n;for(let t=0;t!==n;++t)e[r+t]=e[i+t]}++a}}if(r>0){t[a]=t[r];for(let t=r*n,i=a*n,s=0;s!==n;++s)e[i+s]=e[t+s];++a}return a!==t.length?(this.times=t.slice(0,a),this.values=e.slice(0,a*n)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}Hh.prototype.TimeBufferType=Float32Array,Hh.prototype.ValueBufferType=Float32Array,Hh.prototype.DefaultInterpolation=qt;class Gh extends Hh{}Gh.prototype.ValueTypeName="bool",Gh.prototype.ValueBufferType=Array,Gh.prototype.DefaultInterpolation=Xt,Gh.prototype.InterpolantFactoryMethodLinear=void 0,Gh.prototype.InterpolantFactoryMethodSmooth=void 0;class Vh extends Hh{}Vh.prototype.ValueTypeName="color";class Wh extends Hh{}Wh.prototype.ValueTypeName="number";class jh extends Fh{constructor(t,e,n,i){super(t,e,n,i)}interpolate_(t,e,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,o=(n-e)/(i-e);let l=t*s;for(let t=l+s;l!==t;l+=4)ln.slerpFlat(r,0,a,l-s,a,l,o);return r}}class Xh extends Hh{InterpolantFactoryMethodLinear(t){return new jh(this.times,this.values,this.getValueSize(),t)}}Xh.prototype.ValueTypeName="quaternion",Xh.prototype.DefaultInterpolation=qt,Xh.prototype.InterpolantFactoryMethodSmooth=void 0;class qh extends Hh{}qh.prototype.ValueTypeName="string",qh.prototype.ValueBufferType=Array,qh.prototype.DefaultInterpolation=Xt,qh.prototype.InterpolantFactoryMethodLinear=void 0,qh.prototype.InterpolantFactoryMethodSmooth=void 0;class Yh extends Hh{}Yh.prototype.ValueTypeName="vector";class Zh{constructor(t,e=-1,n,i=2500){this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=we(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,i=1/(t.fps||1);for(let t=0,r=n.length;t!==r;++t)e.push(Jh(n[t]).scale(i));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],n=t.tracks,i={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,i=n.length;t!==i;++t)e.push(Hh.toJSON(n[t]));return i}static CreateFromMorphTargetSequence(t,e,n,i){const r=e.length,a=[];for(let t=0;t<r;t++){let s=[],o=[];s.push((t+r-1)%r,t,(t+1)%r),o.push(0,1,0);const l=Dh(s);s=Nh(s,1,l),o=Nh(o,1,l),i||0!==s[0]||(s.push(r),o.push(o[0])),a.push(new Wh(".morphTargetInfluences["+e[t].name+"]",s,o).scale(1/n))}return new this(t,-1,a)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],a=n.name.match(r);if(a&&a.length>1){const t=a[1];let e=i[t];e||(i[t]=e=[]),e.push(n)}}const a=[];for(const t in i)a.push(this.CreateFromMorphTargetSequence(t,i[t],e,n));return a}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,i,r){if(0!==n.length){const a=[],s=[];Oh(n,a,s,i),0!==a.length&&r.push(new t(e,a,s))}},i=[],r=t.name||"default",a=t.fps||30,s=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const r=l[t].keys;if(r&&0!==r.length)if(r[0].morphTargets){const t={};let e;for(e=0;e<r.length;e++)if(r[e].morphTargets)for(let n=0;n<r[e].morphTargets.length;n++)t[r[e].morphTargets[n]]=-1;for(const n in t){const t=[],a=[];for(let i=0;i!==r[e].morphTargets.length;++i){const i=r[e];t.push(i.time),a.push(i.morphTarget===n?1:0)}i.push(new Wh(".morphTargetInfluence["+n+"]",t,a))}o=t.length*a}else{const a=".bones["+e[t].name+"]";n(Yh,a+".position",r,"pos",i),n(Xh,a+".quaternion",r,"rot",i),n(Yh,a+".scale",r,"scl",i)}}if(0===i.length)return null;return new this(r,o,i,s)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Jh(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Wh;case"vector":case"vector2":case"vector3":case"vector4":return Yh;case"color":return Vh;case"quaternion":return Xh;case"bool":case"boolean":return Gh;case"string":return qh}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Oh(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const Kh={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class Qh{constructor(t,e,n){const i=this;let r,a=!1,s=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===a&&void 0!==i.onStart&&i.onStart(t,s,o),a=!0},this.itemEnd=function(t){s++,void 0!==i.onProgress&&i.onProgress(t,s,o),s===o&&(a=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],i=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return i}return null}}}const $h=new Qh;class tu{constructor(t){this.manager=void 0!==t?t:$h,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}tu.DEFAULT_MATERIAL_NAME="__DEFAULT";const eu={};class nu extends Error{constructor(t,e){super(t),this.response=e}}class iu extends tu{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=Kh.get(t);if(void 0!==r)return this.manager.itemStart(t),setTimeout((()=>{e&&e(r),this.manager.itemEnd(t)}),0),r;if(void 0!==eu[t])return void eu[t].push({onLoad:e,onProgress:n,onError:i});eu[t]=[],eu[t].push({onLoad:e,onProgress:n,onError:i});const a=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,o=this.responseType;fetch(a).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=eu[t],i=e.body.getReader(),r=e.headers.get("Content-Length")||e.headers.get("X-File-Size"),a=r?parseInt(r):0,s=0!==a;let o=0;const l=new ReadableStream({start(t){!function e(){i.read().then((({done:i,value:r})=>{if(i)t.close();else{o+=r.byteLength;const i=new ProgressEvent("progress",{lengthComputable:s,loaded:o,total:a});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(i)}t.enqueue(r),e()}}))}()}});return new Response(l)}throw new nu(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`,e)})).then((t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,s)));case"json":return t.json();default:if(void 0===s)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(s),n=e&&e[1]?e[1].toLowerCase():void 0,i=new TextDecoder(n);return t.arrayBuffer().then((t=>i.decode(t)))}}})).then((e=>{Kh.add(t,e);const n=eu[t];delete eu[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onLoad&&i.onLoad(e)}})).catch((e=>{const n=eu[t];if(void 0===n)throw this.manager.itemError(t),e;delete eu[t];for(let t=0,i=n.length;t<i;t++){const i=n[t];i.onError&&i.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class ru extends tu{constructor(t){super(t)}load(t,e,n,i){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=Kh.get(t);if(void 0!==a)return r.manager.itemStart(t),setTimeout((function(){e&&e(a),r.manager.itemEnd(t)}),0),a;const s=Fe("img");function o(){c(),Kh.add(t,this),e&&e(this),r.manager.itemEnd(t)}function l(e){c(),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}function c(){s.removeEventListener("load",o,!1),s.removeEventListener("error",l,!1)}return s.addEventListener("load",o,!1),s.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),r.manager.itemStart(t),s.src=t,s}}class au extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=new il,s=new iu(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(r.withCredentials),s.load(t,(function(t){let n;try{n=r.parse(t)}catch(t){if(void 0===i)return void console.error(t);i(t)}void 0!==n.image?a.image=n.image:void 0!==n.data&&(a.image.width=n.width,a.image.height=n.height,a.image.data=n.data),a.wrapS=void 0!==n.wrapS?n.wrapS:G,a.wrapT=void 0!==n.wrapT?n.wrapT:G,a.magFilter=void 0!==n.magFilter?n.magFilter:q,a.minFilter=void 0!==n.minFilter?n.minFilter:q,a.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.colorSpace?a.colorSpace=n.colorSpace:void 0!==n.encoding&&(a.encoding=n.encoding),void 0!==n.flipY&&(a.flipY=n.flipY),void 0!==n.format&&(a.format=n.format),void 0!==n.type&&(a.type=n.type),void 0!==n.mipmaps&&(a.mipmaps=n.mipmaps,a.minFilter=Z),1===n.mipmapCount&&(a.minFilter=q),void 0!==n.generateMipmaps&&(a.generateMipmaps=n.generateMipmaps),a.needsUpdate=!0,e&&e(a,n)}),n,i),a}}class su extends hi{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new Ai(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}class ou extends su{constructor(t,e,n){super(t,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Ai(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const lu=new zn,cu=new cn,hu=new cn;class uu{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ie(512,512),this.map=null,this.mapPass=null,this.matrix=new zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Nr,this._frameExtents=new Ie(1,1),this._viewportCount=1,this._viewports=[new en(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;cu.setFromMatrixPosition(t.matrixWorld),e.position.copy(cu),hu.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(hu),e.updateMatrixWorld(),lu.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(lu),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(lu)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class du extends uu{constructor(){super(new Mr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,n=2*be*t.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;n===e.fov&&i===e.aspect&&r===e.far||(e.fov=n,e.aspect=i,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class pu extends su{constructor(t,e,n=0,i=Math.PI/3,r=0,a=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.target=new hi,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.map=null,this.shadow=new du}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const mu=new zn,fu=new cn,gu=new cn;class vu extends uu{constructor(){super(new Mr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ie(4,2),this._viewportCount=6,this._viewports=[new en(2,1,1,1),new en(0,1,1,1),new en(3,1,1,1),new en(1,1,1,1),new en(3,0,1,1),new en(1,0,1,1)],this._cubeDirections=[new cn(1,0,0),new cn(-1,0,0),new cn(0,0,1),new cn(0,0,-1),new cn(0,1,0),new cn(0,-1,0)],this._cubeUps=[new cn(0,1,0),new cn(0,1,0),new cn(0,1,0),new cn(0,1,0),new cn(0,0,1),new cn(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,r=t.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),fu.setFromMatrixPosition(t.matrixWorld),n.position.copy(fu),gu.copy(n.position),gu.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(gu),n.updateMatrixWorld(),i.makeTranslation(-fu.x,-fu.y,-fu.z),mu.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(mu)}}class _u extends su{constructor(t,e,n=0,i=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new vu}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class yu extends uu{constructor(){super(new Yr(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class xu extends su{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.target=new hi,this.shadow=new yu}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class bu extends su{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class wu extends su{constructor(t,e,n=10,i=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class Mu{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new cn)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*i),e.addScaledVector(a[2],.488603*r),e.addScaledVector(a[3],.488603*n),e.addScaledVector(a[4],n*i*1.092548),e.addScaledVector(a[5],i*r*1.092548),e.addScaledVector(a[6],.315392*(3*r*r-1)),e.addScaledVector(a[7],n*r*1.092548),e.addScaledVector(a[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*i),e.addScaledVector(a[2],1.023328*r),e.addScaledVector(a[3],1.023328*n),e.addScaledVector(a[4],.858086*n*i),e.addScaledVector(a[5],.858086*i*r),e.addScaledVector(a[6],.743125*r*r-.247708),e.addScaledVector(a[7],.858086*n*r),e.addScaledVector(a[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}class Su extends su{constructor(t=new Mu,e=1){super(void 0,e),this.isLightProbe=!0,this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}class Tu extends tu{constructor(t){super(t),this.textures={}}load(t,e,n,i){const r=this,a=new iu(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const i=Tu.createMaterialFromType(t.type);if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=t.sheen),void 0!==t.sheenColor&&(i.sheenColor=(new Ai).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(i.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.specularIntensity&&(i.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==i.specularColor&&i.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.iridescence&&(i.iridescence=t.iridescence),void 0!==t.iridescenceIOR&&(i.iridescenceIOR=t.iridescenceIOR),void 0!==t.iridescenceThicknessRange&&(i.iridescenceThicknessRange=t.iridescenceThicknessRange),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.thickness&&(i.thickness=t.thickness),void 0!==t.attenuationDistance&&(i.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==i.attenuationColor&&i.attenuationColor.setHex(t.attenuationColor),void 0!==t.anisotropy&&(i.anisotropy=t.anisotropy),void 0!==t.anisotropyRotation&&(i.anisotropyRotation=t.anisotropyRotation),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.shadowSide&&(i.shadowSide=t.shadowSide),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.alphaHash&&(i.alphaHash=t.alphaHash),void 0!==t.depthFunc&&(i.depthFunc=t.depthFunc),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.blendSrc&&(i.blendSrc=t.blendSrc),void 0!==t.blendDst&&(i.blendDst=t.blendDst),void 0!==t.blendEquation&&(i.blendEquation=t.blendEquation),void 0!==t.blendSrcAlpha&&(i.blendSrcAlpha=t.blendSrcAlpha),void 0!==t.blendDstAlpha&&(i.blendDstAlpha=t.blendDstAlpha),void 0!==t.blendEquationAlpha&&(i.blendEquationAlpha=t.blendEquationAlpha),void 0!==t.blendColor&&void 0!==i.blendColor&&i.blendColor.setHex(t.blendColor),void 0!==t.blendAlpha&&(i.blendAlpha=t.blendAlpha),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),void 0!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.alphaToCoverage&&(i.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(i.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.forceSinglePass&&(i.forceSinglePass=t.forceSinglePass),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const r=t.uniforms[e];switch(i.uniforms[e]={},r.type){case"t":i.uniforms[e].value=n(r.value);break;case"c":i.uniforms[e].value=(new Ai).setHex(r.value);break;case"v2":i.uniforms[e].value=(new Ie).fromArray(r.value);break;case"v3":i.uniforms[e].value=(new cn).fromArray(r.value);break;case"v4":i.uniforms[e].value=(new en).fromArray(r.value);break;case"m3":i.uniforms[e].value=(new Le).fromArray(r.value);break;case"m4":i.uniforms[e].value=(new zn).fromArray(r.value);break;default:i.uniforms[e].value=r.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.glslVersion&&(i.glslVersion=t.glslVersion),void 0!==t.extensions)for(const e in t.extensions)i.extensions[e]=t.extensions[e];if(void 0!==t.lights&&(i.lights=t.lights),void 0!==t.clipping&&(i.clipping=t.clipping),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),i.normalScale=(new Ie).fromArray(e)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(i.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(i.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new Ie).fromArray(t.clearcoatNormalScale)),void 0!==t.iridescenceMap&&(i.iridescenceMap=n(t.iridescenceMap)),void 0!==t.iridescenceThicknessMap&&(i.iridescenceThicknessMap=n(t.iridescenceThicknessMap)),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(i.thicknessMap=n(t.thicknessMap)),void 0!==t.anisotropyMap&&(i.anisotropyMap=n(t.anisotropyMap)),void 0!==t.sheenColorMap&&(i.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(i.sheenRoughnessMap=n(t.sheenRoughnessMap)),i}setTextures(t){return this.textures=t,this}static createMaterialFromType(t){return new{ShadowMaterial:bh,SpriteMaterial:Ao,RawShaderMaterial:wh,ShaderMaterial:br,PointsMaterial:Wl,MeshPhysicalMaterial:Sh,MeshStandardMaterial:Mh,MeshPhongMaterial:Th,MeshToonMaterial:Eh,MeshNormalMaterial:Ah,MeshLambertMaterial:Rh,MeshDepthMaterial:ao,MeshDistanceMaterial:so,MeshBasicMaterial:Ii,MeshMatcapMaterial:Ch,LineDashedMaterial:Ph,LineBasicMaterial:Dl,Material:Pi}[t]}}class Eu{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class Au extends Ji{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}toJSON(){const t=super.toJSON();return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}class Ru extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=new iu(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e={},n={};function i(t,i){if(void 0!==e[i])return e[i];const r=t.interleavedBuffers[i],a=function(t,e){if(void 0!==n[e])return n[e];const i=t.arrayBuffers,r=i[e],a=new Uint32Array(r).buffer;return n[e]=a,a}(t,r.buffer),s=Ue(r.type,a),o=new So(s,r.stride);return o.uuid=r.uuid,e[i]=o,o}const r=t.isInstancedBufferGeometry?new Au:new Ji,a=t.data.index;if(void 0!==a){const t=Ue(a.type,a.array);r.setIndex(new zi(t,1))}const s=t.data.attributes;for(const e in s){const n=s[e];let a;if(n.isInterleavedBufferAttribute){const e=i(t.data,n.data);a=new Eo(e,n.itemSize,n.offset,n.normalized)}else{const t=Ue(n.type,n.array);a=new(n.isInstancedBufferAttribute?ol:zi)(t,n.itemSize,n.normalized)}void 0!==n.name&&(a.name=n.name),void 0!==n.usage&&a.setUsage(n.usage),r.setAttribute(e,a)}const o=t.data.morphAttributes;if(o)for(const e in o){const n=o[e],a=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];let s;if(r.isInterleavedBufferAttribute){const e=i(t.data,r.data);s=new Eo(e,r.itemSize,r.offset,r.normalized)}else{const t=Ue(r.type,r.array);s=new zi(t,r.itemSize,r.normalized)}void 0!==r.name&&(s.name=r.name),a.push(s)}r.morphAttributes[e]=a}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];r.addGroup(e.start,e.count,e.materialIndex)}const c=t.data.boundingSphere;if(void 0!==c){const t=new cn;void 0!==c.center&&t.fromArray(c.center),r.boundingSphere=new Pn(t,c.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}}const Cu={UVMapping:O,CubeReflectionMapping:U,CubeRefractionMapping:F,EquirectangularReflectionMapping:B,EquirectangularRefractionMapping:z,CubeUVReflectionMapping:k},Pu={RepeatWrapping:H,ClampToEdgeWrapping:G,MirroredRepeatWrapping:V},Iu={NearestFilter:W,NearestMipmapNearestFilter:j,NearestMipmapLinearFilter:X,LinearFilter:q,LinearMipmapNearestFilter:Y,LinearMipmapLinearFilter:Z};let Lu;class Du{static getContext(){return void 0===Lu&&(Lu=new(window.AudioContext||window.webkitAudioContext)),Lu}static setContext(t){Lu=t}}const Nu=new zn,Ou=new zn,Uu=new zn;class Fu{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Bu(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Bu();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Bu(){return("undefined"==typeof performance?Date:performance).now()}const zu=new cn,ku=new ln,Hu=new cn,Gu=new cn;class Vu extends hi{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const Wu=new cn,ju=new ln,Xu=new cn,qu=new cn;class Yu{constructor(t,e,n){let i,r,a;switch(this.binding=t,this.valueSize=n,e){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,i=this.valueSize,r=t*i+i;let a=this.cumulativeWeight;if(0===a){for(let t=0;t!==i;++t)n[r+t]=n[t];a=e}else{a+=e;const t=e/a;this._mixBufferRegion(n,r,0,t,i)}this.cumulativeWeight=a}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,i=t*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,s=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const t=e*this._origIndex;this._mixBufferRegion(n,i,t,1-r,e)}a>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*e,1,e);for(let t=e,r=e+e;t!==r;++t)if(n[t]!==n[t+e]){s.setValue(n,i);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,i=n*this._origIndex;t.getValue(e,i);for(let t=n,r=i;t!==r;++t)e[t]=e[i+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}_slerp(t,e,n,i){ln.slerpFlat(t,e,t,e,t,n,i)}_slerpAdditive(t,e,n,i,r){const a=this._workIndex*r;ln.multiplyQuaternionsFlat(t,a,t,e,t,n),ln.slerpFlat(t,e,t,e,t,a,i)}_lerp(t,e,n,i,r){const a=1-i;for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]*a+t[n+s]*i}}_lerpAdditive(t,e,n,i,r){for(let a=0;a!==r;++a){const r=e+a;t[r]=t[r]+t[n+a]*i}}}const Zu="\\[\\]\\.:\\/",Ju=new RegExp("["+Zu+"]","g"),Ku="[^"+Zu+"]",Qu="[^"+Zu.replace("\\.","")+"]",$u=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",Ku)+/(WCOD+)?/.source.replace("WCOD",Qu)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ku)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ku)+"$"),td=["material","materials","bones","map"];class ed{constructor(t,e,n){this.path=e,this.parsedPath=n||ed.parseTrackName(e),this.node=ed.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new ed.Composite(t,e,n):new ed(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Ju,"")}static parseTrackName(t){const e=$u.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==i&&-1!==i){const t=n.nodeName.substring(i+1);-1!==td.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let i=0;i<t.length;i++){const r=t[i];if(r.name===e||r.uuid===e)return r;const a=n(r.children);if(a)return a}return null},i=n(t.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)t[e++]=n[i]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,i=e.propertyName;let r=e.propertyIndex;if(t||(t=ed.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");if(n){let i=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===i){i=e;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);t=t.material.map;break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==i){if(void 0===t[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[i]}}const a=t[i];if(void 0===a){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+i+" but it wasn't found.",t)}let s=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?s=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(s=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==r){if("morphTargetInfluences"===i){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[r]&&(r=t.morphTargetDictionary[r])}o=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else void 0!==a.fromArray&&void 0!==a.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(o=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][s]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ed.Composite=class{constructor(t,e,n){const i=n||ed.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,i)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];void 0!==i&&i.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},ed.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},ed.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},ed.prototype.GetterByBindingType=[ed.prototype._getValue_direct,ed.prototype._getValue_array,ed.prototype._getValue_arrayElement,ed.prototype._getValue_toArray],ed.prototype.SetterByBindingTypeAndVersioning=[[ed.prototype._setValue_direct,ed.prototype._setValue_direct_setNeedsUpdate,ed.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ed.prototype._setValue_array,ed.prototype._setValue_array_setNeedsUpdate,ed.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ed.prototype._setValue_arrayElement,ed.prototype._setValue_arrayElement_setNeedsUpdate,ed.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ed.prototype._setValue_fromArray,ed.prototype._setValue_fromArray_setNeedsUpdate,ed.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class nd{constructor(t,e,n=null,i=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;const r=e.tracks,a=r.length,s=new Array(a),o={endingStart:Zt,endingEnd:Zt};for(let t=0;t!==a;++t){const e=r[t].createInterpolant(null);s[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=s,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,i=t._clip.duration,r=i/n,a=n/i;t.warp(1,r,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const i=this._mixer,r=i.time,a=this.timeScale;let s=this._timeScaleInterpolant;null===s&&(s=i._lendControlInterpolant(),this._timeScaleInterpolant=s);const o=s.parameterPositions,l=s.sampleValues;return o[0]=r,o[1]=r+n,l[0]=t/a,l[1]=e/a,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,i){if(!this.enabled)return void this._updateWeight(t);const r=this._startTime;if(null!==r){const i=(t-r)*n;i<0||0===n?e=0:(this._startTime=null,e=n*i)}e*=this._updateTimeScale(t);const a=this._updateTime(e),s=this._updateWeight(t);if(s>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===$t)for(let n=0,i=t.length;n!==i;++n)t[n].evaluate(a),e[n].accumulateAdditive(s);else for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(a),e[n].accumulate(i,s)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const i=n.evaluate(t)[0];e*=i,t>n.parameterPositions[1]&&(this.stopFading(),0===i&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;if(null!==n){e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let i=this.time+t,r=this._loopCount;const a=2202===n;if(0===t)return-1===r?i:a&&1==(1&r)?e-i:i;if(2200===n){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(i>=e)i=e;else{if(!(i<0)){this.time=i;break t}i=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===r&&(t>=0?(r=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),i>=e||i<0){const n=Math.floor(i/e);i-=e*n,r+=Math.abs(n);const s=this.repetitions-r;if(s<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=t>0?e:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===s){const e=t<0;this._setEndings(e,!e,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=i;if(a&&1==(1&r))return e-i}return i}_setEndings(t,e,n){const i=this._interpolantSettings;n?(i.endingStart=Jt,i.endingEnd=Jt):(i.endingStart=t?this.zeroSlopeAtStart?Jt:Zt:Kt,i.endingEnd=e?this.zeroSlopeAtEnd?Jt:Zt:Kt)}_scheduleFading(t,e,n){const i=this._mixer,r=i.time;let a=this._weightInterpolant;null===a&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const s=a.parameterPositions,o=a.sampleValues;return s[0]=r,o[0]=e,s[1]=r+t,o[1]=n,this}}const id=new Float32Array(1);class rd{constructor(t){this.value=t}clone(){return new rd(void 0===this.value.clone?this.value:this.value.clone())}}let ad=0;class sd{constructor(t,e,n=0,i=1/0){this.ray=new Bn(t,e),this.near=n,this.far=i,this.camera=null,this.layers=new Jn,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return ld(t,this,n,e),n.sort(od),n}intersectObjects(t,e=!0,n=[]){for(let i=0,r=t.length;i<r;i++)ld(t[i],this,n,e);return n.sort(od),n}}function od(t,e){return t.distance-e.distance}function ld(t,e,n,i){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===i){const i=t.children;for(let t=0,r=i.length;t<r;t++)ld(i[t],e,n,!0)}}class cd{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Me(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}const hd=new Ie;const ud=new cn,dd=new cn;class pd{constructor(t=new cn,e=new cn){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){ud.subVectors(t,this.start),dd.subVectors(this.end,this.start);const n=dd.dot(dd);let i=dd.dot(ud)/n;return e&&(i=Me(i,0,1)),i}closestPointToPoint(t,e,n){const i=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const md=new cn;const fd=new cn,gd=new zn,vd=new zn;function _d(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,_d(t.children[n]));return e}const yd=new cn,xd=new Ai,bd=new Ai;const wd=new cn,Md=new cn,Sd=new cn;const Td=new cn,Ed=new wr;function Ad(t,e,n,i,r,a,s){Td.set(r,a,s).unproject(i);const o=e[t];if(void 0!==o){const t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],Td.x,Td.y,Td.z)}}const Rd=new dn;const Cd=new cn;let Pd,Id;"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:u}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=u);var Ld=Object.freeze({__proto__:null,ACESFilmicToneMapping:P,AddEquation:x,AddOperation:T,AdditiveAnimationBlendMode:$t,AdditiveBlending:2,AgXToneMapping:L,AlphaFormat:1021,AlwaysCompare:519,AlwaysDepth:1,AlwaysStencilFunc:519,AmbientLight:bu,AnimationAction:nd,AnimationClip:Zh,AnimationLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=new iu(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)}parse(t){const e=[];for(let n=0;n<t.length;n++){const i=Zh.parse(t[n]);e.push(i)}return e}},AnimationMixer:class extends ve{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,i=t._clip.tracks,r=i.length,a=t._propertyBindings,s=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let c=l[o];void 0===c&&(c={},l[o]=c);for(let t=0;t!==r;++t){const r=i[t],l=r.name;let h=c[l];if(void 0!==h)++h.referenceCount,a[t]=h;else{if(h=a[t],void 0!==h){null===h._cacheIndex&&(++h.referenceCount,this._addInactiveBinding(h,o,l));continue}const i=e&&e._propertyBindings[t].binding.parsedPath;h=new Yu(ed.create(n,l,i),r.ValueTypeName,r.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,o,l),a[t]=h}s[t].resultBuffer=h.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,i=this._actionsByClip[n];this._bindAction(t,i&&i.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const i=this._actions,r=this._actionsByClip;let a=r[e];if(void 0===a)a={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=a;else{const e=a.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=i.length,i.push(t),a.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],i=t._cacheIndex;n._cacheIndex=i,e[i]=n,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,a=this._actionsByClip,s=a[r],o=s.knownActions,l=o[o.length-1],c=t._byClipCacheIndex;l._byClipCacheIndex=c,o[c]=l,o.pop(),t._byClipCacheIndex=null;delete s.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete a[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_addInactiveBinding(t,e,n){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[e];void 0===a&&(a={},i[e]=a),a[n]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,i=n.rootNode.uuid,r=n.path,a=this._bindingsByRootAndName,s=a[i],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete s[r],0===Object.keys(s).length&&delete a[i]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,i=this._nActiveBindings++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new zh(new Float32Array(2),new Float32Array(2),1,id),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,i=--this._nActiveControlInterpolants,r=e[i];t.__cacheIndex=i,e[i]=t,r.__cacheIndex=n,e[n]=r}clipAction(t,e,n){const i=e||this._root,r=i.uuid;let a="string"==typeof t?Zh.findByName(i,t):t;const s=null!==a?a.uuid:t,o=this._actionsByClip[s];let l=null;if(void 0===n&&(n=null!==a?a.blendMode:Qt),void 0!==o){const t=o.actionByRoot[r];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===a&&(a=l._clip)}if(null===a)return null;const c=new nd(this,a,e,n);return this._bindAction(c,l),this._addInactiveAction(c,s,r),c}existingAction(t,e){const n=e||this._root,i=n.uuid,r="string"==typeof t?Zh.findByName(n,t):t,a=r?r.uuid:t,s=this._actionsByClip[a];return void 0!==s&&s.actionByRoot[i]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,i=this.time+=t,r=Math.sign(t),a=this._accuIndex^=1;for(let s=0;s!==n;++s){e[s]._update(i,t,r,a)}const s=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)s[t].apply(a);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,i=this._actionsByClip,r=i[n];if(void 0!==r){const t=r.knownActions;for(let n=0,i=t.length;n!==i;++n){const i=t[n];this._deactivateAction(i);const r=i._cacheIndex,a=e[e.length-1];i._cacheIndex=null,i._byClipCacheIndex=null,a._cacheIndex=r,e[r]=a,e.pop(),this._removeInactiveBindingsForAction(i)}delete i[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const i=n[t].actionByRoot[e];void 0!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}const i=this._bindingsByRootAndName[e];if(void 0!==i)for(const t in i){const e=i[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}},AnimationObjectGroup:class{constructor(){this.isAnimationObjectGroup=!0,this.uuid=we(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,a=r.length;let s,o=t.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=e[u];if(void 0===d){d=o++,e[u]=d,t.push(h);for(let t=0,e=a;t!==e;++t)r[t].push(new ed(h,n[t],i[t]))}else if(d<l){s=t[d];const o=--l,c=t[o];e[c.uuid]=d,t[d]=c,e[u]=o,t[o]=h;for(let t=0,e=a;t!==e;++t){const e=r[t],a=e[o];let s=e[d];e[d]=a,void 0===s&&(s=new ed(h,n[t],i[t])),e[o]=s}}else t[d]!==s&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let a=0,s=arguments.length;a!==s;++a){const s=arguments[a],o=s.uuid,l=e[o];if(void 0!==l&&l>=r){const a=r++,c=t[a];e[c.uuid]=l,t[l]=c,e[o]=a,t[a]=s;for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[a],r=e[l];e[l]=i,e[a]=r}}}this.nCachedObjects_=r}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,a=t.length;for(let s=0,o=arguments.length;s!==o;++s){const o=arguments[s].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<r){const s=--r,o=t[s],c=--a,h=t[c];e[o.uuid]=l,t[l]=o,e[h.uuid]=s,t[s]=h,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t],i=e[s],r=e[c];e[l]=i,e[s]=r,e.pop()}}else{const r=--a,s=t[r];r>0&&(e[s.uuid]=l),t[l]=s,t.pop();for(let t=0,e=i;t!==e;++t){const e=n[t];e[l]=e[r],e.pop()}}}this.nCachedObjects_=r}subscribe_(t,e){const n=this._bindingsIndicesByPath;let i=n[t];const r=this._bindings;if(void 0!==i)return r[i];const a=this._paths,s=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,h=new Array(l);i=r.length,n[t]=i,a.push(t),s.push(e),r.push(h);for(let n=c,i=o.length;n!==i;++n){const i=o[n];h[n]=new ed(i,t,e)}return h}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const i=this._paths,r=this._parsedPaths,a=this._bindings,s=a.length-1,o=a[s];e[t[s]]=n,a[n]=o,a.pop(),r[n]=r[s],r.pop(),i[n]=i[s],i.pop()}}},AnimationUtils:Uh,ArcCurve:tc,ArrayCamera:uo,ArrowHelper:class extends hi{constructor(t=new cn(0,0,1),e=new cn(0,0,0),n=1,i=16776960,r=.2*n,a=.2*r){super(),this.type="ArrowHelper",void 0===Pd&&(Pd=new Ji,Pd.setAttribute("position",new Gi([0,0,0,0,1,0],3)),Id=new Mc(0,.5,1,5,1),Id.translate(0,-.5,0)),this.position.copy(e),this.line=new zl(Pd,new Dl({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new mr(Id,new Ii({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,r,a)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Cd.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Cd,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}},AttachedBindMode:D,Audio:Vu,AudioAnalyser:class{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}},AudioContext:Du,AudioListener:class extends hi{constructor(){super(),this.type="AudioListener",this.context=Du.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Fu}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(zu,ku,Hu),Gu.set(0,0,-1).applyQuaternion(ku),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(zu.x,t),e.positionY.linearRampToValueAtTime(zu.y,t),e.positionZ.linearRampToValueAtTime(zu.z,t),e.forwardX.linearRampToValueAtTime(Gu.x,t),e.forwardY.linearRampToValueAtTime(Gu.y,t),e.forwardZ.linearRampToValueAtTime(Gu.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(zu.x,zu.y,zu.z),e.setOrientation(Gu.x,Gu.y,Gu.z,n.x,n.y,n.z)}},AudioLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=new iu(this.manager);function s(e){i?i(e):console.error(e),r.manager.itemError(t)}a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(t){try{const n=t.slice(0);Du.getContext().decodeAudioData(n,(function(t){e(t)})).catch(s)}catch(t){s(t)}}),n,i)}},AxesHelper:class extends Gl{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new Ji;n.setAttribute("position",new Gi(e,3)),n.setAttribute("color",new Gi([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(n,new Dl({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const i=new Ai,r=this.geometry.attributes.color.array;return i.set(t),i.toArray(r,0),i.toArray(r,3),i.set(e),i.toArray(r,6),i.toArray(r,9),i.set(n),i.toArray(r,12),i.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}},BackSide:_,BasicDepthPacking:3200,BasicShadowMap:0,BatchedMesh:Ll,Bone:nl,BooleanKeyframeTrack:Gh,Box2:class{constructor(t=new Ie(1/0,1/0),e=new Ie(-1/0,-1/0)){this.isBox2=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=hd.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,hd).distanceTo(t)}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}},Box3:dn,Box3Helper:class extends Gl{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Ji;i.setIndex(new zi(n,1)),i.setAttribute("position",new Gi([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(i,new Dl({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}dispose(){this.geometry.dispose(),this.material.dispose()}},BoxGeometry:gr,BoxHelper:class extends Gl{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),r=new Ji;r.setIndex(new zi(n,1)),r.setAttribute("position",new zi(i,3)),super(r,new Dl({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Rd.setFromObject(this.object),Rd.isEmpty())return;const e=Rd.min,n=Rd.max,i=this.geometry.attributes.position,r=i.array;r[0]=n.x,r[1]=n.y,r[2]=n.z,r[3]=e.x,r[4]=n.y,r[5]=n.z,r[6]=e.x,r[7]=e.y,r[8]=n.z,r[9]=n.x,r[10]=e.y,r[11]=n.z,r[12]=n.x,r[13]=n.y,r[14]=e.z,r[15]=e.x,r[16]=n.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=n.x,r[22]=e.y,r[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t,e){return super.copy(t,e),this.object=t.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}},BufferAttribute:zi,BufferGeometry:Ji,BufferGeometryLoader:Ru,ByteType:K,Cache:Kh,Camera:wr,CameraHelper:class extends Gl{constructor(t){const e=new Ji,n=new Dl({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],r=[],a={};function s(t,e){o(t),o(e)}function o(t){i.push(0,0,0),r.push(0,0,0),void 0===a[t]&&(a[t]=[]),a[t].push(i.length/3-1)}s("n1","n2"),s("n2","n4"),s("n4","n3"),s("n3","n1"),s("f1","f2"),s("f2","f4"),s("f4","f3"),s("f3","f1"),s("n1","f1"),s("n2","f2"),s("n3","f3"),s("n4","f4"),s("p","n1"),s("p","n2"),s("p","n3"),s("p","n4"),s("u1","u2"),s("u2","u3"),s("u3","u1"),s("c","t"),s("p","c"),s("cn1","cn2"),s("cn3","cn4"),s("cf1","cf2"),s("cf3","cf4"),e.setAttribute("position",new Gi(i,3)),e.setAttribute("color",new Gi(r,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update();const l=new Ai(16755200),c=new Ai(16711680),h=new Ai(43775),u=new Ai(16777215),d=new Ai(3355443);this.setColors(l,c,h,u,d)}setColors(t,e,n,i,r){const a=this.geometry.getAttribute("color");a.setXYZ(0,t.r,t.g,t.b),a.setXYZ(1,t.r,t.g,t.b),a.setXYZ(2,t.r,t.g,t.b),a.setXYZ(3,t.r,t.g,t.b),a.setXYZ(4,t.r,t.g,t.b),a.setXYZ(5,t.r,t.g,t.b),a.setXYZ(6,t.r,t.g,t.b),a.setXYZ(7,t.r,t.g,t.b),a.setXYZ(8,t.r,t.g,t.b),a.setXYZ(9,t.r,t.g,t.b),a.setXYZ(10,t.r,t.g,t.b),a.setXYZ(11,t.r,t.g,t.b),a.setXYZ(12,t.r,t.g,t.b),a.setXYZ(13,t.r,t.g,t.b),a.setXYZ(14,t.r,t.g,t.b),a.setXYZ(15,t.r,t.g,t.b),a.setXYZ(16,t.r,t.g,t.b),a.setXYZ(17,t.r,t.g,t.b),a.setXYZ(18,t.r,t.g,t.b),a.setXYZ(19,t.r,t.g,t.b),a.setXYZ(20,t.r,t.g,t.b),a.setXYZ(21,t.r,t.g,t.b),a.setXYZ(22,t.r,t.g,t.b),a.setXYZ(23,t.r,t.g,t.b),a.setXYZ(24,e.r,e.g,e.b),a.setXYZ(25,e.r,e.g,e.b),a.setXYZ(26,e.r,e.g,e.b),a.setXYZ(27,e.r,e.g,e.b),a.setXYZ(28,e.r,e.g,e.b),a.setXYZ(29,e.r,e.g,e.b),a.setXYZ(30,e.r,e.g,e.b),a.setXYZ(31,e.r,e.g,e.b),a.setXYZ(32,n.r,n.g,n.b),a.setXYZ(33,n.r,n.g,n.b),a.setXYZ(34,n.r,n.g,n.b),a.setXYZ(35,n.r,n.g,n.b),a.setXYZ(36,n.r,n.g,n.b),a.setXYZ(37,n.r,n.g,n.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0}update(){const t=this.geometry,e=this.pointMap;Ed.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Ad("c",e,t,Ed,0,0,-1),Ad("t",e,t,Ed,0,0,1),Ad("n1",e,t,Ed,-1,-1,-1),Ad("n2",e,t,Ed,1,-1,-1),Ad("n3",e,t,Ed,-1,1,-1),Ad("n4",e,t,Ed,1,1,-1),Ad("f1",e,t,Ed,-1,-1,1),Ad("f2",e,t,Ed,1,-1,1),Ad("f3",e,t,Ed,-1,1,1),Ad("f4",e,t,Ed,1,1,1),Ad("u1",e,t,Ed,.7,1.1,-1),Ad("u2",e,t,Ed,-.7,1.1,-1),Ad("u3",e,t,Ed,0,2,-1),Ad("cf1",e,t,Ed,-1,0,1),Ad("cf2",e,t,Ed,1,0,1),Ad("cf3",e,t,Ed,0,-1,1),Ad("cf4",e,t,Ed,0,1,1),Ad("cn1",e,t,Ed,-1,0,-1),Ad("cn2",e,t,Ed,1,0,-1),Ad("cn3",e,t,Ed,0,-1,-1),Ad("cn4",e,t,Ed,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}},CanvasTexture:class extends tn{constructor(t,e,n,i,r,a,s,o,l){super(t,e,n,i,r,a,s,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}},CapsuleGeometry:bc,CatmullRomCurve3:sc,CineonToneMapping:C,CircleGeometry:wc,ClampToEdgeWrapping:G,Clock:Fu,Color:Ai,ColorKeyframeTrack:Vh,ColorManagement:je,CompressedArrayTexture:class extends Kl{constructor(t,e,n,i,r,a){super(t,e,n,r,a),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=G}},CompressedCubeTexture:class extends Kl{constructor(t,e,n){super(void 0,t[0].width,t[0].height,e,n,U),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=t}},CompressedTexture:Kl,CompressedTextureLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=[],s=new Kl,o=new iu(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(r.withCredentials);let l=0;function c(c){o.load(t[c],(function(t){const n=r.parse(t,!0);a[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(s.minFilter=q),s.image=a,s.format=n.format,s.needsUpdate=!0,e&&e(s))}),n,i)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)c(e);else o.load(t,(function(t){const n=r.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){a[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)a[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),a[e].format=n.format,a[e].width=n.width,a[e].height=n.height}s.image=a}else s.image.width=n.width,s.image.height=n.height,s.mipmaps=n.mipmaps;1===n.mipmapCount&&(s.minFilter=q),s.format=n.format,s.needsUpdate=!0,e&&e(s)}),n,i);return s}},ConeGeometry:Sc,ConstantAlphaFactor:213,ConstantColorFactor:211,CubeCamera:Tr,CubeReflectionMapping:U,CubeRefractionMapping:F,CubeTexture:Er,CubeTextureLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=new Er;r.colorSpace=ie;const a=new ru(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let s=0;function o(n){a.load(t[n],(function(t){r.images[n]=t,s++,6===s&&(r.needsUpdate=!0,e&&e(r))}),void 0,i)}for(let e=0;e<t.length;++e)o(e);return r}},CubeUVReflectionMapping:k,CubicBezierCurve:hc,CubicBezierCurve3:uc,CubicInterpolant:Bh,CullFaceBack:1,CullFaceFront:2,CullFaceFrontBack:3,CullFaceNone:0,Curve:Ql,CurvePath:_c,CustomBlending:5,CustomToneMapping:I,CylinderGeometry:Mc,Cylindrical:class{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}},Data3DTexture:on,DataArrayTexture:an,DataTexture:il,DataTextureLoader:au,DataUtils:Ui,DecrementStencilOp:7683,DecrementWrapStencilOp:34056,DefaultLoadingManager:$h,DepthFormat:lt,DepthStencilFormat:ct,DepthTexture:xa,DetachedBindMode:N,DirectionalLight:xu,DirectionalLightHelper:class extends hi{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",void 0===e&&(e=1);let i=new Ji;i.setAttribute("position",new Gi([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const r=new Dl({fog:!1,toneMapped:!1});this.lightPlane=new zl(i,r),this.add(this.lightPlane),i=new Ji,i.setAttribute("position",new Gi([0,0,0,0,0,1],3)),this.targetLine=new zl(i,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),wd.setFromMatrixPosition(this.light.matrixWorld),Md.setFromMatrixPosition(this.light.target.matrixWorld),Sd.subVectors(Md,wd),this.lightPlane.lookAt(Md),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Md),this.targetLine.scale.z=Sd.length()}},DiscreteInterpolant:kh,DisplayP3ColorSpace:ae,DodecahedronGeometry:Ec,DoubleSide:y,DstAlphaFactor:206,DstColorFactor:208,DynamicCopyUsage:35050,DynamicDrawUsage:35048,DynamicReadUsage:35049,EdgesGeometry:Ic,EllipseCurve:$l,EqualCompare:514,EqualDepth:4,EqualStencilFunc:514,EquirectangularReflectionMapping:B,EquirectangularRefractionMapping:z,Euler:Zn,EventDispatcher:ve,ExtrudeGeometry:oh,FileLoader:iu,Float16BufferAttribute:class extends zi{constructor(t,e,n){super(new Uint16Array(t),e,n),this.isFloat16BufferAttribute=!0}getX(t){let e=Oi(this.array[t*this.itemSize]);return this.normalized&&(e=Re(e,this.array)),e}setX(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize]=Ni(e),this}getY(t){let e=Oi(this.array[t*this.itemSize+1]);return this.normalized&&(e=Re(e,this.array)),e}setY(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+1]=Ni(e),this}getZ(t){let e=Oi(this.array[t*this.itemSize+2]);return this.normalized&&(e=Re(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+2]=Ni(e),this}getW(t){let e=Oi(this.array[t*this.itemSize+3]);return this.normalized&&(e=Re(e,this.array)),e}setW(t,e){return this.normalized&&(e=Ce(e,this.array)),this.array[t*this.itemSize+3]=Ni(e),this}setXY(t,e,n){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array)),this.array[t+0]=Ni(e),this.array[t+1]=Ni(n),this}setXYZ(t,e,n,i){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array)),this.array[t+0]=Ni(e),this.array[t+1]=Ni(n),this.array[t+2]=Ni(i),this}setXYZW(t,e,n,i,r){return t*=this.itemSize,this.normalized&&(e=Ce(e,this.array),n=Ce(n,this.array),i=Ce(i,this.array),r=Ce(r,this.array)),this.array[t+0]=Ni(e),this.array[t+1]=Ni(n),this.array[t+2]=Ni(i),this.array[t+3]=Ni(r),this}},Float32BufferAttribute:Gi,Float64BufferAttribute:class extends zi{constructor(t,e,n){super(new Float64Array(t),e,n)}},FloatType:nt,Fog:wo,FogExp2:bo,FramebufferTexture:class extends tn{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=W,this.minFilter=W,this.generateMipmaps=!1,this.needsUpdate=!0}},FrontSide:v,Frustum:Nr,GLBufferAttribute:class{constructor(t,e,n,i,r){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}},GLSL1:"100",GLSL3:pe,GreaterCompare:516,GreaterDepth:6,GreaterEqualCompare:518,GreaterEqualDepth:5,GreaterEqualStencilFunc:518,GreaterStencilFunc:516,GridHelper:class extends Gl{constructor(t=10,e=10,n=4473924,i=8947848){n=new Ai(n),i=new Ai(i);const r=e/2,a=t/e,s=t/2,o=[],l=[];for(let t=0,c=0,h=-s;t<=e;t++,h+=a){o.push(-s,0,h,s,0,h),o.push(h,0,-s,h,0,s);const e=t===r?n:i;e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3,e.toArray(l,c),c+=3}const c=new Ji;c.setAttribute("position",new Gi(o,3)),c.setAttribute("color",new Gi(l,3));super(c,new Dl({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},Group:po,HalfFloatType:it,HemisphereLight:ou,HemisphereLightHelper:class extends hi{constructor(t,e,n){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new hh(e);i.rotateY(.5*Math.PI),this.material=new Ii({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const r=i.getAttribute("position"),a=new Float32Array(3*r.count);i.setAttribute("color",new zi(a,3)),this.add(new mr(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");xd.copy(this.light.color),bd.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const i=t<n/2?xd:bd;e.setXYZ(t,i.r,i.g,i.b)}e.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),t.lookAt(yd.setFromMatrixPosition(this.light.matrixWorld).negate())}},IcosahedronGeometry:ch,ImageBitmapLoader:class extends tu{constructor(t){super(t),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,a=Kh.get(t);if(void 0!==a)return r.manager.itemStart(t),a.then?void a.then((n=>{e&&e(n),r.manager.itemEnd(t)})).catch((t=>{i&&i(t)})):(setTimeout((function(){e&&e(a),r.manager.itemEnd(t)}),0),a);const s={};s.credentials="anonymous"===this.crossOrigin?"same-origin":"include",s.headers=this.requestHeader;const o=fetch(t,s).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(r.options,{colorSpaceConversion:"none"}))})).then((function(n){return Kh.add(t,n),e&&e(n),r.manager.itemEnd(t),n})).catch((function(e){i&&i(e),Kh.remove(t),r.manager.itemError(t),r.manager.itemEnd(t)}));Kh.add(t,o),r.manager.itemStart(t)}},ImageLoader:ru,ImageUtils:Ze,IncrementStencilOp:7682,IncrementWrapStencilOp:34055,InstancedBufferAttribute:ol,InstancedBufferGeometry:Au,InstancedInterleavedBuffer:class extends So{constructor(t,e,n=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}},InstancedMesh:fl,Int16BufferAttribute:class extends zi{constructor(t,e,n){super(new Int16Array(t),e,n)}},Int32BufferAttribute:class extends zi{constructor(t,e,n){super(new Int32Array(t),e,n)}},Int8BufferAttribute:class extends zi{constructor(t,e,n){super(new Int8Array(t),e,n)}},IntType:tt,InterleavedBuffer:So,InterleavedBufferAttribute:Eo,Interpolant:Fh,InterpolateDiscrete:Xt,InterpolateLinear:qt,InterpolateSmooth:Yt,InvertStencilOp:5386,KeepStencilOp:ue,KeyframeTrack:Hh,LOD:jo,LatheGeometry:xc,Layers:Jn,LessCompare:513,LessDepth:2,LessEqualCompare:515,LessEqualDepth:3,LessEqualStencilFunc:515,LessStencilFunc:513,Light:su,LightProbe:Su,Line:zl,Line3:pd,LineBasicMaterial:Dl,LineCurve:dc,LineCurve3:pc,LineDashedMaterial:Ph,LineLoop:Vl,LineSegments:Gl,LinearDisplayP3ColorSpace:se,LinearEncoding:te,LinearFilter:q,LinearInterpolant:zh,LinearMipMapLinearFilter:1008,LinearMipMapNearestFilter:1007,LinearMipmapLinearFilter:Z,LinearMipmapNearestFilter:Y,LinearSRGBColorSpace:re,LinearToneMapping:A,LinearTransfer:oe,Loader:tu,LoaderUtils:Eu,LoadingManager:Qh,LoopOnce:2200,LoopPingPong:2202,LoopRepeat:2201,LuminanceAlphaFormat:1025,LuminanceFormat:1024,MOUSE:d,Material:Pi,MaterialLoader:Tu,MathUtils:Pe,Matrix3:Le,Matrix4:zn,MaxEquation:104,Mesh:mr,MeshBasicMaterial:Ii,MeshDepthMaterial:ao,MeshDistanceMaterial:so,MeshLambertMaterial:Rh,MeshMatcapMaterial:Ch,MeshNormalMaterial:Ah,MeshPhongMaterial:Th,MeshPhysicalMaterial:Sh,MeshStandardMaterial:Mh,MeshToonMaterial:Eh,MinEquation:103,MirroredRepeatWrapping:V,MixOperation:S,MultiplyBlending:4,MultiplyOperation:M,NearestFilter:W,NearestMipMapLinearFilter:1005,NearestMipMapNearestFilter:1004,NearestMipmapLinearFilter:X,NearestMipmapNearestFilter:j,NeverCompare:512,NeverDepth:0,NeverStencilFunc:512,NoBlending:0,NoColorSpace:ne,NoToneMapping:E,NormalAnimationBlendMode:Qt,NormalBlending:1,NotEqualCompare:517,NotEqualDepth:7,NotEqualStencilFunc:517,NumberKeyframeTrack:Wh,Object3D:hi,ObjectLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=this,a=""===this.path?Eu.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||a;const s=new iu(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(t,(function(n){let a=null;try{a=JSON.parse(n)}catch(e){return void 0!==i&&i(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const s=a.metadata;if(void 0===s||void 0===s.type||"geometry"===s.type.toLowerCase())return void 0!==i&&i(new Error("THREE.ObjectLoader: Can't load "+t)),void console.error("THREE.ObjectLoader: Can't load "+t);r.parse(a,e)}),n,i)}async loadAsync(t,e){const n=""===this.path?Eu.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const i=new iu(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const r=await i.loadAsync(t,e),a=JSON.parse(r),s=a.metadata;if(void 0===s||void 0===s.type||"geometry"===s.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(a)}parse(t,e){const n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),a=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),s=this.parseTextures(t.textures,a),o=this.parseMaterials(t.materials,s),l=this.parseObject(t.object,r,o,s,n),c=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,c),void 0!==e){let t=!1;for(const e in a)if(a[e].data instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),i=this.parseGeometries(t.geometries,n),r=await this.parseImagesAsync(t.images),a=this.parseTextures(t.textures,r),s=this.parseMaterials(t.materials,a),o=this.parseObject(t.object,i,s,a,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(t){const e={};if(void 0!==t)for(let n=0,i=t.length;n<i;n++){const i=(new Lc).fromJSON(t[n]);e[i.uuid]=i}return e}parseSkeletons(t,e){const n={},i={};if(e.traverse((function(t){t.isBone&&(i[t.uuid]=t)})),void 0!==t)for(let e=0,r=t.length;e<r;e++){const r=(new sl).fromJSON(t[e],i);n[r.uuid]=r}return n}parseGeometries(t,e){const n={};if(void 0!==t){const i=new Ru;for(let r=0,a=t.length;r<a;r++){let a;const s=t[r];switch(s.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(s);break;default:s.type in xh?a=xh[s.type].fromJSON(s,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${s.type}"`)}a.uuid=s.uuid,void 0!==s.name&&(a.name=s.name),void 0!==s.userData&&(a.userData=s.userData),n[s.uuid]=a}}return n}parseMaterials(t,e){const n={},i={};if(void 0!==t){const r=new Tu;r.setTextures(e);for(let e=0,a=t.length;e<a;e++){const a=t[e];void 0===n[a.uuid]&&(n[a.uuid]=r.parse(a)),i[a.uuid]=n[a.uuid]}}return i}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const i=t[n],r=Zh.parse(i);e[r.uuid]=r}return e}parseImages(t,e){const n=this,i={};let r;function a(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),r.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:Ue(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new Qh(e);r=new ru(n),r.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.url;if(Array.isArray(r)){const t=[];for(let e=0,n=r.length;e<n;e++){const n=a(r[e]);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new il(n.data,n.width,n.height)))}i[n.uuid]=new Ke(t)}else{const t=a(n.url);i[n.uuid]=new Ke(t)}}}return i}async parseImagesAsync(t){const e=this,n={};let i;async function r(t){if("string"==typeof t){const n=t,r=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await i.loadAsync(r)}return t.data?{data:Ue(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){i=new ru(this.manager),i.setCrossOrigin(this.crossOrigin);for(let e=0,i=t.length;e<i;e++){const i=t[e],a=i.url;if(Array.isArray(a)){const t=[];for(let e=0,n=a.length;e<n;e++){const n=a[e],i=await r(n);null!==i&&(i instanceof HTMLImageElement?t.push(i):t.push(new il(i.data,i.width,i.height)))}n[i.uuid]=new Ke(t)}else{const t=await r(i.url);n[i.uuid]=new Ke(t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const i={};if(void 0!==t)for(let r=0,a=t.length;r<a;r++){const a=t[r];void 0===a.image&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),void 0===e[a.image]&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const s=e[a.image],o=s.data;let l;Array.isArray(o)?(l=new Er,6===o.length&&(l.needsUpdate=!0)):(l=o&&o.data?new il:new tn,o&&(l.needsUpdate=!0)),l.source=s,l.uuid=a.uuid,void 0!==a.name&&(l.name=a.name),void 0!==a.mapping&&(l.mapping=n(a.mapping,Cu)),void 0!==a.channel&&(l.channel=a.channel),void 0!==a.offset&&l.offset.fromArray(a.offset),void 0!==a.repeat&&l.repeat.fromArray(a.repeat),void 0!==a.center&&l.center.fromArray(a.center),void 0!==a.rotation&&(l.rotation=a.rotation),void 0!==a.wrap&&(l.wrapS=n(a.wrap[0],Pu),l.wrapT=n(a.wrap[1],Pu)),void 0!==a.format&&(l.format=a.format),void 0!==a.internalFormat&&(l.internalFormat=a.internalFormat),void 0!==a.type&&(l.type=a.type),void 0!==a.colorSpace&&(l.colorSpace=a.colorSpace),void 0!==a.encoding&&(l.encoding=a.encoding),void 0!==a.minFilter&&(l.minFilter=n(a.minFilter,Iu)),void 0!==a.magFilter&&(l.magFilter=n(a.magFilter,Iu)),void 0!==a.anisotropy&&(l.anisotropy=a.anisotropy),void 0!==a.flipY&&(l.flipY=a.flipY),void 0!==a.generateMipmaps&&(l.generateMipmaps=a.generateMipmaps),void 0!==a.premultiplyAlpha&&(l.premultiplyAlpha=a.premultiplyAlpha),void 0!==a.unpackAlignment&&(l.unpackAlignment=a.unpackAlignment),void 0!==a.compareFunction&&(l.compareFunction=a.compareFunction),void 0!==a.userData&&(l.userData=a.userData),i[a.uuid]=l}return i}parseObject(t,e,n,i,r){let a,s,o;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function c(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];void 0===n[r]&&console.warn("THREE.ObjectLoader: Undefined material",r),e.push(n[r])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function h(t){return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),i[t]}switch(t.type){case"Scene":a=new Mo,void 0!==t.background&&(Number.isInteger(t.background)?a.background=new Ai(t.background):a.background=h(t.background)),void 0!==t.environment&&(a.environment=h(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?a.fog=new wo(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(a.fog=new bo(t.fog.color,t.fog.density)),""!==t.fog.name&&(a.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(a.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(a.backgroundIntensity=t.backgroundIntensity);break;case"PerspectiveCamera":a=new Mr(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(a.focus=t.focus),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.filmGauge&&(a.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(a.filmOffset=t.filmOffset),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"OrthographicCamera":a=new Yr(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"AmbientLight":a=new bu(t.color,t.intensity);break;case"DirectionalLight":a=new xu(t.color,t.intensity);break;case"PointLight":a=new _u(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":a=new wu(t.color,t.intensity,t.width,t.height);break;case"SpotLight":a=new pu(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":a=new ou(t.color,t.groundColor,t.intensity);break;case"LightProbe":a=(new Su).fromJSON(t);break;case"SkinnedMesh":s=l(t.geometry),o=c(t.material),a=new el(s,o),void 0!==t.bindMode&&(a.bindMode=t.bindMode),void 0!==t.bindMatrix&&a.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(a.skeleton=t.skeleton);break;case"Mesh":s=l(t.geometry),o=c(t.material),a=new mr(s,o);break;case"InstancedMesh":s=l(t.geometry),o=c(t.material);const e=t.count,n=t.instanceMatrix,i=t.instanceColor;a=new fl(s,o,e),a.instanceMatrix=new ol(new Float32Array(n.array),16),void 0!==i&&(a.instanceColor=new ol(new Float32Array(i.array),i.itemSize));break;case"BatchedMesh":s=l(t.geometry),o=c(t.material),a=new Ll(t.maxGeometryCount,t.maxVertexCount,t.maxIndexCount,o),a.geometry=s,a.perObjectFrustumCulled=t.perObjectFrustumCulled,a.sortObjects=t.sortObjects,a._drawRanges=t.drawRanges,a._reservedRanges=t.reservedRanges,a._visibility=t.visibility,a._active=t.active,a._bounds=t.bounds.map((t=>{const e=new dn;e.min.fromArray(t.boxMin),e.max.fromArray(t.boxMax);const n=new Pn;return n.radius=t.sphereRadius,n.center.fromArray(t.sphereCenter),{boxInitialized:t.boxInitialized,box:e,sphereInitialized:t.sphereInitialized,sphere:n}})),a._maxGeometryCount=t.maxGeometryCount,a._maxVertexCount=t.maxVertexCount,a._maxIndexCount=t.maxIndexCount,a._geometryInitialized=t.geometryInitialized,a._geometryCount=t.geometryCount,a._matricesTexture=h(t.matricesTexture.uuid);break;case"LOD":a=new jo;break;case"Line":a=new zl(l(t.geometry),c(t.material));break;case"LineLoop":a=new Vl(l(t.geometry),c(t.material));break;case"LineSegments":a=new Gl(l(t.geometry),c(t.material));break;case"PointCloud":case"Points":a=new Zl(l(t.geometry),c(t.material));break;case"Sprite":a=new Ho(c(t.material));break;case"Group":a=new po;break;case"Bone":a=new nl;break;default:a=new hi}if(a.uuid=t.uuid,void 0!==t.name&&(a.name=t.name),void 0!==t.matrix?(a.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(a.matrixAutoUpdate=t.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==t.position&&a.position.fromArray(t.position),void 0!==t.rotation&&a.rotation.fromArray(t.rotation),void 0!==t.quaternion&&a.quaternion.fromArray(t.quaternion),void 0!==t.scale&&a.scale.fromArray(t.scale)),void 0!==t.up&&a.up.fromArray(t.up),void 0!==t.castShadow&&(a.castShadow=t.castShadow),void 0!==t.receiveShadow&&(a.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(a.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(a.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(a.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&a.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(a.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(a.visible=t.visible),void 0!==t.frustumCulled&&(a.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(a.renderOrder=t.renderOrder),void 0!==t.userData&&(a.userData=t.userData),void 0!==t.layers&&(a.layers.mask=t.layers),void 0!==t.children){const s=t.children;for(let t=0;t<s.length;t++)a.add(this.parseObject(s[t],e,n,i,r))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];a.animations.push(r[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(a.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],i=a.getObjectByProperty("uuid",n.object);void 0!==i&&a.addLevel(i,n.distance,n.hysteresis)}}return a}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}},ObjectSpaceNormalMap:1,OctahedronGeometry:hh,OneFactor:201,OneMinusConstantAlphaFactor:214,OneMinusConstantColorFactor:212,OneMinusDstAlphaFactor:207,OneMinusDstColorFactor:209,OneMinusSrcAlphaFactor:w,OneMinusSrcColorFactor:203,OrthographicCamera:Yr,P3Primaries:he,PCFShadowMap:m,PCFSoftShadowMap:f,PMREMGenerator:aa,Path:yc,PerspectiveCamera:Mr,Plane:Ir,PlaneGeometry:Fr,PlaneHelper:class extends zl{constructor(t,e=1,n=16776960){const i=n,r=new Ji;r.setAttribute("position",new Gi([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),r.computeBoundingSphere(),super(r,new Dl({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const a=new Ji;a.setAttribute("position",new Gi([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),a.computeBoundingSphere(),this.add(new mr(a,new Ii({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}},PointLight:_u,PointLightHelper:class extends mr{constructor(t,e,n){super(new ph(e,4,2),new Ii({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}},Points:Zl,PointsMaterial:Wl,PolarGridHelper:class extends Gl{constructor(t=10,e=16,n=8,i=64,r=4473924,a=8947848){r=new Ai(r),a=new Ai(a);const s=[],o=[];if(e>1)for(let n=0;n<e;n++){const i=n/e*(2*Math.PI),l=Math.sin(i)*t,c=Math.cos(i)*t;s.push(0,0,0),s.push(l,0,c);const h=1&n?r:a;o.push(h.r,h.g,h.b),o.push(h.r,h.g,h.b)}for(let e=0;e<n;e++){const l=1&e?r:a,c=t-t/n*e;for(let t=0;t<i;t++){let e=t/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c;s.push(n,0,r),o.push(l.r,l.g,l.b),e=(t+1)/i*(2*Math.PI),n=Math.sin(e)*c,r=Math.cos(e)*c,s.push(n,0,r),o.push(l.r,l.g,l.b)}}const l=new Ji;l.setAttribute("position",new Gi(s,3)),l.setAttribute("color",new Gi(o,3));super(l,new Dl({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}},PolyhedronGeometry:Tc,PositionalAudio:class extends Vu{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(Wu,ju,Xu),qu.set(0,0,1).applyQuaternion(ju);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(Wu.x,t),e.positionY.linearRampToValueAtTime(Wu.y,t),e.positionZ.linearRampToValueAtTime(Wu.z,t),e.orientationX.linearRampToValueAtTime(qu.x,t),e.orientationY.linearRampToValueAtTime(qu.y,t),e.orientationZ.linearRampToValueAtTime(qu.z,t)}else e.setPosition(Wu.x,Wu.y,Wu.z),e.setOrientation(qu.x,qu.y,qu.z)}},PropertyBinding:ed,PropertyMixer:Yu,QuadraticBezierCurve:mc,QuadraticBezierCurve3:fc,Quaternion:ln,QuaternionKeyframeTrack:Xh,QuaternionLinearInterpolant:jh,RED_GREEN_RGTC2_Format:Wt,RED_RGTC1_Format:36283,REVISION:u,RGBADepthPacking:3201,RGBAFormat:ot,RGBAIntegerFormat:mt,RGBA_ASTC_10x10_Format:Ft,RGBA_ASTC_10x5_Format:Nt,RGBA_ASTC_10x6_Format:Ot,RGBA_ASTC_10x8_Format:Ut,RGBA_ASTC_12x10_Format:Bt,RGBA_ASTC_12x12_Format:zt,RGBA_ASTC_4x4_Format:Et,RGBA_ASTC_5x4_Format:At,RGBA_ASTC_5x5_Format:Rt,RGBA_ASTC_6x5_Format:Ct,RGBA_ASTC_6x6_Format:Pt,RGBA_ASTC_8x5_Format:It,RGBA_ASTC_8x6_Format:Lt,RGBA_ASTC_8x8_Format:Dt,RGBA_BPTC_Format:kt,RGBA_ETC2_EAC_Format:Tt,RGBA_PVRTC_2BPPV1_Format:wt,RGBA_PVRTC_4BPPV1_Format:bt,RGBA_S3TC_DXT1_Format:gt,RGBA_S3TC_DXT3_Format:vt,RGBA_S3TC_DXT5_Format:_t,RGB_BPTC_SIGNED_Format:Ht,RGB_BPTC_UNSIGNED_Format:Gt,RGB_ETC1_Format:Mt,RGB_ETC2_Format:St,RGB_PVRTC_2BPPV1_Format:xt,RGB_PVRTC_4BPPV1_Format:yt,RGB_S3TC_DXT1_Format:ft,RGFormat:dt,RGIntegerFormat:pt,RawShaderMaterial:wh,Ray:Bn,Raycaster:sd,Rec709Primaries:ce,RectAreaLight:wu,RedFormat:ht,RedIntegerFormat:ut,ReinhardToneMapping:R,RenderTarget:nn,RepeatWrapping:H,ReplaceStencilOp:7681,ReverseSubtractEquation:102,RingGeometry:uh,SIGNED_RED_GREEN_RGTC2_Format:jt,SIGNED_RED_RGTC1_Format:Vt,SRGBColorSpace:ie,SRGBTransfer:le,Scene:Mo,ShaderChunk:Br,ShaderLib:kr,ShaderMaterial:br,ShadowMaterial:bh,Shape:Lc,ShapeGeometry:dh,ShapePath:class{constructor(){this.type="ShapePath",this.color=new Ai,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new yc,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,i){return this.currentPath.quadraticCurveTo(t,e,n,i),this}bezierCurveTo(t,e,n,i,r,a){return this.currentPath.bezierCurveTo(t,e,n,i,r,a),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t){function e(t,e){const n=e.length;let i=!1;for(let r=n-1,a=0;a<n;r=a++){let n=e[r],s=e[a],o=s.x-n.x,l=s.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[a],o=-o,s=e[r],l=-l),t.y<n.y||t.y>s.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-o*(t.y-n.y);if(0===e)return!0;if(e<0)continue;i=!i}}else{if(t.y!==n.y)continue;if(s.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=s.x)return!0}}return i}const n=rh.isClockWise,i=this.subPaths;if(0===i.length)return[];let r,a,s;const o=[];if(1===i.length)return a=i[0],s=new Lc,s.curves=a.curves,o.push(s),o;let l=!n(i[0].getPoints());l=t?!l:l;const c=[],h=[];let u,d,p=[],m=0;h[m]=void 0,p[m]=[];for(let e=0,s=i.length;e<s;e++)a=i[e],u=a.getPoints(),r=n(u),r=t?!r:r,r?(!l&&h[m]&&m++,h[m]={s:new Lc,p:u},h[m].s.curves=a.curves,l&&m++,p[m]=[]):p[m].push({h:a,p:u[0]});if(!h[0])return function(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=new Lc;r.curves=i.curves,e.push(r)}return e}(i);if(h.length>1){let t=!1,n=0;for(let t=0,e=h.length;t<e;t++)c[t]=[];for(let i=0,r=h.length;i<r;i++){const r=p[i];for(let a=0;a<r.length;a++){const s=r[a];let o=!0;for(let r=0;r<h.length;r++)e(s.p,h[r].p)&&(i!==r&&n++,o?(o=!1,c[r].push(s)):t=!0);o&&c[i].push(s)}}n>0&&!1===t&&(p=c)}for(let t=0,e=h.length;t<e;t++){s=h[t].s,o.push(s),d=p[t];for(let t=0,e=d.length;t<e;t++)s.holes.push(d[t].h)}return o}},ShapeUtils:rh,ShortType:Q,Skeleton:sl,SkeletonHelper:class extends Gl{constructor(t){const e=_d(t),n=new Ji,i=[],r=[],a=new Ai(0,0,1),s=new Ai(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),r.push(a.r,a.g,a.b),r.push(s.r,s.g,s.b))}n.setAttribute("position",new Gi(i,3)),n.setAttribute("color",new Gi(r,3));super(n,new Dl({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,i=n.getAttribute("position");vd.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const r=e[t];r.parent&&r.parent.isBone&&(gd.multiplyMatrices(vd,r.matrixWorld),fd.setFromMatrixPosition(gd),i.setXYZ(n,fd.x,fd.y,fd.z),gd.multiplyMatrices(vd,r.parent.matrixWorld),fd.setFromMatrixPosition(gd),i.setXYZ(n+1,fd.x,fd.y,fd.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}dispose(){this.geometry.dispose(),this.material.dispose()}},SkinnedMesh:el,Source:Ke,Sphere:Pn,SphereGeometry:ph,Spherical:cd,SphericalHarmonics3:Mu,SplineCurve:gc,SpotLight:pu,SpotLightHelper:class extends hi{constructor(t,e){super(),this.light=t,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e,this.type="SpotLightHelper";const n=new Ji,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const r=t/n*Math.PI*2,a=e/n*Math.PI*2;i.push(Math.cos(r),Math.sin(r),1,Math.cos(a),Math.sin(a),1)}n.setAttribute("position",new Gi(i,3));const r=new Dl({fog:!1,toneMapped:!1});this.cone=new Gl(n,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),md.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(md),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}},Sprite:Ho,SpriteMaterial:Ao,SrcAlphaFactor:b,SrcAlphaSaturateFactor:210,SrcColorFactor:202,StaticCopyUsage:35046,StaticDrawUsage:de,StaticReadUsage:35045,StereoCamera:class{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Mr,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Mr,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,Uu.copy(t.projectionMatrix);const n=e.eyeSep/2,i=n*e.near/e.focus,r=e.near*Math.tan(xe*e.fov*.5)/e.zoom;let a,s;Ou.elements[12]=-n,Nu.elements[12]=n,a=-r*e.aspect+i,s=r*e.aspect+i,Uu.elements[0]=2*e.near/(s-a),Uu.elements[8]=(s+a)/(s-a),this.cameraL.projectionMatrix.copy(Uu),a=-r*e.aspect-i,s=r*e.aspect-i,Uu.elements[0]=2*e.near/(s-a),Uu.elements[8]=(s+a)/(s-a),this.cameraR.projectionMatrix.copy(Uu)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Ou),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Nu)}},StreamCopyUsage:35042,StreamDrawUsage:35040,StreamReadUsage:35041,StringKeyframeTrack:qh,SubtractEquation:101,SubtractiveBlending:3,TOUCH:p,TangentSpaceNormalMap:0,TetrahedronGeometry:mh,Texture:tn,TextureLoader:class extends tu{constructor(t){super(t)}load(t,e,n,i){const r=new tn,a=new ru(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,(function(t){r.image=t,r.needsUpdate=!0,void 0!==e&&e(r)}),n,i),r}},TorusGeometry:fh,TorusKnotGeometry:gh,Triangle:wi,TriangleFanDrawMode:2,TriangleStripDrawMode:1,TrianglesDrawMode:0,TubeGeometry:vh,TwoPassDoubleSide:2,UVMapping:O,Uint16BufferAttribute:ki,Uint32BufferAttribute:Hi,Uint8BufferAttribute:class extends zi{constructor(t,e,n){super(new Uint8Array(t),e,n)}},Uint8ClampedBufferAttribute:class extends zi{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}},Uniform:rd,UniformsGroup:class extends ve{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:ad++}),this.name="",this.usage=de,this.uniforms=[]}add(t){return this.uniforms.push(t),this}remove(t){const e=this.uniforms.indexOf(t);return-1!==e&&this.uniforms.splice(e,1),this}setName(t){return this.name=t,this}setUsage(t){return this.usage=t,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(t){this.name=t.name,this.usage=t.usage;const e=t.uniforms;this.uniforms.length=0;for(let t=0,n=e.length;t<n;t++){const n=Array.isArray(e[t])?e[t]:[e[t]];for(let t=0;t<n.length;t++)this.uniforms.push(n[t].clone())}return this}clone(){return(new this.constructor).copy(this)}},UniformsLib:zr,UniformsUtils:xr,UnsignedByteType:J,UnsignedInt248Type:st,UnsignedIntType:et,UnsignedShort4444Type:rt,UnsignedShort5551Type:at,UnsignedShortType:$,VSMShadowMap:g,Vector2:Ie,Vector3:cn,Vector4:en,VectorKeyframeTrack:Yh,VideoTexture:class extends tn{constructor(t,e,n,i,r,a,s,o,l){super(t,e,n,i,r,a,s,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==a?a:q,this.magFilter=void 0!==r?r:q,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){c.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1==="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}},WebGL1Renderer:xo,WebGL3DRenderTarget:class extends rn{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new on(null,t,e,n),this.texture.isRenderTargetTexture=!0}},WebGLArrayRenderTarget:sn,WebGLCoordinateSystem:fe,WebGLCubeRenderTarget:Ar,WebGLMultipleRenderTargets:class extends rn{constructor(t=1,e=1,n=1,i={}){super(t,e,i),this.isWebGLMultipleRenderTargets=!0;const r=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=r.clone(),this.texture[t].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let i=0,r=this.texture.length;i<r;i++)this.texture[i].image.width=t,this.texture[i].image.height=e,this.texture[i].image.depth=n;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}},WebGLRenderTarget:rn,WebGLRenderer:yo,WebGLUtils:ho,WebGPUCoordinateSystem:ge,WireframeGeometry:_h,WrapAroundEnding:Kt,ZeroCurvatureEnding:Zt,ZeroFactor:200,ZeroSlopeEnding:Jt,ZeroStencilOp:0,_SRGBAFormat:me,createCanvasElement:Be,sRGBEncoding:ee});var Dd=Object.freeze({__proto__:null,Water:class extends mr{constructor(t,e={}){super(t),this.isWater=!0;const n=this,i=void 0!==e.textureWidth?e.textureWidth:512,r=void 0!==e.textureHeight?e.textureHeight:512,a=void 0!==e.clipBias?e.clipBias:0,s=void 0!==e.alpha?e.alpha:1,o=void 0!==e.time?e.time:0,l=void 0!==e.waterNormals?e.waterNormals:null,c=void 0!==e.sunDirection?e.sunDirection:new cn(.70707,.70707,0),h=new Ai(void 0!==e.sunColor?e.sunColor:16777215),u=new Ai(void 0!==e.waterColor?e.waterColor:8355711),d=void 0!==e.eye?e.eye:new cn(0,0,0),p=void 0!==e.distortionScale?e.distortionScale:20,m=void 0!==e.side?e.side:v,f=void 0!==e.fog&&e.fog,g=new Ir,_=new cn,y=new cn,x=new cn,b=new zn,w=new cn(0,0,-1),M=new en,S=new cn,T=new cn,E=new en,A=new zn,R=new Mr,C=new rn(i,r),P={name:"MirrorShader",uniforms:xr.merge([zr.fog,zr.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new zn},sunColor:{value:new Ai(8355711)},sunDirection:{value:new cn(.70707,.70707,0)},eye:{value:new cn},waterColor:{value:new Ai(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t\t#include <fog_fragment>\t\n\t\t\t\t}"},I=new br({name:P.name,uniforms:xr.clone(P.uniforms),vertexShader:P.vertexShader,fragmentShader:P.fragmentShader,lights:!0,side:m,fog:f});I.uniforms.mirrorSampler.value=C.texture,I.uniforms.textureMatrix.value=A,I.uniforms.alpha.value=s,I.uniforms.time.value=o,I.uniforms.normalSampler.value=l,I.uniforms.sunColor.value=h,I.uniforms.waterColor.value=u,I.uniforms.sunDirection.value=c,I.uniforms.distortionScale.value=p,I.uniforms.eye.value=d,n.material=I,n.onBeforeRender=function(t,e,i){if(y.setFromMatrixPosition(n.matrixWorld),x.setFromMatrixPosition(i.matrixWorld),b.extractRotation(n.matrixWorld),_.set(0,0,1),_.applyMatrix4(b),S.subVectors(y,x),S.dot(_)>0)return;S.reflect(_).negate(),S.add(y),b.extractRotation(i.matrixWorld),w.set(0,0,-1),w.applyMatrix4(b),w.add(x),T.subVectors(y,w),T.reflect(_).negate(),T.add(y),R.position.copy(S),R.up.set(0,1,0),R.up.applyMatrix4(b),R.up.reflect(_),R.lookAt(T),R.far=i.far,R.updateMatrixWorld(),R.projectionMatrix.copy(i.projectionMatrix),A.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),A.multiply(R.projectionMatrix),A.multiply(R.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(_,y),g.applyMatrix4(R.matrixWorldInverse),M.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const r=R.projectionMatrix;E.x=(Math.sign(M.x)+r.elements[8])/r.elements[0],E.y=(Math.sign(M.y)+r.elements[9])/r.elements[5],E.z=-1,E.w=(1+r.elements[10])/r.elements[14],M.multiplyScalar(2/M.dot(E)),r.elements[2]=M.x,r.elements[6]=M.y,r.elements[10]=M.z+1-a,r.elements[14]=M.w,d.setFromMatrixPosition(i.matrixWorld);const s=t.getRenderTarget(),o=t.xr.enabled,l=t.shadowMap.autoUpdate;n.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(C),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,R),n.visible=!0,t.xr.enabled=o,t.shadowMap.autoUpdate=l,t.setRenderTarget(s);const c=i.viewport;void 0!==c&&t.state.viewport(c)}}}});const Nd=new sd,Od=new cn,Ud=new cn,Fd=new ln,Bd={X:new cn(1,0,0),Y:new cn(0,1,0),Z:new cn(0,0,1)},zd={type:"change"},kd={type:"mouseDown"},Hd={type:"mouseUp",mode:null},Gd={type:"objectChange"};function Vd(t){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:t.button};{const e=this.domElement.getBoundingClientRect();return{x:(t.clientX-e.left)/e.width*2-1,y:-(t.clientY-e.top)/e.height*2+1,button:t.button}}}function Wd(t){if(this.enabled)switch(t.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(t))}}function jd(t){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(t)),this.pointerDown(this._getPointer(t)))}function Xd(t){this.enabled&&this.pointerMove(this._getPointer(t))}function qd(t){this.enabled&&(this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(t)))}function Yd(t,e,n){const i=e.intersectObject(t,!0);for(let t=0;t<i.length;t++)if(i[t].object.visible||n)return i[t];return!1}const Zd=new Zn,Jd=new cn(0,1,0),Kd=new cn(0,0,0),Qd=new zn,$d=new ln,tp=new ln,ep=new cn,np=new zn,ip=new cn(1,0,0),rp=new cn(0,1,0),ap=new cn(0,0,1),sp=new cn,op=new cn,lp=new cn;class cp extends hi{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const t=new Ii({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new Dl({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),n=t.clone();n.opacity=.15;const i=e.clone();i.opacity=.5;const r=t.clone();r.color.setHex(16711680);const a=t.clone();a.color.setHex(65280);const s=t.clone();s.color.setHex(255);const o=t.clone();o.color.setHex(16711680),o.opacity=.5;const l=t.clone();l.color.setHex(65280),l.opacity=.5;const c=t.clone();c.color.setHex(255),c.opacity=.5;const h=t.clone();h.opacity=.25;const u=t.clone();u.color.setHex(16776960),u.opacity=.25;t.clone().color.setHex(16776960);const d=t.clone();d.color.setHex(7895160);const p=new Mc(0,.04,.1,12);p.translate(0,.05,0);const m=new gr(.08,.08,.08);m.translate(0,.04,0);const f=new Ji;f.setAttribute("position",new Gi([0,0,0,1,0,0],3));const g=new Mc(.0075,.0075,.5,3);function v(t,e){const n=new fh(t,.0075,3,64,e*Math.PI*2);return n.rotateY(Math.PI/2),n.rotateX(Math.PI/2),n}g.translate(0,.25,0);const _={X:[[new mr(p,r),[.5,0,0],[0,0,-Math.PI/2]],[new mr(p,r),[-.5,0,0],[0,0,Math.PI/2]],[new mr(g,r),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new mr(p,a),[0,.5,0]],[new mr(p,a),[0,-.5,0],[Math.PI,0,0]],[new mr(g,a)]],Z:[[new mr(p,s),[0,0,.5],[Math.PI/2,0,0]],[new mr(p,s),[0,0,-.5],[-Math.PI/2,0,0]],[new mr(g,s),null,[Math.PI/2,0,0]]],XYZ:[[new mr(new hh(.1,0),h.clone()),[0,0,0]]],XY:[[new mr(new gr(.15,.15,.01),c.clone()),[.15,.15,0]]],YZ:[[new mr(new gr(.15,.15,.01),o.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new mr(new gr(.15,.15,.01),l.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},y={X:[[new mr(new Mc(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new mr(new Mc(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new mr(new Mc(.2,0,.6,4),n),[0,.3,0]],[new mr(new Mc(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new mr(new Mc(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new mr(new Mc(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new mr(new hh(.2,0),n)]],XY:[[new mr(new gr(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new mr(new gr(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new mr(new gr(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]]},x={START:[[new mr(new hh(.01,2),i),null,null,null,"helper"]],END:[[new mr(new hh(.01,2),i),null,null,null,"helper"]],DELTA:[[new zl(function(){const t=new Ji;return t.setAttribute("position",new Gi([0,0,0,1,1,1],3)),t}(),i),null,null,null,"helper"]],X:[[new zl(f,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new zl(f,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new zl(f,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},b={XYZE:[[new mr(v(.5,1),d),null,[0,Math.PI/2,0]]],X:[[new mr(v(.5,.5),r)]],Y:[[new mr(v(.5,.5),a),null,[0,0,-Math.PI/2]]],Z:[[new mr(v(.5,.5),s),null,[0,Math.PI/2,0]]],E:[[new mr(v(.75,1),u),null,[0,Math.PI/2,0]]]},w={AXIS:[[new zl(f,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},M={XYZE:[[new mr(new ph(.25,10,8),n)]],X:[[new mr(new fh(.5,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new mr(new fh(.5,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new mr(new fh(.5,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new mr(new fh(.75,.1,2,24),n)]]},S={X:[[new mr(m,r),[.5,0,0],[0,0,-Math.PI/2]],[new mr(g,r),[0,0,0],[0,0,-Math.PI/2]],[new mr(m,r),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new mr(m,a),[0,.5,0]],[new mr(g,a)],[new mr(m,a),[0,-.5,0],[0,0,Math.PI]]],Z:[[new mr(m,s),[0,0,.5],[Math.PI/2,0,0]],[new mr(g,s),[0,0,0],[Math.PI/2,0,0]],[new mr(m,s),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new mr(new gr(.15,.15,.01),c),[.15,.15,0]]],YZ:[[new mr(new gr(.15,.15,.01),o),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new mr(new gr(.15,.15,.01),l),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new mr(new gr(.1,.1,.1),h.clone())]]},T={X:[[new mr(new Mc(.2,0,.6,4),n),[.3,0,0],[0,0,-Math.PI/2]],[new mr(new Mc(.2,0,.6,4),n),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new mr(new Mc(.2,0,.6,4),n),[0,.3,0]],[new mr(new Mc(.2,0,.6,4),n),[0,-.3,0],[0,0,Math.PI]]],Z:[[new mr(new Mc(.2,0,.6,4),n),[0,0,.3],[Math.PI/2,0,0]],[new mr(new Mc(.2,0,.6,4),n),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new mr(new gr(.2,.2,.01),n),[.15,.15,0]]],YZ:[[new mr(new gr(.2,.2,.01),n),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new mr(new gr(.2,.2,.01),n),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new mr(new gr(.2,.2,.2),n),[0,0,0]]]},E={X:[[new zl(f,i.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new zl(f,i.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new zl(f,i.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function A(t){const e=new hi;for(const n in t)for(let i=t[n].length;i--;){const r=t[n][i][0].clone(),a=t[n][i][1],s=t[n][i][2],o=t[n][i][3],l=t[n][i][4];r.name=n,r.tag=l,a&&r.position.set(a[0],a[1],a[2]),s&&r.rotation.set(s[0],s[1],s[2]),o&&r.scale.set(o[0],o[1],o[2]),r.updateMatrix();const c=r.geometry.clone();c.applyMatrix4(r.matrix),r.geometry=c,r.renderOrder=1/0,r.position.set(0,0,0),r.rotation.set(0,0,0),r.scale.set(1,1,1),e.add(r)}return e}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=A(_)),this.add(this.gizmo.rotate=A(b)),this.add(this.gizmo.scale=A(S)),this.add(this.picker.translate=A(y)),this.add(this.picker.rotate=A(M)),this.add(this.picker.scale=A(T)),this.add(this.helper.translate=A(x)),this.add(this.helper.rotate=A(w)),this.add(this.helper.scale=A(E)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const e="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:tp;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let t=0;t<n.length;t++){const i=n[t];let r;if(i.visible=!0,i.rotation.set(0,0,0),i.position.copy(this.worldPosition),r=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),i.scale.set(1,1,1).multiplyScalar(r*this.size/4),"helper"!==i.tag){if(i.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const t=.99,n=.2;"X"===i.name&&Math.abs(Jd.copy(ip).applyQuaternion(e).dot(this.eye))>t&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),"Y"===i.name&&Math.abs(Jd.copy(rp).applyQuaternion(e).dot(this.eye))>t&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),"Z"===i.name&&Math.abs(Jd.copy(ap).applyQuaternion(e).dot(this.eye))>t&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),"XY"===i.name&&Math.abs(Jd.copy(ap).applyQuaternion(e).dot(this.eye))<n&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),"YZ"===i.name&&Math.abs(Jd.copy(ip).applyQuaternion(e).dot(this.eye))<n&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1),"XZ"===i.name&&Math.abs(Jd.copy(rp).applyQuaternion(e).dot(this.eye))<n&&(i.scale.set(1e-10,1e-10,1e-10),i.visible=!1)}else"rotate"===this.mode&&($d.copy(e),Jd.copy(this.eye).applyQuaternion(Fd.copy(e).invert()),-1!==i.name.search("E")&&i.quaternion.setFromRotationMatrix(Qd.lookAt(this.eye,Kd,rp)),"X"===i.name&&(Fd.setFromAxisAngle(ip,Math.atan2(-Jd.y,Jd.z)),Fd.multiplyQuaternions($d,Fd),i.quaternion.copy(Fd)),"Y"===i.name&&(Fd.setFromAxisAngle(rp,Math.atan2(Jd.x,Jd.z)),Fd.multiplyQuaternions($d,Fd),i.quaternion.copy(Fd)),"Z"===i.name&&(Fd.setFromAxisAngle(ap,Math.atan2(Jd.y,Jd.x)),Fd.multiplyQuaternions($d,Fd),i.quaternion.copy(Fd)));i.visible=i.visible&&(-1===i.name.indexOf("X")||this.showX),i.visible=i.visible&&(-1===i.name.indexOf("Y")||this.showY),i.visible=i.visible&&(-1===i.name.indexOf("Z")||this.showZ),i.visible=i.visible&&(-1===i.name.indexOf("E")||this.showX&&this.showY&&this.showZ),i.material._color=i.material._color||i.material.color.clone(),i.material._opacity=i.material._opacity||i.material.opacity,i.material.color.copy(i.material._color),i.material.opacity=i.material._opacity,this.enabled&&this.axis&&(i.name===this.axis||this.axis.split("").some((function(t){return i.name===t})))&&(i.material.color.setHex(16776960),i.material.opacity=1)}else i.visible=!1,"AXIS"===i.name?(i.visible=!!this.axis,"X"===this.axis&&(Fd.setFromEuler(Zd.set(0,0,0)),i.quaternion.copy(e).multiply(Fd),Math.abs(Jd.copy(ip).applyQuaternion(e).dot(this.eye))>.9&&(i.visible=!1)),"Y"===this.axis&&(Fd.setFromEuler(Zd.set(0,0,Math.PI/2)),i.quaternion.copy(e).multiply(Fd),Math.abs(Jd.copy(rp).applyQuaternion(e).dot(this.eye))>.9&&(i.visible=!1)),"Z"===this.axis&&(Fd.setFromEuler(Zd.set(0,Math.PI/2,0)),i.quaternion.copy(e).multiply(Fd),Math.abs(Jd.copy(ap).applyQuaternion(e).dot(this.eye))>.9&&(i.visible=!1)),"XYZE"===this.axis&&(Fd.setFromEuler(Zd.set(0,Math.PI/2,0)),Jd.copy(this.rotationAxis),i.quaternion.setFromRotationMatrix(Qd.lookAt(Kd,Jd,rp)),i.quaternion.multiply(Fd),i.visible=this.dragging),"E"===this.axis&&(i.visible=!1)):"START"===i.name?(i.position.copy(this.worldPositionStart),i.visible=this.dragging):"END"===i.name?(i.position.copy(this.worldPosition),i.visible=this.dragging):"DELTA"===i.name?(i.position.copy(this.worldPositionStart),i.quaternion.copy(this.worldQuaternionStart),Od.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),Od.applyQuaternion(this.worldQuaternionStart.clone().invert()),i.scale.copy(Od),i.visible=this.dragging):(i.quaternion.copy(e),this.dragging?i.position.copy(this.worldPositionStart):i.position.copy(this.worldPosition),this.axis&&(i.visible=-1!==this.axis.search(i.name)))}super.updateMatrixWorld(t)}}class hp extends mr{constructor(){super(new Fr(1e5,1e5,2,2),new Ii({visible:!1,wireframe:!0,side:y,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(e="local"),sp.copy(ip).applyQuaternion("local"===e?this.worldQuaternion:tp),op.copy(rp).applyQuaternion("local"===e?this.worldQuaternion:tp),lp.copy(ap).applyQuaternion("local"===e?this.worldQuaternion:tp),Jd.copy(op),this.mode){case"translate":case"scale":switch(this.axis){case"X":Jd.copy(this.eye).cross(sp),ep.copy(sp).cross(Jd);break;case"Y":Jd.copy(this.eye).cross(op),ep.copy(op).cross(Jd);break;case"Z":Jd.copy(this.eye).cross(lp),ep.copy(lp).cross(Jd);break;case"XY":ep.copy(lp);break;case"YZ":ep.copy(sp);break;case"XZ":Jd.copy(lp),ep.copy(op);break;case"XYZ":case"E":ep.set(0,0,0)}break;default:ep.set(0,0,0)}0===ep.length()?this.quaternion.copy(this.cameraQuaternion):(np.lookAt(Od.set(0,0,0),ep,Jd),this.quaternion.setFromRotationMatrix(np)),super.updateMatrixWorld(t)}}var up=Object.freeze({__proto__:null,TransformControls:class extends hi{constructor(t,e){super(),void 0===e&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.isTransformControls=!0,this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const n=new cp;this._gizmo=n,this.add(n);const i=new hp;this._plane=i,this.add(i);const r=this;function a(t,e){let a=e;Object.defineProperty(r,t,{get:function(){return void 0!==a?a:e},set:function(e){a!==e&&(a=e,i[t]=e,n[t]=e,r.dispatchEvent({type:t+"-changed",value:e}),r.dispatchEvent(zd))}}),r[t]=e,i[t]=e,n[t]=e}a("camera",t),a("object",void 0),a("enabled",!0),a("axis",null),a("mode","translate"),a("translationSnap",null),a("rotationSnap",null),a("scaleSnap",null),a("space","world"),a("size",1),a("dragging",!1),a("showX",!0),a("showY",!0),a("showZ",!0);const s=new cn,o=new cn,l=new ln,c=new ln,h=new cn,u=new ln,d=new cn,p=new cn,m=new cn,f=new cn;a("worldPosition",s),a("worldPositionStart",o),a("worldQuaternion",l),a("worldQuaternionStart",c),a("cameraPosition",h),a("cameraQuaternion",u),a("pointStart",d),a("pointEnd",p),a("rotationAxis",m),a("rotationAngle",0),a("eye",f),this._offset=new cn,this._startNorm=new cn,this._endNorm=new cn,this._cameraScale=new cn,this._parentPosition=new cn,this._parentQuaternion=new ln,this._parentQuaternionInv=new ln,this._parentScale=new cn,this._worldScaleStart=new cn,this._worldQuaternionInv=new ln,this._worldScale=new cn,this._positionStart=new cn,this._quaternionStart=new ln,this._scaleStart=new cn,this._getPointer=Vd.bind(this),this._onPointerDown=jd.bind(this),this._onPointerHover=Wd.bind(this),this._onPointerMove=Xd.bind(this),this._onPointerUp=qd.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.camera.isOrthographicCamera?this.camera.getWorldDirection(this.eye).negate():this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(void 0===this.object||!0===this.dragging)return;Nd.setFromCamera(t,this.camera);const e=Yd(this._gizmo.picker[this.mode],Nd);this.axis=e?e.object.name:null}pointerDown(t){if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){Nd.setFromCamera(t,this.camera);const e=Yd(this._plane,Nd,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,kd.mode=this.mode,this.dispatchEvent(kd)}}pointerMove(t){const e=this.axis,n=this.mode,i=this.object;let r=this.space;if("scale"===n?r="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(r="world"),void 0===i||null===e||!1===this.dragging||-1!==t.button)return;Nd.setFromCamera(t,this.camera);const a=Yd(this._plane,Nd,!0);if(a){if(this.pointEnd.copy(a.point).sub(this.worldPositionStart),"translate"===n)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===r&&"XYZ"!==e&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===e.indexOf("X")&&(this._offset.x=0),-1===e.indexOf("Y")&&(this._offset.y=0),-1===e.indexOf("Z")&&(this._offset.z=0),"local"===r&&"XYZ"!==e?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),i.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===r&&(i.position.applyQuaternion(Fd.copy(this._quaternionStart).invert()),-1!==e.search("X")&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.position.applyQuaternion(this._quaternionStart)),"world"===r&&(i.parent&&i.position.add(Od.setFromMatrixPosition(i.parent.matrixWorld)),-1!==e.search("X")&&(i.position.x=Math.round(i.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(i.position.y=Math.round(i.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(i.position.z=Math.round(i.position.z/this.translationSnap)*this.translationSnap),i.parent&&i.position.sub(Od.setFromMatrixPosition(i.parent.matrixWorld))));else if("scale"===n){if(-1!==e.search("XYZ")){let t=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(t*=-1),Ud.set(t,t,t)}else Od.copy(this.pointStart),Ud.copy(this.pointEnd),Od.applyQuaternion(this._worldQuaternionInv),Ud.applyQuaternion(this._worldQuaternionInv),Ud.divide(Od),-1===e.search("X")&&(Ud.x=1),-1===e.search("Y")&&(Ud.y=1),-1===e.search("Z")&&(Ud.z=1);i.scale.copy(this._scaleStart).multiply(Ud),this.scaleSnap&&(-1!==e.search("X")&&(i.scale.x=Math.round(i.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(i.scale.y=Math.round(i.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(i.scale.z=Math.round(i.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===n){this._offset.copy(this.pointEnd).sub(this.pointStart);const t=20/this.worldPosition.distanceTo(Od.setFromMatrixPosition(this.camera.matrixWorld));let n=!1;"XYZE"===e?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(Od.copy(this.rotationAxis).cross(this.eye))*t):"X"!==e&&"Y"!==e&&"Z"!==e||(this.rotationAxis.copy(Bd[e]),Od.copy(Bd[e]),"local"===r&&Od.applyQuaternion(this.worldQuaternion),Od.cross(this.eye),0===Od.length()?n=!0:this.rotationAngle=this._offset.dot(Od.normalize())*t),("E"===e||n)&&(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===r&&"E"!==e&&"XYZE"!==e?(i.quaternion.copy(this._quaternionStart),i.quaternion.multiply(Fd.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),i.quaternion.copy(Fd.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),i.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(zd),this.dispatchEvent(Gd)}}pointerUp(t){0===t.button&&(this.dragging&&null!==this.axis&&(Hd.mode=this.mode,this.dispatchEvent(Hd)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}))}attach(t){return this.object=t,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(zd),this.dispatchEvent(Gd),this.pointStart.copy(this.pointEnd))}getRaycaster(){return Nd}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}},TransformControlsGizmo:cp,TransformControlsPlane:hp});const dp={type:"change"},pp={type:"start"},mp={type:"end"},fp=new Bn,gp=new Ir,vp=Math.cos(70*Pe.DEG2RAD);var _p=Object.freeze({__proto__:null,OrbitControls:class extends ve{constructor(t,e){super(),this.object=t,this.domElement=e,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new cn,this.cursor=new cn,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:d.ROTATE,MIDDLE:d.DOLLY,RIGHT:d.PAN},this.touches={ONE:p.ROTATE,TWO:p.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return s.phi},this.getAzimuthalAngle=function(){return s.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",Y),this._domElementKeyEvents=t},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Y),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(dp),n.update(),r=i.NONE},this.update=function(){const e=new cn,h=(new ln).setFromUnitVectors(t.up,new cn(0,1,0)),u=h.clone().invert(),d=new cn,p=new ln,m=new cn,f=2*Math.PI;return function(g=null){const v=n.object.position;e.copy(v).sub(n.target),e.applyQuaternion(h),s.setFromVector3(e),n.autoRotate&&r===i.NONE&&A(function(t){return null!==t?2*Math.PI/60*n.autoRotateSpeed*t:2*Math.PI/60/60*n.autoRotateSpeed}(g)),n.enableDamping?(s.theta+=o.theta*n.dampingFactor,s.phi+=o.phi*n.dampingFactor):(s.theta+=o.theta,s.phi+=o.phi);let _=n.minAzimuthAngle,y=n.maxAzimuthAngle;isFinite(_)&&isFinite(y)&&(_<-Math.PI?_+=f:_>Math.PI&&(_-=f),y<-Math.PI?y+=f:y>Math.PI&&(y-=f),s.theta=_<=y?Math.max(_,Math.min(y,s.theta)):s.theta>(_+y)/2?Math.max(_,s.theta):Math.min(y,s.theta)),s.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,s.phi)),s.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(c,n.dampingFactor):n.target.add(c),n.target.sub(n.cursor),n.target.clampLength(n.minTargetRadius,n.maxTargetRadius),n.target.add(n.cursor),n.zoomToCursor&&M||n.object.isOrthographicCamera?s.radius=O(s.radius):s.radius=O(s.radius*l),e.setFromSpherical(s),e.applyQuaternion(u),v.copy(n.target).add(e),n.object.lookAt(n.target),!0===n.enableDamping?(o.theta*=1-n.dampingFactor,o.phi*=1-n.dampingFactor,c.multiplyScalar(1-n.dampingFactor)):(o.set(0,0,0),c.set(0,0,0));let x=!1;if(n.zoomToCursor&&M){let i=null;if(n.object.isPerspectiveCamera){const t=e.length();i=O(t*l);const r=t-i;n.object.position.addScaledVector(b,r),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const t=new cn(w.x,w.y,0);t.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/l)),n.object.updateProjectionMatrix(),x=!0;const r=new cn(w.x,w.y,0);r.unproject(n.object),n.object.position.sub(r).add(t),n.object.updateMatrixWorld(),i=e.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==i&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(i).add(n.object.position):(fp.origin.copy(n.object.position),fp.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(fp.direction))<vp?t.lookAt(n.target):(gp.setFromNormalAndCoplanarPoint(n.object.up,n.target),fp.intersectPlane(gp,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/l)),n.object.updateProjectionMatrix(),x=!0);return l=1,M=!1,!!(x||d.distanceToSquared(n.object.position)>a||8*(1-p.dot(n.object.quaternion))>a||m.distanceToSquared(n.target)>0)&&(n.dispatchEvent(dp),d.copy(n.object.position),p.copy(n.object.quaternion),m.copy(n.target),!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",Z),n.domElement.removeEventListener("pointerdown",W),n.domElement.removeEventListener("pointercancel",X),n.domElement.removeEventListener("wheel",q),n.domElement.removeEventListener("pointermove",j),n.domElement.removeEventListener("pointerup",X),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",Y),n._domElementKeyEvents=null)};const n=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=i.NONE;const a=1e-6,s=new cd,o=new cd;let l=1;const c=new cn,h=new Ie,u=new Ie,m=new Ie,f=new Ie,g=new Ie,v=new Ie,_=new Ie,y=new Ie,x=new Ie,b=new cn,w=new Ie;let M=!1;const S=[],T={};function E(t){const e=Math.abs(t)/(100*(0|window.devicePixelRatio));return Math.pow(.95,n.zoomSpeed*e)}function A(t){o.theta-=t}function R(t){o.phi-=t}const C=function(){const t=new cn;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),c.add(t)}}(),P=function(){const t=new cn;return function(e,i){!0===n.screenSpacePanning?t.setFromMatrixColumn(i,1):(t.setFromMatrixColumn(i,0),t.crossVectors(n.object.up,t)),t.multiplyScalar(e),c.add(t)}}(),I=function(){const t=new cn;return function(e,i){const r=n.domElement;if(n.object.isPerspectiveCamera){const a=n.object.position;t.copy(a).sub(n.target);let s=t.length();s*=Math.tan(n.object.fov/2*Math.PI/180),C(2*e*s/r.clientHeight,n.object.matrix),P(2*i*s/r.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(C(e*(n.object.right-n.object.left)/n.object.zoom/r.clientWidth,n.object.matrix),P(i*(n.object.top-n.object.bottom)/n.object.zoom/r.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function L(t){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?l/=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function D(t){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?l*=t:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function N(t,e){if(!n.zoomToCursor)return;M=!0;const i=n.domElement.getBoundingClientRect(),r=t-i.left,a=e-i.top,s=i.width,o=i.height;w.x=r/s*2-1,w.y=-a/o*2+1,b.set(w.x,w.y,1).unproject(n.object).sub(n.object.position).normalize()}function O(t){return Math.max(n.minDistance,Math.min(n.maxDistance,t))}function U(t){h.set(t.clientX,t.clientY)}function F(t){f.set(t.clientX,t.clientY)}function B(t){if(1===S.length)h.set(t.pageX,t.pageY);else{const e=K(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);h.set(n,i)}}function z(t){if(1===S.length)f.set(t.pageX,t.pageY);else{const e=K(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);f.set(n,i)}}function k(t){const e=K(t),n=t.pageX-e.x,i=t.pageY-e.y,r=Math.sqrt(n*n+i*i);_.set(0,r)}function H(t){if(1==S.length)u.set(t.pageX,t.pageY);else{const e=K(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);u.set(n,i)}m.subVectors(u,h).multiplyScalar(n.rotateSpeed);const e=n.domElement;A(2*Math.PI*m.x/e.clientHeight),R(2*Math.PI*m.y/e.clientHeight),h.copy(u)}function G(t){if(1===S.length)g.set(t.pageX,t.pageY);else{const e=K(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);g.set(n,i)}v.subVectors(g,f).multiplyScalar(n.panSpeed),I(v.x,v.y),f.copy(g)}function V(t){const e=K(t),i=t.pageX-e.x,r=t.pageY-e.y,a=Math.sqrt(i*i+r*r);y.set(0,a),x.set(0,Math.pow(y.y/_.y,n.zoomSpeed)),L(x.y),_.copy(y);N(.5*(t.pageX+e.x),.5*(t.pageY+e.y))}function W(t){!1!==n.enabled&&(0===S.length&&(n.domElement.setPointerCapture(t.pointerId),n.domElement.addEventListener("pointermove",j),n.domElement.addEventListener("pointerup",X)),function(t){S.push(t.pointerId)}(t),"touch"===t.pointerType?function(t){switch(J(t),S.length){case 1:switch(n.touches.ONE){case p.ROTATE:if(!1===n.enableRotate)return;B(t),r=i.TOUCH_ROTATE;break;case p.PAN:if(!1===n.enablePan)return;z(t),r=i.TOUCH_PAN;break;default:r=i.NONE}break;case 2:switch(n.touches.TWO){case p.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&k(t),n.enablePan&&z(t)}(t),r=i.TOUCH_DOLLY_PAN;break;case p.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&k(t),n.enableRotate&&B(t)}(t),r=i.TOUCH_DOLLY_ROTATE;break;default:r=i.NONE}break;default:r=i.NONE}r!==i.NONE&&n.dispatchEvent(pp)}(t):function(t){let e;switch(t.button){case 0:e=n.mouseButtons.LEFT;break;case 1:e=n.mouseButtons.MIDDLE;break;case 2:e=n.mouseButtons.RIGHT;break;default:e=-1}switch(e){case d.DOLLY:if(!1===n.enableZoom)return;!function(t){N(t.clientX,t.clientX),_.set(t.clientX,t.clientY)}(t),r=i.DOLLY;break;case d.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enablePan)return;F(t),r=i.PAN}else{if(!1===n.enableRotate)return;U(t),r=i.ROTATE}break;case d.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===n.enableRotate)return;U(t),r=i.ROTATE}else{if(!1===n.enablePan)return;F(t),r=i.PAN}break;default:r=i.NONE}r!==i.NONE&&n.dispatchEvent(pp)}(t))}function j(t){!1!==n.enabled&&("touch"===t.pointerType?function(t){switch(J(t),r){case i.TOUCH_ROTATE:if(!1===n.enableRotate)return;H(t),n.update();break;case i.TOUCH_PAN:if(!1===n.enablePan)return;G(t),n.update();break;case i.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(t){n.enableZoom&&V(t),n.enablePan&&G(t)}(t),n.update();break;case i.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(t){n.enableZoom&&V(t),n.enableRotate&&H(t)}(t),n.update();break;default:r=i.NONE}}(t):function(t){switch(r){case i.ROTATE:if(!1===n.enableRotate)return;!function(t){u.set(t.clientX,t.clientY),m.subVectors(u,h).multiplyScalar(n.rotateSpeed);const e=n.domElement;A(2*Math.PI*m.x/e.clientHeight),R(2*Math.PI*m.y/e.clientHeight),h.copy(u),n.update()}(t);break;case i.DOLLY:if(!1===n.enableZoom)return;!function(t){y.set(t.clientX,t.clientY),x.subVectors(y,_),x.y>0?L(E(x.y)):x.y<0&&D(E(x.y)),_.copy(y),n.update()}(t);break;case i.PAN:if(!1===n.enablePan)return;!function(t){g.set(t.clientX,t.clientY),v.subVectors(g,f).multiplyScalar(n.panSpeed),I(v.x,v.y),f.copy(g),n.update()}(t)}}(t))}function X(t){!function(t){delete T[t.pointerId];for(let e=0;e<S.length;e++)if(S[e]==t.pointerId)return void S.splice(e,1)}(t),0===S.length&&(n.domElement.releasePointerCapture(t.pointerId),n.domElement.removeEventListener("pointermove",j),n.domElement.removeEventListener("pointerup",X)),n.dispatchEvent(mp),r=i.NONE}function q(t){!1!==n.enabled&&!1!==n.enableZoom&&r===i.NONE&&(t.preventDefault(),n.dispatchEvent(pp),function(t){N(t.clientX,t.clientY),t.deltaY<0?D(E(t.deltaY)):t.deltaY>0&&L(E(t.deltaY)),n.update()}(t),n.dispatchEvent(mp))}function Y(t){!1!==n.enabled&&!1!==n.enablePan&&function(t){let e=!1;switch(t.code){case n.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?R(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):I(0,n.keyPanSpeed),e=!0;break;case n.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?R(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):I(0,-n.keyPanSpeed),e=!0;break;case n.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?A(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):I(n.keyPanSpeed,0),e=!0;break;case n.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?A(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):I(-n.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),n.update())}(t)}function Z(t){!1!==n.enabled&&t.preventDefault()}function J(t){let e=T[t.pointerId];void 0===e&&(e=new Ie,T[t.pointerId]=e),e.set(t.pageX,t.pageY)}function K(t){const e=t.pointerId===S[0]?S[1]:S[0];return T[e]}n.domElement.addEventListener("contextmenu",Z),n.domElement.addEventListener("pointerdown",W),n.domElement.addEventListener("pointercancel",X),n.domElement.addEventListener("wheel",q,{passive:!1}),this.update()}}});function yp(t,e){var n=t.__state.conversionName.toString(),i=Math.round(t.r),r=Math.round(t.g),a=Math.round(t.b),s=t.a,o=Math.round(t.h),l=t.s.toFixed(1),c=t.v.toFixed(1);if(e||"THREE_CHAR_HEX"===n||"SIX_CHAR_HEX"===n){for(var h=t.hex.toString(16);h.length<6;)h="0"+h;return"#"+h}return"CSS_RGB"===n?"rgb("+i+","+r+","+a+")":"CSS_RGBA"===n?"rgba("+i+","+r+","+a+","+s+")":"HEX"===n?"0x"+t.hex.toString(16):"RGB_ARRAY"===n?"["+i+","+r+","+a+"]":"RGBA_ARRAY"===n?"["+i+","+r+","+a+","+s+"]":"RGB_OBJ"===n?"{r:"+i+",g:"+r+",b:"+a+"}":"RGBA_OBJ"===n?"{r:"+i+",g:"+r+",b:"+a+",a:"+s+"}":"HSV_OBJ"===n?"{h:"+o+",s:"+l+",v:"+c+"}":"HSVA_OBJ"===n?"{h:"+o+",s:"+l+",v:"+c+",a:"+s+"}":"unknown format"}var xp=Array.prototype.forEach,bp=Array.prototype.slice,wp={BREAK:{},extend:function(t){return this.each(bp.call(arguments,1),(function(e){(this.isObject(e)?Object.keys(e):[]).forEach(function(n){this.isUndefined(e[n])||(t[n]=e[n])}.bind(this))}),this),t},defaults:function(t){return this.each(bp.call(arguments,1),(function(e){(this.isObject(e)?Object.keys(e):[]).forEach(function(n){this.isUndefined(t[n])&&(t[n]=e[n])}.bind(this))}),this),t},compose:function(){var t=bp.call(arguments);return function(){for(var e=bp.call(arguments),n=t.length-1;n>=0;n--)e=[t[n].apply(this,e)];return e[0]}},each:function(t,e,n){if(t)if(xp&&t.forEach&&t.forEach===xp)t.forEach(e,n);else if(t.length===t.length+0){var i,r=void 0;for(r=0,i=t.length;r<i;r++)if(r in t&&e.call(n,t[r],r)===this.BREAK)return}else for(var a in t)if(e.call(n,t[a],a)===this.BREAK)return},defer:function(t){setTimeout(t,0)},debounce:function(t,e,n){var i=void 0;return function(){var r=this,a=arguments;var s=n||!i;clearTimeout(i),i=setTimeout((function(){i=null,n||t.apply(r,a)}),e),s&&t.apply(r,a)}},toArray:function(t){return t.toArray?t.toArray():bp.call(t)},isUndefined:function(t){return void 0===t},isNull:function(t){return null===t},isNaN:function(t){function e(e){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}((function(t){return isNaN(t)})),isArray:Array.isArray||function(t){return t.constructor===Array},isObject:function(t){return t===Object(t)},isNumber:function(t){return t===t+0},isString:function(t){return t===t+""},isBoolean:function(t){return!1===t||!0===t},isFunction:function(t){return t instanceof Function}},Mp=[{litmus:wp.isString,conversions:{THREE_CHAR_HEX:{read:function(t){var e=t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);return null!==e&&{space:"HEX",hex:parseInt("0x"+e[1].toString()+e[1].toString()+e[2].toString()+e[2].toString()+e[3].toString()+e[3].toString(),0)}},write:yp},SIX_CHAR_HEX:{read:function(t){var e=t.match(/^#([A-F0-9]{6})$/i);return null!==e&&{space:"HEX",hex:parseInt("0x"+e[1].toString(),0)}},write:yp},CSS_RGB:{read:function(t){var e=t.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return null!==e&&{space:"RGB",r:parseFloat(e[1]),g:parseFloat(e[2]),b:parseFloat(e[3])}},write:yp},CSS_RGBA:{read:function(t){var e=t.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);return null!==e&&{space:"RGB",r:parseFloat(e[1]),g:parseFloat(e[2]),b:parseFloat(e[3]),a:parseFloat(e[4])}},write:yp}}},{litmus:wp.isNumber,conversions:{HEX:{read:function(t){return{space:"HEX",hex:t,conversionName:"HEX"}},write:function(t){return t.hex}}}},{litmus:wp.isArray,conversions:{RGB_ARRAY:{read:function(t){return 3===t.length&&{space:"RGB",r:t[0],g:t[1],b:t[2]}},write:function(t){return[t.r,t.g,t.b]}},RGBA_ARRAY:{read:function(t){return 4===t.length&&{space:"RGB",r:t[0],g:t[1],b:t[2],a:t[3]}},write:function(t){return[t.r,t.g,t.b,t.a]}}}},{litmus:wp.isObject,conversions:{RGBA_OBJ:{read:function(t){return!!(wp.isNumber(t.r)&&wp.isNumber(t.g)&&wp.isNumber(t.b)&&wp.isNumber(t.a))&&{space:"RGB",r:t.r,g:t.g,b:t.b,a:t.a}},write:function(t){return{r:t.r,g:t.g,b:t.b,a:t.a}}},RGB_OBJ:{read:function(t){return!!(wp.isNumber(t.r)&&wp.isNumber(t.g)&&wp.isNumber(t.b))&&{space:"RGB",r:t.r,g:t.g,b:t.b}},write:function(t){return{r:t.r,g:t.g,b:t.b}}},HSVA_OBJ:{read:function(t){return!!(wp.isNumber(t.h)&&wp.isNumber(t.s)&&wp.isNumber(t.v)&&wp.isNumber(t.a))&&{space:"HSV",h:t.h,s:t.s,v:t.v,a:t.a}},write:function(t){return{h:t.h,s:t.s,v:t.v,a:t.a}}},HSV_OBJ:{read:function(t){return!!(wp.isNumber(t.h)&&wp.isNumber(t.s)&&wp.isNumber(t.v))&&{space:"HSV",h:t.h,s:t.s,v:t.v}},write:function(t){return{h:t.h,s:t.s,v:t.v}}}}}],Sp=void 0,Tp=void 0,Ep=function(){Tp=!1;var t=arguments.length>1?wp.toArray(arguments):arguments[0];return wp.each(Mp,(function(e){if(e.litmus(t))return wp.each(e.conversions,(function(e,n){if(Sp=e.read(t),!1===Tp&&!1!==Sp)return Tp=Sp,Sp.conversionName=n,Sp.conversion=e,wp.BREAK})),wp.BREAK})),Tp},Ap=void 0,Rp={hsv_to_rgb:function(t,e,n){var i=Math.floor(t/60)%6,r=t/60-Math.floor(t/60),a=n*(1-e),s=n*(1-r*e),o=n*(1-(1-r)*e),l=[[n,o,a],[s,n,a],[a,n,o],[a,s,n],[o,a,n],[n,a,s]][i];return{r:255*l[0],g:255*l[1],b:255*l[2]}},rgb_to_hsv:function(t,e,n){var i=Math.min(t,e,n),r=Math.max(t,e,n),a=r-i,s=void 0;return 0===r?{h:NaN,s:0,v:0}:(s=t===r?(e-n)/a:e===r?2+(n-t)/a:4+(t-e)/a,(s/=6)<0&&(s+=1),{h:360*s,s:a/r,v:r/255})},rgb_to_hex:function(t,e,n){var i=this.hex_with_component(0,2,t);return i=this.hex_with_component(i,1,e),i=this.hex_with_component(i,0,n)},component_from_hex:function(t,e){return t>>8*e&255},hex_with_component:function(t,e,n){return n<<(Ap=8*e)|t&~(255<<Ap)}},Cp="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},Pp=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},Ip=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),Lp=function t(e,n,i){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,n);if(void 0===r){var a=Object.getPrototypeOf(e);return null===a?void 0:t(a,n,i)}if("value"in r)return r.value;var s=r.get;return void 0!==s?s.call(i):void 0},Dp=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},Np=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e},Op=function(){function t(){if(Pp(this,t),this.__state=Ep.apply(this,arguments),!1===this.__state)throw new Error("Failed to interpret color arguments");this.__state.a=this.__state.a||1}return Ip(t,[{key:"toString",value:function(){return yp(this)}},{key:"toHexString",value:function(){return yp(this,!0)}},{key:"toOriginal",value:function(){return this.__state.conversion.write(this)}}]),t}();function Up(t,e,n){Object.defineProperty(t,e,{get:function(){return"RGB"===this.__state.space||Op.recalculateRGB(this,e,n),this.__state[e]},set:function(t){"RGB"!==this.__state.space&&(Op.recalculateRGB(this,e,n),this.__state.space="RGB"),this.__state[e]=t}})}function Fp(t,e){Object.defineProperty(t,e,{get:function(){return"HSV"===this.__state.space||Op.recalculateHSV(this),this.__state[e]},set:function(t){"HSV"!==this.__state.space&&(Op.recalculateHSV(this),this.__state.space="HSV"),this.__state[e]=t}})}Op.recalculateRGB=function(t,e,n){if("HEX"===t.__state.space)t.__state[e]=Rp.component_from_hex(t.__state.hex,n);else{if("HSV"!==t.__state.space)throw new Error("Corrupted color state");wp.extend(t.__state,Rp.hsv_to_rgb(t.__state.h,t.__state.s,t.__state.v))}},Op.recalculateHSV=function(t){var e=Rp.rgb_to_hsv(t.r,t.g,t.b);wp.extend(t.__state,{s:e.s,v:e.v}),wp.isNaN(e.h)?wp.isUndefined(t.__state.h)&&(t.__state.h=0):t.__state.h=e.h},Op.COMPONENTS=["r","g","b","h","s","v","hex","a"],Up(Op.prototype,"r",2),Up(Op.prototype,"g",1),Up(Op.prototype,"b",0),Fp(Op.prototype,"h"),Fp(Op.prototype,"s"),Fp(Op.prototype,"v"),Object.defineProperty(Op.prototype,"a",{get:function(){return this.__state.a},set:function(t){this.__state.a=t}}),Object.defineProperty(Op.prototype,"hex",{get:function(){return"HEX"!==this.__state.space&&(this.__state.hex=Rp.rgb_to_hex(this.r,this.g,this.b),this.__state.space="HEX"),this.__state.hex},set:function(t){this.__state.space="HEX",this.__state.hex=t}});var Bp=function(){function t(e,n){Pp(this,t),this.initialValue=e[n],this.domElement=document.createElement("div"),this.object=e,this.property=n,this.__onChange=void 0,this.__onFinishChange=void 0}return Ip(t,[{key:"onChange",value:function(t){return this.__onChange=t,this}},{key:"onFinishChange",value:function(t){return this.__onFinishChange=t,this}},{key:"setValue",value:function(t){return this.object[this.property]=t,this.__onChange&&this.__onChange.call(this,t),this.updateDisplay(),this}},{key:"getValue",value:function(){return this.object[this.property]}},{key:"updateDisplay",value:function(){return this}},{key:"isModified",value:function(){return this.initialValue!==this.getValue()}}]),t}(),zp={};wp.each({HTMLEvents:["change"],MouseEvents:["click","mousemove","mousedown","mouseup","mouseover"],KeyboardEvents:["keydown"]},(function(t,e){wp.each(t,(function(t){zp[t]=e}))}));var kp=/(\d+(\.\d+)?)px/;function Hp(t){if("0"===t||wp.isUndefined(t))return 0;var e=t.match(kp);return wp.isNull(e)?0:parseFloat(e[1])}var Gp={makeSelectable:function(t,e){void 0!==t&&void 0!==t.style&&(t.onselectstart=e?function(){return!1}:function(){},t.style.MozUserSelect=e?"auto":"none",t.style.KhtmlUserSelect=e?"auto":"none",t.unselectable=e?"on":"off")},makeFullscreen:function(t,e,n){var i=n,r=e;wp.isUndefined(r)&&(r=!0),wp.isUndefined(i)&&(i=!0),t.style.position="absolute",r&&(t.style.left=0,t.style.right=0),i&&(t.style.top=0,t.style.bottom=0)},fakeEvent:function(t,e,n,i){var r=n||{},a=zp[e];if(!a)throw new Error("Event type "+e+" not supported.");var s=document.createEvent(a);switch(a){case"MouseEvents":var o=r.x||r.clientX||0,l=r.y||r.clientY||0;s.initMouseEvent(e,r.bubbles||!1,r.cancelable||!0,window,r.clickCount||1,0,0,o,l,!1,!1,!1,!1,0,null);break;case"KeyboardEvents":var c=s.initKeyboardEvent||s.initKeyEvent;wp.defaults(r,{cancelable:!0,ctrlKey:!1,altKey:!1,shiftKey:!1,metaKey:!1,keyCode:void 0,charCode:void 0}),c(e,r.bubbles||!1,r.cancelable,window,r.ctrlKey,r.altKey,r.shiftKey,r.metaKey,r.keyCode,r.charCode);break;default:s.initEvent(e,r.bubbles||!1,r.cancelable||!0)}wp.defaults(s,i),t.dispatchEvent(s)},bind:function(t,e,n,i){var r=i||!1;return t.addEventListener?t.addEventListener(e,n,r):t.attachEvent&&t.attachEvent("on"+e,n),Gp},unbind:function(t,e,n,i){var r=i||!1;return t.removeEventListener?t.removeEventListener(e,n,r):t.detachEvent&&t.detachEvent("on"+e,n),Gp},addClass:function(t,e){if(void 0===t.className)t.className=e;else if(t.className!==e){var n=t.className.split(/ +/);-1===n.indexOf(e)&&(n.push(e),t.className=n.join(" ").replace(/^\s+/,"").replace(/\s+$/,""))}return Gp},removeClass:function(t,e){if(e)if(t.className===e)t.removeAttribute("class");else{var n=t.className.split(/ +/),i=n.indexOf(e);-1!==i&&(n.splice(i,1),t.className=n.join(" "))}else t.className=void 0;return Gp},hasClass:function(t,e){return new RegExp("(?:^|\\s+)"+e+"(?:\\s+|$)").test(t.className)||!1},getWidth:function(t){var e=getComputedStyle(t);return Hp(e["border-left-width"])+Hp(e["border-right-width"])+Hp(e["padding-left"])+Hp(e["padding-right"])+Hp(e.width)},getHeight:function(t){var e=getComputedStyle(t);return Hp(e["border-top-width"])+Hp(e["border-bottom-width"])+Hp(e["padding-top"])+Hp(e["padding-bottom"])+Hp(e.height)},getOffset:function(t){var e=t,n={left:0,top:0};if(e.offsetParent)do{n.left+=e.offsetLeft,n.top+=e.offsetTop,e=e.offsetParent}while(e);return n},isActive:function(t){return t===document.activeElement&&(t.type||t.href)}},Vp=function(t){function e(t,n){Pp(this,e);var i=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),r=i;return i.__prev=i.getValue(),i.__checkbox=document.createElement("input"),i.__checkbox.setAttribute("type","checkbox"),Gp.bind(i.__checkbox,"change",(function(){r.setValue(!r.__prev)}),!1),i.domElement.appendChild(i.__checkbox),i.updateDisplay(),i}return Dp(e,Bp),Ip(e,[{key:"setValue",value:function(t){var n=Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,t);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),this.__prev=this.getValue(),n}},{key:"updateDisplay",value:function(){return!0===this.getValue()?(this.__checkbox.setAttribute("checked","checked"),this.__checkbox.checked=!0,this.__prev=!0):(this.__checkbox.checked=!1,this.__prev=!1),Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(),Wp=function(t){function e(t,n,i){Pp(this,e);var r=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),a=i,s=r;if(r.__select=document.createElement("select"),wp.isArray(a)){var o={};wp.each(a,(function(t){o[t]=t})),a=o}return wp.each(a,(function(t,e){var n=document.createElement("option");n.innerHTML=e,n.setAttribute("value",t),s.__select.appendChild(n)})),r.updateDisplay(),Gp.bind(r.__select,"change",(function(){var t=this.options[this.selectedIndex].value;s.setValue(t)})),r.domElement.appendChild(r.__select),r}return Dp(e,Bp),Ip(e,[{key:"setValue",value:function(t){var n=Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,t);return this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue()),n}},{key:"updateDisplay",value:function(){return Gp.isActive(this.__select)?this:(this.__select.value=this.getValue(),Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this))}}]),e}(),jp=function(t){function e(t,n){Pp(this,e);var i=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),r=i;function a(){r.setValue(r.__input.value)}return i.__input=document.createElement("input"),i.__input.setAttribute("type","text"),Gp.bind(i.__input,"keyup",a),Gp.bind(i.__input,"change",a),Gp.bind(i.__input,"blur",(function(){r.__onFinishChange&&r.__onFinishChange.call(r,r.getValue())})),Gp.bind(i.__input,"keydown",(function(t){13===t.keyCode&&this.blur()})),i.updateDisplay(),i.domElement.appendChild(i.__input),i}return Dp(e,Bp),Ip(e,[{key:"updateDisplay",value:function(){return Gp.isActive(this.__input)||(this.__input.value=this.getValue()),Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}();function Xp(t){var e=t.toString();return e.indexOf(".")>-1?e.length-e.indexOf(".")-1:0}var qp=function(t){function e(t,n,i){Pp(this,e);var r=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),a=i||{};return r.__min=a.min,r.__max=a.max,r.__step=a.step,wp.isUndefined(r.__step)?0===r.initialValue?r.__impliedStep=1:r.__impliedStep=Math.pow(10,Math.floor(Math.log(Math.abs(r.initialValue))/Math.LN10))/10:r.__impliedStep=r.__step,r.__precision=Xp(r.__impliedStep),r}return Dp(e,Bp),Ip(e,[{key:"setValue",value:function(t){var n=t;return void 0!==this.__min&&n<this.__min?n=this.__min:void 0!==this.__max&&n>this.__max&&(n=this.__max),void 0!==this.__step&&n%this.__step!=0&&(n=Math.round(n/this.__step)*this.__step),Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"setValue",this).call(this,n)}},{key:"min",value:function(t){return this.__min=t,this}},{key:"max",value:function(t){return this.__max=t,this}},{key:"step",value:function(t){return this.__step=t,this.__impliedStep=t,this.__precision=Xp(t),this}}]),e}();var Yp=function(t){function e(t,n,i){Pp(this,e);var r=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n,i));r.__truncationSuspended=!1;var a=r,s=void 0;function o(){a.__onFinishChange&&a.__onFinishChange.call(a,a.getValue())}function l(t){var e=s-t.clientY;a.setValue(a.getValue()+e*a.__impliedStep),s=t.clientY}function c(){Gp.unbind(window,"mousemove",l),Gp.unbind(window,"mouseup",c),o()}return r.__input=document.createElement("input"),r.__input.setAttribute("type","text"),Gp.bind(r.__input,"change",(function(){var t=parseFloat(a.__input.value);wp.isNaN(t)||a.setValue(t)})),Gp.bind(r.__input,"blur",(function(){o()})),Gp.bind(r.__input,"mousedown",(function(t){Gp.bind(window,"mousemove",l),Gp.bind(window,"mouseup",c),s=t.clientY})),Gp.bind(r.__input,"keydown",(function(t){13===t.keyCode&&(a.__truncationSuspended=!0,this.blur(),a.__truncationSuspended=!1,o())})),r.updateDisplay(),r.domElement.appendChild(r.__input),r}return Dp(e,qp),Ip(e,[{key:"updateDisplay",value:function(){var t,n,i;return this.__input.value=this.__truncationSuspended?this.getValue():(t=this.getValue(),n=this.__precision,i=Math.pow(10,n),Math.round(t*i)/i),Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}();function Zp(t,e,n,i,r){return i+(t-e)/(n-e)*(r-i)}var Jp=function(t){function e(t,n,i,r,a){Pp(this,e);var s=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n,{min:i,max:r,step:a})),o=s;function l(t){t.preventDefault();var e=o.__background.getBoundingClientRect();return o.setValue(Zp(t.clientX,e.left,e.right,o.__min,o.__max)),!1}function c(){Gp.unbind(window,"mousemove",l),Gp.unbind(window,"mouseup",c),o.__onFinishChange&&o.__onFinishChange.call(o,o.getValue())}function h(t){var e=t.touches[0].clientX,n=o.__background.getBoundingClientRect();o.setValue(Zp(e,n.left,n.right,o.__min,o.__max))}function u(){Gp.unbind(window,"touchmove",h),Gp.unbind(window,"touchend",u),o.__onFinishChange&&o.__onFinishChange.call(o,o.getValue())}return s.__background=document.createElement("div"),s.__foreground=document.createElement("div"),Gp.bind(s.__background,"mousedown",(function(t){document.activeElement.blur(),Gp.bind(window,"mousemove",l),Gp.bind(window,"mouseup",c),l(t)})),Gp.bind(s.__background,"touchstart",(function(t){if(1!==t.touches.length)return;Gp.bind(window,"touchmove",h),Gp.bind(window,"touchend",u),h(t)})),Gp.addClass(s.__background,"slider"),Gp.addClass(s.__foreground,"slider-fg"),s.updateDisplay(),s.__background.appendChild(s.__foreground),s.domElement.appendChild(s.__background),s}return Dp(e,qp),Ip(e,[{key:"updateDisplay",value:function(){var t=(this.getValue()-this.__min)/(this.__max-this.__min);return this.__foreground.style.width=100*t+"%",Lp(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"updateDisplay",this).call(this)}}]),e}(),Kp=function(t){function e(t,n,i){Pp(this,e);var r=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),a=r;return r.__button=document.createElement("div"),r.__button.innerHTML=void 0===i?"Fire":i,Gp.bind(r.__button,"click",(function(t){return t.preventDefault(),a.fire(),!1})),Gp.addClass(r.__button,"button"),r.domElement.appendChild(r.__button),r}return Dp(e,Bp),Ip(e,[{key:"fire",value:function(){this.__onChange&&this.__onChange.call(this),this.getValue().call(this.object),this.__onFinishChange&&this.__onFinishChange.call(this,this.getValue())}}]),e}(),Qp=function(t){function e(t,n){Pp(this,e);var i=Np(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));i.__color=new Op(i.getValue()),i.__temp=new Op(0);var r=i;i.domElement=document.createElement("div"),Gp.makeSelectable(i.domElement,!1),i.__selector=document.createElement("div"),i.__selector.className="selector",i.__saturation_field=document.createElement("div"),i.__saturation_field.className="saturation-field",i.__field_knob=document.createElement("div"),i.__field_knob.className="field-knob",i.__field_knob_border="2px solid ",i.__hue_knob=document.createElement("div"),i.__hue_knob.className="hue-knob",i.__hue_field=document.createElement("div"),i.__hue_field.className="hue-field",i.__input=document.createElement("input"),i.__input.type="text",i.__input_textShadow="0 1px 1px ",Gp.bind(i.__input,"keydown",(function(t){13===t.keyCode&&u.call(this)})),Gp.bind(i.__input,"blur",u),Gp.bind(i.__selector,"mousedown",(function(){Gp.addClass(this,"drag").bind(window,"mouseup",(function(){Gp.removeClass(r.__selector,"drag")}))})),Gp.bind(i.__selector,"touchstart",(function(){Gp.addClass(this,"drag").bind(window,"touchend",(function(){Gp.removeClass(r.__selector,"drag")}))}));var a,s=document.createElement("div");function o(t){p(t),Gp.bind(window,"mousemove",p),Gp.bind(window,"touchmove",p),Gp.bind(window,"mouseup",c),Gp.bind(window,"touchend",c)}function l(t){m(t),Gp.bind(window,"mousemove",m),Gp.bind(window,"touchmove",m),Gp.bind(window,"mouseup",h),Gp.bind(window,"touchend",h)}function c(){Gp.unbind(window,"mousemove",p),Gp.unbind(window,"touchmove",p),Gp.unbind(window,"mouseup",c),Gp.unbind(window,"touchend",c),d()}function h(){Gp.unbind(window,"mousemove",m),Gp.unbind(window,"touchmove",m),Gp.unbind(window,"mouseup",h),Gp.unbind(window,"touchend",h),d()}function u(){var t=Ep(this.value);!1!==t?(r.__color.__state=t,r.setValue(r.__color.toOriginal())):this.value=r.__color.toString()}function d(){r.__onFinishChange&&r.__onFinishChange.call(r,r.__color.toOriginal())}function p(t){-1===t.type.indexOf("touch")&&t.preventDefault();var e=r.__saturation_field.getBoundingClientRect(),n=t.touches&&t.touches[0]||t,i=n.clientX,a=n.clientY,s=(i-e.left)/(e.right-e.left),o=1-(a-e.top)/(e.bottom-e.top);return o>1?o=1:o<0&&(o=0),s>1?s=1:s<0&&(s=0),r.__color.v=o,r.__color.s=s,r.setValue(r.__color.toOriginal()),!1}function m(t){-1===t.type.indexOf("touch")&&t.preventDefault();var e=r.__hue_field.getBoundingClientRect(),n=1-((t.touches&&t.touches[0]||t).clientY-e.top)/(e.bottom-e.top);return n>1?n=1:n<0&&(n=0),r.__color.h=360*n,r.setValue(r.__color.toOriginal()),!1}return wp.extend(i.__selector.style,{width:"122px",height:"102px",padding:"3px",backgroundColor:"#222",boxShadow:"0px 1px 3px rgba(0,0,0,0.3)"}),wp.extend(i.__field_knob.style,{position:"absolute",width:"12px",height:"12px",border:i.__field_knob_border+(i.__color.v<.5?"#fff":"#000"),boxShadow:"0px 1px 3px rgba(0,0,0,0.5)",borderRadius:"12px",zIndex:1}),wp.extend(i.__hue_knob.style,{position:"absolute",width:"15px",height:"2px",borderRight:"4px solid #fff",zIndex:1}),wp.extend(i.__saturation_field.style,{width:"100px",height:"100px",border:"1px solid #555",marginRight:"3px",display:"inline-block",cursor:"pointer"}),wp.extend(s.style,{width:"100%",height:"100%",background:"none"}),tm(s,"top","rgba(0,0,0,0)","#000"),wp.extend(i.__hue_field.style,{width:"15px",height:"100px",border:"1px solid #555",cursor:"ns-resize",position:"absolute",top:"3px",right:"3px"}),(a=i.__hue_field).style.background="",a.style.cssText+="background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);",a.style.cssText+="background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",a.style.cssText+="background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",a.style.cssText+="background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",a.style.cssText+="background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);",wp.extend(i.__input.style,{outline:"none",textAlign:"center",color:"#fff",border:0,fontWeight:"bold",textShadow:i.__input_textShadow+"rgba(0,0,0,0.7)"}),Gp.bind(i.__saturation_field,"mousedown",o),Gp.bind(i.__saturation_field,"touchstart",o),Gp.bind(i.__field_knob,"mousedown",o),Gp.bind(i.__field_knob,"touchstart",o),Gp.bind(i.__hue_field,"mousedown",l),Gp.bind(i.__hue_field,"touchstart",l),i.__saturation_field.appendChild(s),i.__selector.appendChild(i.__field_knob),i.__selector.appendChild(i.__saturation_field),i.__selector.appendChild(i.__hue_field),i.__hue_field.appendChild(i.__hue_knob),i.domElement.appendChild(i.__input),i.domElement.appendChild(i.__selector),i.updateDisplay(),i}return Dp(e,Bp),Ip(e,[{key:"updateDisplay",value:function(){var t=Ep(this.getValue());if(!1!==t){var e=!1;wp.each(Op.COMPONENTS,(function(n){if(!wp.isUndefined(t[n])&&!wp.isUndefined(this.__color.__state[n])&&t[n]!==this.__color.__state[n])return e=!0,{}}),this),e&&wp.extend(this.__color.__state,t)}wp.extend(this.__temp.__state,this.__color.__state),this.__temp.a=1;var n=this.__color.v<.5||this.__color.s>.5?255:0,i=255-n;wp.extend(this.__field_knob.style,{marginLeft:100*this.__color.s-7+"px",marginTop:100*(1-this.__color.v)-7+"px",backgroundColor:this.__temp.toHexString(),border:this.__field_knob_border+"rgb("+n+","+n+","+n+")"}),this.__hue_knob.style.marginTop=100*(1-this.__color.h/360)+"px",this.__temp.s=1,this.__temp.v=1,tm(this.__saturation_field,"left","#fff",this.__temp.toHexString()),this.__input.value=this.__color.toString(),wp.extend(this.__input.style,{backgroundColor:this.__color.toHexString(),color:"rgb("+n+","+n+","+n+")",textShadow:this.__input_textShadow+"rgba("+i+","+i+","+i+",.7)"})}}]),e}(),$p=["-moz-","-o-","-webkit-","-ms-",""];function tm(t,e,n,i){t.style.background="",wp.each($p,(function(r){t.style.cssText+="background: "+r+"linear-gradient("+e+", "+n+" 0%, "+i+" 100%); "}))}var em=function(t,e){var n=e||document,i=document.createElement("style");i.type="text/css",i.innerHTML=t;var r=n.getElementsByTagName("head")[0];try{r.appendChild(i)}catch(t){}},nm=function(t,e){var n=t[e];return wp.isArray(arguments[2])||wp.isObject(arguments[2])?new Wp(t,e,arguments[2]):wp.isNumber(n)?wp.isNumber(arguments[2])&&wp.isNumber(arguments[3])?wp.isNumber(arguments[4])?new Jp(t,e,arguments[2],arguments[3],arguments[4]):new Jp(t,e,arguments[2],arguments[3]):wp.isNumber(arguments[4])?new Yp(t,e,{min:arguments[2],max:arguments[3],step:arguments[4]}):new Yp(t,e,{min:arguments[2],max:arguments[3]}):wp.isString(n)?new jp(t,e):wp.isFunction(n)?new Kp(t,e,""):wp.isBoolean(n)?new Vp(t,e):null};var im=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){setTimeout(t,1e3/60)},rm=function(){function t(){Pp(this,t),this.backgroundElement=document.createElement("div"),wp.extend(this.backgroundElement.style,{backgroundColor:"rgba(0,0,0,0.8)",top:0,left:0,display:"none",zIndex:"1000",opacity:0,WebkitTransition:"opacity 0.2s linear",transition:"opacity 0.2s linear"}),Gp.makeFullscreen(this.backgroundElement),this.backgroundElement.style.position="fixed",this.domElement=document.createElement("div"),wp.extend(this.domElement.style,{position:"fixed",display:"none",zIndex:"1001",opacity:0,WebkitTransition:"-webkit-transform 0.2s ease-out, opacity 0.2s linear",transition:"transform 0.2s ease-out, opacity 0.2s linear"}),document.body.appendChild(this.backgroundElement),document.body.appendChild(this.domElement);var e=this;Gp.bind(this.backgroundElement,"click",(function(){e.hide()}))}return Ip(t,[{key:"show",value:function(){var t=this;this.backgroundElement.style.display="block",this.domElement.style.display="block",this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)",this.layout(),wp.defer((function(){t.backgroundElement.style.opacity=1,t.domElement.style.opacity=1,t.domElement.style.webkitTransform="scale(1)"}))}},{key:"hide",value:function(){var t=this,e=function e(){t.domElement.style.display="none",t.backgroundElement.style.display="none",Gp.unbind(t.domElement,"webkitTransitionEnd",e),Gp.unbind(t.domElement,"transitionend",e),Gp.unbind(t.domElement,"oTransitionEnd",e)};Gp.bind(this.domElement,"webkitTransitionEnd",e),Gp.bind(this.domElement,"transitionend",e),Gp.bind(this.domElement,"oTransitionEnd",e),this.backgroundElement.style.opacity=0,this.domElement.style.opacity=0,this.domElement.style.webkitTransform="scale(1.1)"}},{key:"layout",value:function(){this.domElement.style.left=window.innerWidth/2-Gp.getWidth(this.domElement)/2+"px",this.domElement.style.top=window.innerHeight/2-Gp.getHeight(this.domElement)/2+"px"}}]),t}(),am=function(t){if(t&&"undefined"!=typeof window){var e=document.createElement("style");return e.setAttribute("type","text/css"),e.innerHTML=t,document.head.appendChild(e),t}}(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");em(am);var sm="Default",om=function(){try{return!!window.localStorage}catch(t){return!1}}(),lm=void 0,cm=!0,hm=void 0,um=!1,dm=[],pm=function t(e){var n=this,i=e||{};this.domElement=document.createElement("div"),this.__ul=document.createElement("ul"),this.domElement.appendChild(this.__ul),Gp.addClass(this.domElement,"dg"),this.__folders={},this.__controllers=[],this.__rememberedObjects=[],this.__rememberedObjectIndecesToControllers=[],this.__listening=[],i=wp.defaults(i,{closeOnTop:!1,autoPlace:!0,width:t.DEFAULT_WIDTH}),i=wp.defaults(i,{resizable:i.autoPlace,hideable:i.autoPlace}),wp.isUndefined(i.load)?i.load={preset:sm}:i.preset&&(i.load.preset=i.preset),wp.isUndefined(i.parent)&&i.hideable&&dm.push(this),i.resizable=wp.isUndefined(i.parent)&&i.resizable,i.autoPlace&&wp.isUndefined(i.scrollable)&&(i.scrollable=!0);var r,a=om&&"true"===localStorage.getItem(ym(this,"isLocal")),s=void 0,o=void 0;if(Object.defineProperties(this,{parent:{get:function(){return i.parent}},scrollable:{get:function(){return i.scrollable}},autoPlace:{get:function(){return i.autoPlace}},closeOnTop:{get:function(){return i.closeOnTop}},preset:{get:function(){return n.parent?n.getRoot().preset:i.load.preset},set:function(t){n.parent?n.getRoot().preset=t:i.load.preset=t,function(t){for(var e=0;e<t.__preset_select.length;e++)t.__preset_select[e].value===t.preset&&(t.__preset_select.selectedIndex=e)}(this),n.revert()}},width:{get:function(){return i.width},set:function(t){i.width=t,Mm(n,t)}},name:{get:function(){return i.name},set:function(t){i.name=t,o&&(o.innerHTML=i.name)}},closed:{get:function(){return i.closed},set:function(e){i.closed=e,i.closed?Gp.addClass(n.__ul,t.CLASS_CLOSED):Gp.removeClass(n.__ul,t.CLASS_CLOSED),this.onResize(),n.__closeButton&&(n.__closeButton.innerHTML=e?t.TEXT_OPEN:t.TEXT_CLOSED)}},load:{get:function(){return i.load}},useLocalStorage:{get:function(){return a},set:function(t){om&&(a=t,t?Gp.bind(window,"unload",s):Gp.unbind(window,"unload",s),localStorage.setItem(ym(n,"isLocal"),t))}}}),wp.isUndefined(i.parent)){if(this.closed=i.closed||!1,Gp.addClass(this.domElement,t.CLASS_MAIN),Gp.makeSelectable(this.domElement,!1),om&&a){n.useLocalStorage=!0;var l=localStorage.getItem(ym(this,"gui"));l&&(i.load=JSON.parse(l))}this.__closeButton=document.createElement("div"),this.__closeButton.innerHTML=t.TEXT_CLOSED,Gp.addClass(this.__closeButton,t.CLASS_CLOSE_BUTTON),i.closeOnTop?(Gp.addClass(this.__closeButton,t.CLASS_CLOSE_TOP),this.domElement.insertBefore(this.__closeButton,this.domElement.childNodes[0])):(Gp.addClass(this.__closeButton,t.CLASS_CLOSE_BOTTOM),this.domElement.appendChild(this.__closeButton)),Gp.bind(this.__closeButton,"click",(function(){n.closed=!n.closed}))}else{void 0===i.closed&&(i.closed=!0);var c=document.createTextNode(i.name);Gp.addClass(c,"controller-name"),o=mm(n,c);Gp.addClass(this.__ul,t.CLASS_CLOSED),Gp.addClass(o,"title"),Gp.bind(o,"click",(function(t){return t.preventDefault(),n.closed=!n.closed,!1})),i.closed||(this.closed=!1)}i.autoPlace&&(wp.isUndefined(i.parent)&&(cm&&(hm=document.createElement("div"),Gp.addClass(hm,"dg"),Gp.addClass(hm,t.CLASS_AUTO_PLACE_CONTAINER),document.body.appendChild(hm),cm=!1),hm.appendChild(this.domElement),Gp.addClass(this.domElement,t.CLASS_AUTO_PLACE)),this.parent||Mm(n,i.width)),this.__resizeHandler=function(){n.onResizeDebounced()},Gp.bind(window,"resize",this.__resizeHandler),Gp.bind(this.__ul,"webkitTransitionEnd",this.__resizeHandler),Gp.bind(this.__ul,"transitionend",this.__resizeHandler),Gp.bind(this.__ul,"oTransitionEnd",this.__resizeHandler),this.onResize(),i.resizable&&wm(this),s=function(){om&&"true"===localStorage.getItem(ym(n,"isLocal"))&&localStorage.setItem(ym(n,"gui"),JSON.stringify(n.getSaveObject()))},this.saveToLocalStorageIfPossible=s,i.parent||((r=n.getRoot()).width+=1,wp.defer((function(){r.width-=1})))};function mm(t,e,n){var i=document.createElement("li");return e&&i.appendChild(e),n?t.__ul.insertBefore(i,n):t.__ul.appendChild(i),t.onResize(),i}function fm(t){Gp.unbind(window,"resize",t.__resizeHandler),t.saveToLocalStorageIfPossible&&Gp.unbind(window,"unload",t.saveToLocalStorageIfPossible)}function gm(t,e){var n=t.__preset_select[t.__preset_select.selectedIndex];n.innerHTML=e?n.value+"*":n.value}function vm(t,e){var n=t.getRoot(),i=n.__rememberedObjects.indexOf(e.object);if(-1!==i){var r=n.__rememberedObjectIndecesToControllers[i];if(void 0===r&&(r={},n.__rememberedObjectIndecesToControllers[i]=r),r[e.property]=e,n.load&&n.load.remembered){var a=n.load.remembered,s=void 0;if(a[t.preset])s=a[t.preset];else{if(!a[sm])return;s=a[sm]}if(s[i]&&void 0!==s[i][e.property]){var o=s[i][e.property];e.initialValue=o,e.setValue(o)}}}}function _m(t,e,n,i){if(void 0===e[n])throw new Error('Object "'+e+'" has no property "'+n+'"');var r=void 0;if(i.color)r=new Qp(e,n);else{var a=[e,n].concat(i.factoryArgs);r=nm.apply(t,a)}i.before instanceof Bp&&(i.before=i.before.__li),vm(t,r),Gp.addClass(r.domElement,"c");var s=document.createElement("span");Gp.addClass(s,"property-name"),s.innerHTML=r.property;var o=document.createElement("div");o.appendChild(s),o.appendChild(r.domElement);var l=mm(t,o,i.before);return Gp.addClass(l,pm.CLASS_CONTROLLER_ROW),r instanceof Qp?Gp.addClass(l,"color"):Gp.addClass(l,Cp(r.getValue())),function(t,e,n){if(n.__li=e,n.__gui=t,wp.extend(n,{options:function(e){if(arguments.length>1){var i=n.__li.nextElementSibling;return n.remove(),_m(t,n.object,n.property,{before:i,factoryArgs:[wp.toArray(arguments)]})}if(wp.isArray(e)||wp.isObject(e)){var r=n.__li.nextElementSibling;return n.remove(),_m(t,n.object,n.property,{before:r,factoryArgs:[e]})}},name:function(t){return n.__li.firstElementChild.firstElementChild.innerHTML=t,n},listen:function(){return n.__gui.listen(n),n},remove:function(){return n.__gui.remove(n),n}}),n instanceof Jp){var i=new Yp(n.object,n.property,{min:n.__min,max:n.__max,step:n.__step});wp.each(["updateDisplay","onChange","onFinishChange","step","min","max"],(function(t){var e=n[t],r=i[t];n[t]=i[t]=function(){var t=Array.prototype.slice.call(arguments);return r.apply(i,t),e.apply(n,t)}})),Gp.addClass(e,"has-slider"),n.domElement.insertBefore(i.domElement,n.domElement.firstElementChild)}else if(n instanceof Yp){var r=function(e){if(wp.isNumber(n.__min)&&wp.isNumber(n.__max)){var i=n.__li.firstElementChild.firstElementChild.innerHTML,r=n.__gui.__listening.indexOf(n)>-1;n.remove();var a=_m(t,n.object,n.property,{before:n.__li.nextElementSibling,factoryArgs:[n.__min,n.__max,n.__step]});return a.name(i),r&&a.listen(),a}return e};n.min=wp.compose(r,n.min),n.max=wp.compose(r,n.max)}else n instanceof Vp?(Gp.bind(e,"click",(function(){Gp.fakeEvent(n.__checkbox,"click")})),Gp.bind(n.__checkbox,"click",(function(t){t.stopPropagation()}))):n instanceof Kp?(Gp.bind(e,"click",(function(){Gp.fakeEvent(n.__button,"click")})),Gp.bind(e,"mouseover",(function(){Gp.addClass(n.__button,"hover")})),Gp.bind(e,"mouseout",(function(){Gp.removeClass(n.__button,"hover")}))):n instanceof Qp&&(Gp.addClass(e,"color"),n.updateDisplay=wp.compose((function(t){return e.style.borderLeftColor=n.__color.toString(),t}),n.updateDisplay),n.updateDisplay());n.setValue=wp.compose((function(e){return t.getRoot().__preset_select&&n.isModified()&&gm(t.getRoot(),!0),e}),n.setValue)}(t,l,r),t.__controllers.push(r),r}function ym(t,e){return document.location.href+"."+e}function xm(t,e,n){var i=document.createElement("option");i.innerHTML=e,i.value=e,t.__preset_select.appendChild(i),n&&(t.__preset_select.selectedIndex=t.__preset_select.length-1)}function bm(t,e){e.style.display=t.useLocalStorage?"block":"none"}function wm(t){var e=void 0;function n(n){return n.preventDefault(),t.width+=e-n.clientX,t.onResize(),e=n.clientX,!1}function i(){Gp.removeClass(t.__closeButton,pm.CLASS_DRAG),Gp.unbind(window,"mousemove",n),Gp.unbind(window,"mouseup",i)}function r(r){return r.preventDefault(),e=r.clientX,Gp.addClass(t.__closeButton,pm.CLASS_DRAG),Gp.bind(window,"mousemove",n),Gp.bind(window,"mouseup",i),!1}t.__resize_handle=document.createElement("div"),wp.extend(t.__resize_handle.style,{width:"6px",marginLeft:"-3px",height:"200px",cursor:"ew-resize",position:"absolute"}),Gp.bind(t.__resize_handle,"mousedown",r),Gp.bind(t.__closeButton,"mousedown",r),t.domElement.insertBefore(t.__resize_handle,t.domElement.firstElementChild)}function Mm(t,e){t.domElement.style.width=e+"px",t.__save_row&&t.autoPlace&&(t.__save_row.style.width=e+"px"),t.__closeButton&&(t.__closeButton.style.width=e+"px")}function Sm(t,e){var n={};return wp.each(t.__rememberedObjects,(function(i,r){var a={},s=t.__rememberedObjectIndecesToControllers[r];wp.each(s,(function(t,n){a[n]=e?t.initialValue:t.getValue()})),n[r]=a})),n}function Tm(t){0!==t.length&&im.call(window,(function(){Tm(t)})),wp.each(t,(function(t){t.updateDisplay()}))}pm.toggleHide=function(){um=!um,wp.each(dm,(function(t){t.domElement.style.display=um?"none":""}))},pm.CLASS_AUTO_PLACE="a",pm.CLASS_AUTO_PLACE_CONTAINER="ac",pm.CLASS_MAIN="main",pm.CLASS_CONTROLLER_ROW="cr",pm.CLASS_TOO_TALL="taller-than-window",pm.CLASS_CLOSED="closed",pm.CLASS_CLOSE_BUTTON="close-button",pm.CLASS_CLOSE_TOP="close-top",pm.CLASS_CLOSE_BOTTOM="close-bottom",pm.CLASS_DRAG="drag",pm.DEFAULT_WIDTH=245,pm.TEXT_CLOSED="Close Controls",pm.TEXT_OPEN="...",pm._keydownHandler=function(t){"text"===document.activeElement.type||72!==t.which&&72!==t.keyCode||pm.toggleHide()},Gp.bind(window,"keydown",pm._keydownHandler,!1),wp.extend(pm.prototype,{add:function(t,e){return _m(this,t,e,{factoryArgs:Array.prototype.slice.call(arguments,2)})},addColor:function(t,e){return _m(this,t,e,{color:!0})},remove:function(t){this.__ul.removeChild(t.__li),this.__controllers.splice(this.__controllers.indexOf(t),1);var e=this;wp.defer((function(){e.onResize()}))},destroy:function(){if(this.parent)throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");this.autoPlace&&hm.removeChild(this.domElement);var t=this;wp.each(this.__folders,(function(e){t.removeFolder(e)})),Gp.unbind(window,"keydown",pm._keydownHandler,!1),fm(this)},addFolder:function(t){if(void 0!==this.__folders[t])throw new Error('You already have a folder in this GUI by the name "'+t+'"');var e={name:t,parent:this};e.autoPlace=this.autoPlace,this.load&&this.load.folders&&this.load.folders[t]&&(e.closed=this.load.folders[t].closed,e.load=this.load.folders[t]);var n=new pm(e);this.__folders[t]=n;var i=mm(this,n.domElement);return Gp.addClass(i,"folder"),n},removeFolder:function(t){this.__ul.removeChild(t.domElement.parentElement),delete this.__folders[t.name],this.load&&this.load.folders&&this.load.folders[t.name]&&delete this.load.folders[t.name],fm(t);var e=this;wp.each(t.__folders,(function(e){t.removeFolder(e)})),wp.defer((function(){e.onResize()}))},open:function(){this.closed=!1},close:function(){this.closed=!0},hide:function(){this.domElement.style.display="none"},show:function(){this.domElement.style.display=""},onResize:function(){var t=this.getRoot();if(t.scrollable){var e=Gp.getOffset(t.__ul).top,n=0;wp.each(t.__ul.childNodes,(function(e){t.autoPlace&&e===t.__save_row||(n+=Gp.getHeight(e))})),window.innerHeight-e-20<n?(Gp.addClass(t.domElement,pm.CLASS_TOO_TALL),t.__ul.style.height=window.innerHeight-e-20+"px"):(Gp.removeClass(t.domElement,pm.CLASS_TOO_TALL),t.__ul.style.height="auto")}t.__resize_handle&&wp.defer((function(){t.__resize_handle.style.height=t.__ul.offsetHeight+"px"})),t.__closeButton&&(t.__closeButton.style.width=t.width+"px")},onResizeDebounced:wp.debounce((function(){this.onResize()}),50),remember:function(){if(wp.isUndefined(lm)&&((lm=new rm).domElement.innerHTML='<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'),this.parent)throw new Error("You can only call remember on a top level GUI.");var t=this;wp.each(Array.prototype.slice.call(arguments),(function(e){0===t.__rememberedObjects.length&&function(t){var e=t.__save_row=document.createElement("li");Gp.addClass(t.domElement,"has-save"),t.__ul.insertBefore(e,t.__ul.firstChild),Gp.addClass(e,"save-row");var n=document.createElement("span");n.innerHTML="&nbsp;",Gp.addClass(n,"button gears");var i=document.createElement("span");i.innerHTML="Save",Gp.addClass(i,"button"),Gp.addClass(i,"save");var r=document.createElement("span");r.innerHTML="New",Gp.addClass(r,"button"),Gp.addClass(r,"save-as");var a=document.createElement("span");a.innerHTML="Revert",Gp.addClass(a,"button"),Gp.addClass(a,"revert");var s=t.__preset_select=document.createElement("select");t.load&&t.load.remembered?wp.each(t.load.remembered,(function(e,n){xm(t,n,n===t.preset)})):xm(t,sm,!1);if(Gp.bind(s,"change",(function(){for(var e=0;e<t.__preset_select.length;e++)t.__preset_select[e].innerHTML=t.__preset_select[e].value;t.preset=this.value})),e.appendChild(s),e.appendChild(n),e.appendChild(i),e.appendChild(r),e.appendChild(a),om){var o=document.getElementById("dg-local-explain"),l=document.getElementById("dg-local-storage");document.getElementById("dg-save-locally").style.display="block","true"===localStorage.getItem(ym(t,"isLocal"))&&l.setAttribute("checked","checked"),bm(t,o),Gp.bind(l,"change",(function(){t.useLocalStorage=!t.useLocalStorage,bm(t,o)}))}var c=document.getElementById("dg-new-constructor");Gp.bind(c,"keydown",(function(t){!t.metaKey||67!==t.which&&67!==t.keyCode||lm.hide()})),Gp.bind(n,"click",(function(){c.innerHTML=JSON.stringify(t.getSaveObject(),void 0,2),lm.show(),c.focus(),c.select()})),Gp.bind(i,"click",(function(){t.save()})),Gp.bind(r,"click",(function(){var e=prompt("Enter a new preset name.");e&&t.saveAs(e)})),Gp.bind(a,"click",(function(){t.revert()}))}(t),-1===t.__rememberedObjects.indexOf(e)&&t.__rememberedObjects.push(e)})),this.autoPlace&&Mm(this,this.width)},getRoot:function(){for(var t=this;t.parent;)t=t.parent;return t},getSaveObject:function(){var t=this.load;return t.closed=this.closed,this.__rememberedObjects.length>0&&(t.preset=this.preset,t.remembered||(t.remembered={}),t.remembered[this.preset]=Sm(this)),t.folders={},wp.each(this.__folders,(function(e,n){t.folders[n]=e.getSaveObject()})),t},save:function(){this.load.remembered||(this.load.remembered={}),this.load.remembered[this.preset]=Sm(this),gm(this,!1),this.saveToLocalStorageIfPossible()},saveAs:function(t){this.load.remembered||(this.load.remembered={},this.load.remembered[sm]=Sm(this,!0)),this.load.remembered[t]=Sm(this),this.preset=t,xm(this,t,!0),this.saveToLocalStorageIfPossible()},revert:function(t){wp.each(this.__controllers,(function(e){this.getRoot().load.remembered?vm(t||this.getRoot(),e):e.setValue(e.initialValue),e.__onFinishChange&&e.__onFinishChange.call(e,e.getValue())}),this),wp.each(this.__folders,(function(t){t.revert(t)})),t||gm(this.getRoot(),!1)},listen:function(t){var e=0===this.__listening.length;this.__listening.push(t),e&&Tm(this.__listening)},updateDisplay:function(){wp.each(this.__controllers,(function(t){t.updateDisplay()})),wp.each(this.__folders,(function(t){t.updateDisplay()}))}});var Em={Color:Op,math:Rp,interpret:Ep},Am={Controller:Bp,BooleanController:Vp,OptionController:Wp,StringController:jp,NumberController:qp,NumberControllerBox:Yp,NumberControllerSlider:Jp,FunctionController:Kp,ColorController:Qp},Rm={dom:Gp},Cm={GUI:pm},Pm=pm,Im={color:Em,controllers:Am,dom:Rm,gui:Cm,GUI:Pm},Lm=Object.freeze({__proto__:null,color:Em,controllers:Am,dom:Rm,gui:Cm,GUI:Pm,default:Im});var Dm=Object.freeze({__proto__:null,RGBELoader:class extends au{constructor(t){super(t),this.type=it}parse(t){const e=function(t,e){switch(t){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}},n=function(t,e,n){e=e||1024;let i=t.pos,r=-1,a=0,s="",o=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));for(;0>(r=o.indexOf("\n"))&&a<e&&i<t.byteLength;)s+=o,a+=o.length,i+=128,o+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(i,i+128)));return-1<r&&(!1!==n&&(t.pos+=a+r+1),s+o.slice(0,r))},i=function(t,e,n,i){const r=t[e+3],a=Math.pow(2,r-128)/255;n[i+0]=t[e+0]*a,n[i+1]=t[e+1]*a,n[i+2]=t[e+2]*a,n[i+3]=1},r=function(t,e,n,i){const r=t[e+3],a=Math.pow(2,r-128)/255;n[i+0]=Ui.toHalfFloat(Math.min(t[e+0]*a,65504)),n[i+1]=Ui.toHalfFloat(Math.min(t[e+1]*a,65504)),n[i+2]=Ui.toHalfFloat(Math.min(t[e+2]*a,65504)),n[i+3]=Ui.toHalfFloat(1)},a=new Uint8Array(t);a.pos=0;const s=function(t){const i=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,r=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,s=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,o={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;for((t.pos>=t.byteLength||!(l=n(t)))&&e(1,"no header found"),(c=l.match(/^#\?(\S+)/))||e(3,"bad initial token"),o.valid|=1,o.programtype=c[1],o.string+=l+"\n";l=n(t),!1!==l;)if(o.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(i))&&(o.gamma=parseFloat(c[1])),(c=l.match(r))&&(o.exposure=parseFloat(c[1])),(c=l.match(a))&&(o.valid|=2,o.format=c[1]),(c=l.match(s))&&(o.valid|=4,o.height=parseInt(c[1],10),o.width=parseInt(c[2],10)),2&o.valid&&4&o.valid)break}else o.comments+=l+"\n";return 2&o.valid||e(3,"missing format specifier"),4&o.valid||e(3,"missing image size specifier"),o}(a),o=s.width,l=s.height,c=function(t,n,i){const r=n;if(r<8||r>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);r!==(t[2]<<8|t[3])&&e(3,"wrong scanline width");const a=new Uint8Array(4*n*i);a.length||e(4,"unable to allocate buffer space");let s=0,o=0;const l=4*r,c=new Uint8Array(4),h=new Uint8Array(l);let u=i;for(;u>0&&o<t.byteLength;){o+4>t.byteLength&&e(1),c[0]=t[o++],c[1]=t[o++],c[2]=t[o++],c[3]=t[o++],2==c[0]&&2==c[1]&&(c[2]<<8|c[3])==r||e(3,"bad rgbe scanline format");let n,i=0;for(;i<l&&o<t.byteLength;){n=t[o++];const r=n>128;if(r&&(n-=128),(0===n||i+n>l)&&e(3,"bad scanline data"),r){const e=t[o++];for(let t=0;t<n;t++)h[i++]=e}else h.set(t.subarray(o,o+n),i),i+=n,o+=n}const d=r;for(let t=0;t<d;t++){let e=0;a[s]=h[t+e],e+=r,a[s+1]=h[t+e],e+=r,a[s+2]=h[t+e],e+=r,a[s+3]=h[t+e],s+=4}u--}return a}(a.subarray(a.pos),o,l);let h,u,d;switch(this.type){case nt:d=c.length/4;const t=new Float32Array(4*d);for(let e=0;e<d;e++)i(c,4*e,t,4*e);h=t,u=nt;break;case it:d=c.length/4;const e=new Uint16Array(4*d);for(let t=0;t<d;t++)r(c,4*t,e,4*t);h=e,u=it;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:o,height:l,data:h,header:s.string,gamma:s.gamma,exposure:s.exposure,type:u}}setDataType(t){return this.type=t,this}load(t,e,n,i){return super.load(t,(function(t,n){switch(t.type){case nt:case it:t.colorSpace=re,t.minFilter=q,t.magFilter=q,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,i)}}});const Nm=new Yr(-1,1,1,-1,0,1);const Om=new class extends Ji{constructor(){super(),this.setAttribute("position",new Gi([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Gi([0,2,0,0,2,0],2))}};class Um{constructor(t){this._mesh=new mr(Om,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,Nm)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}var Fm=Object.freeze({__proto__:null,Pass:class{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}},FullScreenQuad:Um});const Bm=0,zm=1,km=2,Hm=1.25,Gm=1,Vm=32,Wm=65535,jm=Math.pow(2,-24);class Xm{constructor(){}}function qm(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function Ym(t){let e=-1,n=-1/0;for(let i=0;i<3;i++){const r=t[i+3]-t[i];r>n&&(n=r,e=i)}return e}function Zm(t,e){e.set(t)}function Jm(t,e,n){let i,r;for(let a=0;a<3;a++){const s=a+3;i=t[a],r=e[a],n[a]=i<r?i:r,i=t[s],r=e[s],n[s]=i>r?i:r}}function Km(t,e,n){for(let i=0;i<3;i++){const r=e[t+2*i],a=e[t+2*i+1],s=r-a,o=r+a;s<n[i]&&(n[i]=s),o>n[i+3]&&(n[i+3]=o)}}function Qm(t){const e=t[3]-t[0],n=t[4]-t[1],i=t[5]-t[2];return 2*(e*n+n*i+i*e)}function $m(t,e,n,i,r=null){let a=1/0,s=1/0,o=1/0,l=-1/0,c=-1/0,h=-1/0,u=1/0,d=1/0,p=1/0,m=-1/0,f=-1/0,g=-1/0;const v=null!==r;for(let i=6*e,r=6*(e+n);i<r;i+=6){const e=t[i+0],n=t[i+1],r=e-n,_=e+n;r<a&&(a=r),_>l&&(l=_),v&&e<u&&(u=e),v&&e>m&&(m=e);const y=t[i+2],x=t[i+3],b=y-x,w=y+x;b<s&&(s=b),w>c&&(c=w),v&&y<d&&(d=y),v&&y>f&&(f=y);const M=t[i+4],S=t[i+5],T=M-S,E=M+S;T<o&&(o=T),E>h&&(h=E),v&&M<p&&(p=M),v&&M>g&&(g=M)}i[0]=a,i[1]=s,i[2]=o,i[3]=l,i[4]=c,i[5]=h,v&&(r[0]=u,r[1]=d,r[2]=p,r[3]=m,r[4]=f,r[5]=g)}const tf=32,ef=(t,e)=>t.candidate-e.candidate,nf=new Array(tf).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),rf=new Float32Array(6);function af(t,e){function n(t){d&&d(t/p)}function i(e,r,d,p=null,f=0){if(!m&&f>=l&&(m=!0,c&&(console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),d<=h||f>=l)return n(r+d),e.offset=r,e.count=d,e;const g=function(t,e,n,i,r,a){let s=-1,o=0;if(a===Bm)s=Ym(e),-1!==s&&(o=(e[s]+e[s+3])/2);else if(a===zm)s=Ym(t),-1!==s&&(o=function(t,e,n,i){let r=0;for(let a=e,s=e+n;a<s;a++)r+=t[6*a+2*i];return r/n}(n,i,r,s));else if(a===km){const a=Qm(t);let l=Hm*r;const c=6*i,h=6*(i+r);for(let t=0;t<3;t++){const i=e[t],u=(e[t+3]-i)/tf;if(r<tf/4){const e=[...nf];e.length=r;let i=0;for(let r=c;r<h;r+=6,i++){const a=e[i];a.candidate=n[r+2*t],a.count=0;const{bounds:s,leftCacheBounds:o,rightCacheBounds:l}=a;for(let t=0;t<3;t++)l[t]=1/0,l[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;Km(r,n,s)}e.sort(ef);let u=r;for(let t=0;t<u;t++){const n=e[t];for(;t+1<u&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),u--}for(let i=c;i<h;i+=6){const r=n[i+2*t];for(let t=0;t<u;t++){const a=e[t];r>=a.candidate?Km(i,n,a.rightCacheBounds):(Km(i,n,a.leftCacheBounds),a.count++)}}for(let n=0;n<u;n++){const i=e[n],c=i.count,h=r-i.count,u=i.leftCacheBounds,d=i.rightCacheBounds;let p=0;0!==c&&(p=Qm(u)/a);let m=0;0!==h&&(m=Qm(d)/a);const f=Gm+Hm*(p*c+m*h);f<l&&(s=t,l=f,o=i.candidate)}}else{for(let t=0;t<tf;t++){const e=nf[t];e.count=0,e.candidate=i+u+t*u;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=c;e<h;e+=6){let r=~~((n[e+2*t]-i)/u);r>=tf&&(r=tf-1);const a=nf[r];a.count++,Km(e,n,a.bounds)}const e=nf[tf-1];Zm(e.bounds,e.rightCacheBounds);for(let t=tf-2;t>=0;t--){const e=nf[t],n=nf[t+1];Jm(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let e=0;e<tf-1;e++){const n=nf[e],i=n.count,c=n.bounds,h=nf[e+1].rightCacheBounds;0!==i&&(0===d?Zm(c,rf):Jm(c,rf,rf)),d+=i;let u=0,p=0;0!==d&&(u=Qm(rf)/a);const m=r-d;0!==m&&(p=Qm(h)/a);const f=Gm+Hm*(u*d+p*m);f<l&&(s=t,l=f,o=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:s,pos:o}}(e.boundingData,p,s,r,d,u);if(-1===g.axis)return n(r+d),e.offset=r,e.count=d,e;const v=function(t,e,n,i,r){let a=n,s=n+i-1;const o=r.pos,l=2*r.axis;for(;;){for(;a<=s&&e[6*a+l]<o;)a++;for(;a<=s&&e[6*s+l]>=o;)s--;if(!(a<s))return a;for(let n=0;n<3;n++){let i=t[3*a+n];t[3*a+n]=t[3*s+n],t[3*s+n]=i;let r=e[6*a+2*n+0];e[6*a+2*n+0]=e[6*s+2*n+0],e[6*s+2*n+0]=r;let o=e[6*a+2*n+1];e[6*a+2*n+1]=e[6*s+2*n+1],e[6*s+2*n+1]=o}a++,s--}}(o,s,r,d,g);if(v===r||v===r+d)n(r+d),e.offset=r,e.count=d;else{e.splitAxis=g.axis;const t=new Xm,n=r,o=v-r;e.left=t,t.boundingData=new Float32Array(6),$m(s,n,o,t.boundingData,a),i(t,n,o,a,f+1);const l=new Xm,c=v,h=d-o;e.right=l,l.boundingData=new Float32Array(6),$m(s,c,h,l.boundingData,a),i(l,c,h,a,f+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=n>65535?new Uint32Array(new i(4*n)):new Uint16Array(new i(2*n)),t.setIndex(new zi(r,1));for(let t=0;t<n;t++)r[t]=t}}(t,e);const r=new Float32Array(6),a=new Float32Array(6),s=function(t,e){const n=t.attributes.position,i=t.index.array,r=i.length/3,a=new Float32Array(6*r),s=n.normalized,o=n.array,l=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);const h=["getX","getY","getZ"];for(let t=0;t<r;t++){const r=3*t,u=6*t;let d,p,m;s?(d=i[r+0],p=i[r+1],m=i[r+2]):(d=i[r+0]*c+l,p=i[r+1]*c+l,m=i[r+2]*c+l);for(let t=0;t<3;t++){let i,r,l;s?(i=n[h[t]](d),r=n[h[t]](p),l=n[h[t]](m)):(i=o[d+t],r=o[p+t],l=o[m+t]);let c=i;r<c&&(c=r),l<c&&(c=l);let f=i;r>f&&(f=r),l>f&&(f=l);const g=(f-c)/2,v=2*t;a[u+v+0]=c+g,a[u+v+1]=g+(Math.abs(c)+g)*jm,c<e[t]&&(e[t]=c),f>e[t+3]&&(e[t+3]=f)}}return a}(t,r),o=t.index.array,l=e.maxDepth,c=e.verbose,h=e.maxLeafTris,u=e.strategy,d=e.onProgress,p=t.index.count/3;let m=!1;const f=[],g=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const i=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<i.length-1;t++){const n=i[t],r=i[t+1];e.push({offset:n/3,count:(r-n)/3})}return e}(t);if(1===g.length){const t=g[0],e=new Xm;e.boundingData=r,function(t,e,n,i){let r=1/0,a=1/0,s=1/0,o=-1/0,l=-1/0,c=-1/0;for(let i=6*e,h=6*(e+n);i<h;i+=6){const e=t[i+0];e<r&&(r=e),e>o&&(o=e);const n=t[i+2];n<a&&(a=n),n>l&&(l=n);const h=t[i+4];h<s&&(s=h),h>c&&(c=h)}i[0]=r,i[1]=a,i[2]=s,i[3]=o,i[4]=l,i[5]=c}(s,t.offset,t.count,a),i(e,t.offset,t.count,a),f.push(e)}else for(let t of g){const e=new Xm;e.boundingData=new Float32Array(6),$m(s,t.offset,t.count,e.boundingData,a),i(e,t.offset,t.count,a),f.push(e)}return f}class sf{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const a=t[r][e];n=a<n?a:n,i=a>i?a:i}this.min=n,this.max=i}setFromPoints(t,e){let n=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const a=e[r],s=t.dot(a);n=s<n?s:n,i=s>i?s:i}this.min=n,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}sf.prototype.setFromBox=function(){const t=new cn;return function(e,n){const i=n.min,r=n.max;let a=1/0,s=-1/0;for(let n=0;n<=1;n++)for(let o=0;o<=1;o++)for(let l=0;l<=1;l++){t.x=i.x*n+r.x*(1-n),t.y=i.y*o+r.y*(1-o),t.z=i.z*l+r.z*(1-l);const c=e.dot(t);a=Math.min(c,a),s=Math.max(c,s)}this.min=a,this.max=s}}(),function(){const t=new sf}();const of=function(){const t=new cn,e=new cn,n=new cn;return function(i,r,a){const s=i.start,o=t,l=r.start,c=e;n.subVectors(s,l),t.subVectors(i.end,i.start),e.subVectors(r.end,r.start);const h=n.dot(c),u=c.dot(o),d=c.dot(c),p=n.dot(o),m=o.dot(o)*d-u*u;let f,g;f=0!==m?(h*u-p*d)/m:0,g=(h+f*u)/d,a.x=f,a.y=g}}(),lf=function(){const t=new Ie,e=new cn,n=new cn;return function(i,r,a,s){of(i,r,t);let o=t.x,l=t.y;if(o>=0&&o<=1&&l>=0&&l<=1)return i.at(o,a),void r.at(l,s);if(o>=0&&o<=1)return l<0?r.at(0,s):r.at(1,s),void i.closestPointToPoint(s,!0,a);if(l>=0&&l<=1)return o<0?i.at(0,a):i.at(1,a),void r.closestPointToPoint(a,!0,s);{let t,c;t=o<0?i.start:i.end,c=l<0?r.start:r.end;const h=e,u=n;return i.closestPointToPoint(c,!0,e),r.closestPointToPoint(t,!0,n),h.distanceToSquared(c)<=u.distanceToSquared(t)?(a.copy(h),void s.copy(c)):(a.copy(t),void s.copy(u))}}}(),cf=function(){const t=new cn,e=new cn,n=new Ir,i=new pd;return function(r,a){const{radius:s,center:o}=r,{a:l,b:c,c:h}=a;i.start=l,i.end=c;if(i.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;i.start=l,i.end=h;if(i.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;i.start=c,i.end=h;if(i.closestPointToPoint(o,!0,t).distanceTo(o)<=s)return!0;const u=a.getPlane(n);if(Math.abs(u.distanceToPoint(o))<=s){const t=u.projectPoint(o,e);if(a.containsPoint(t))return!0}return!1}}();function hf(t){return Math.abs(t)<1e-15}class uf extends wi{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new cn)),this.satBounds=new Array(4).fill().map((()=>new sf)),this.points=[this.a,this.b,this.c],this.sphere=new Pn,this.plane=new Ir,this.needsUpdate=!0}intersectsSphere(t){return cf(t,this)}update(){const t=this.a,e=this.b,n=this.c,i=this.points,r=this.satAxes,a=this.satBounds,s=r[0],o=a[0];this.getNormal(s),o.setFromPoints(s,i);const l=r[1],c=a[1];l.subVectors(t,e),c.setFromPoints(l,i);const h=r[2],u=a[2];h.subVectors(e,n),u.setFromPoints(h,i);const d=r[3],p=a[3];d.subVectors(n,t),p.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}uf.prototype.closestPointToSegment=function(){const t=new cn,e=new cn,n=new pd;return function(i,r=null,a=null){const{start:s,end:o}=i,l=this.points;let c,h=1/0;for(let s=0;s<3;s++){const o=(s+1)%3;n.start.copy(l[s]),n.end.copy(l[o]),lf(n,i,t,e),c=t.distanceToSquared(e),c<h&&(h=c,r&&r.copy(t),a&&a.copy(e))}return this.closestPointToPoint(s,t),c=s.distanceToSquared(t),c<h&&(h=c,r&&r.copy(t),a&&a.copy(s)),this.closestPointToPoint(o,t),c=o.distanceToSquared(t),c<h&&(h=c,r&&r.copy(t),a&&a.copy(o)),Math.sqrt(h)}}(),uf.prototype.intersectsTriangle=function(){const t=new uf,e=new Array(3),n=new Array(3),i=new sf,r=new sf,a=new cn,s=new cn,o=new cn,l=new cn,c=new pd,h=new pd,u=new pd;return function(d,p=null,m=!1){this.needsUpdate&&this.update(),d.isExtendedTriangle?d.needsUpdate&&d.update():(t.copy(d),t.update(),d=t);const f=this.plane,g=d.plane;if(Math.abs(f.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,s=this.satAxes;n[0]=d.a,n[1]=d.b,n[2]=d.c;for(let e=0;e<4;e++){const r=t[e],a=s[e];if(i.setFromPoints(a,n),r.isSeparated(i))return!1}const o=d.satBounds,l=d.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=o[t],r=l[t];if(i.setFromPoints(r,e),n.isSeparated(i))return!1}for(let t=0;t<4;t++){const o=s[t];for(let t=0;t<4;t++){const s=l[t];if(a.crossVectors(o,s),i.setFromPoints(a,e),r.setFromPoints(a,n),i.isSeparated(r))return!1}}return p&&(m||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let i=0;i<3;i++){const r=t[i],a=t[(i+1)%3];c.start.copy(r),c.end.copy(a),c.delta(s);const o=e?h.start:h.end,l=hf(g.distanceToPoint(r));if(hf(g.normal.dot(s))&&l){h.copy(c),n=2;break}if((g.intersectLine(c,o)||l)&&!hf(o.distanceTo(a))){if(n++,e)break;e=!0}}if(1===n&&d.containsPoint(h.end))return p&&(p.start.copy(h.end),p.end.copy(h.end)),!0;if(2!==n)return!1;const i=d.points;let r=!1,a=0;for(let t=0;t<3;t++){const e=i[t],n=i[(t+1)%3];c.start.copy(e),c.end.copy(n),c.delta(o);const s=r?u.start:u.end,l=hf(f.distanceToPoint(e));if(hf(f.normal.dot(o))&&l){u.copy(c),a=2;break}if((f.intersectLine(c,s)||l)&&!hf(s.distanceTo(n))){if(a++,r)break;r=!0}}if(1===a&&this.containsPoint(u.end))return p&&(p.start.copy(u.end),p.end.copy(u.end)),!0;if(2!==a)return!1;if(h.delta(s),u.delta(o),s.dot(o)<0){let t=u.start;u.start=u.end,u.end=t}const m=h.start.dot(s),v=h.end.dot(s),_=u.start.dot(s),y=u.end.dot(s);return(m===y||_===v||v<_!==m<y)&&(p&&(l.subVectors(h.start,u.start),l.dot(s)>0?p.start.copy(h.start):p.start.copy(u.start),l.subVectors(h.end,u.end),l.dot(s)<0?p.end.copy(h.end):p.end.copy(u.end)),!0)}}}(),uf.prototype.distanceToPoint=function(){const t=new cn;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),uf.prototype.distanceToTriangle=function(){const t=new cn,e=new cn,n=["a","b","c"],i=new pd,r=new pd;return function(a,s=null,o=null){const l=s||o?i:null;if(this.intersectsTriangle(a,l))return(s||o)&&(s&&l.getCenter(s),o&&l.getCenter(o)),0;let c=1/0;for(let e=0;e<3;e++){let i;const r=n[e],l=a[r];this.closestPointToPoint(l,t),i=l.distanceToSquared(t),i<c&&(c=i,s&&s.copy(t),o&&o.copy(l));const h=this[r];a.closestPointToPoint(h,t),i=h.distanceToSquared(t),i<c&&(c=i,s&&s.copy(h),o&&o.copy(t))}for(let l=0;l<3;l++){const h=n[l],u=n[(l+1)%3];i.set(this[h],this[u]);for(let l=0;l<3;l++){const h=n[l],u=n[(l+1)%3];r.set(a[h],a[u]),lf(i,r,t,e);const d=t.distanceToSquared(e);d<c&&(c=d,s&&s.copy(t),o&&o.copy(e))}}return Math.sqrt(c)}}();class df{constructor(t,e,n){this.isOrientedBox=!0,this.min=new cn,this.max=new cn,this.matrix=new zn,this.invMatrix=new zn,this.points=new Array(8).fill().map((()=>new cn)),this.satAxes=new Array(3).fill().map((()=>new cn)),this.satBounds=new Array(3).fill().map((()=>new sf)),this.alignedSatBounds=new Array(3).fill().map((()=>new sf)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}df.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,i=this.points;for(let r=0;r<=1;r++)for(let a=0;a<=1;a++)for(let s=0;s<=1;s++){const o=i[1*r|2*a|4*s];o.x=r?n.x:e.x,o.y=a?n.y:e.y,o.z=s?n.z:e.z,o.applyMatrix4(t)}const r=this.satBounds,a=this.satAxes,s=i[0];for(let t=0;t<3;t++){const e=a[t],n=r[t],o=i[1<<t];e.subVectors(s,o),n.setFromPoints(e,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},df.prototype.intersectsBox=function(){const t=new sf;return function(e){this.needsUpdate&&this.update();const n=e.min,i=e.max,r=this.satBounds,a=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=i.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=i.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=i.z,s[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const i=a[n],s=r[n];if(t.setFromBox(i,e),s.isSeparated(t))return!1}return!0}}(),df.prototype.intersectsTriangle=function(){const t=new uf,e=new Array(3),n=new sf,i=new sf,r=new cn;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(t.copy(a),t.update(),a=t);const s=this.satBounds,o=this.satAxes;e[0]=a.a,e[1]=a.b,e[2]=a.c;for(let t=0;t<3;t++){const i=s[t],r=o[t];if(n.setFromPoints(r,e),i.isSeparated(n))return!1}const l=a.satBounds,c=a.satAxes,h=this.points;for(let t=0;t<3;t++){const e=l[t],i=c[t];if(n.setFromPoints(i,h),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const a=o[t];for(let t=0;t<4;t++){const s=c[t];if(r.crossVectors(a,s),n.setFromPoints(r,e),i.setFromPoints(r,h),n.isSeparated(i))return!1}}return!0}}(),df.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},df.prototype.distanceToPoint=function(){const t=new cn;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),df.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new pd)),n=new Array(12).fill().map((()=>new pd)),i=new cn,r=new cn;return function(a,s=0,o=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(o||l)&&(a.getCenter(r),this.closestPointToPoint(r,i),a.closestPointToPoint(i,r),o&&o.copy(i),l&&l.copy(r)),0;const c=s*s,h=a.min,u=a.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];r.copy(e).clamp(h,u);const n=e.distanceToSquared(r);if(n<p&&(p=n,o&&o.copy(e),l&&l.copy(r),n<c))return Math.sqrt(n)}let m=0;for(let i=0;i<3;i++)for(let r=0;r<=1;r++)for(let a=0;a<=1;a++){const s=(i+1)%3,o=(i+2)%3,l=1<<i|r<<s|a<<o,c=d[r<<s|a<<o],p=d[l];e[m].set(c,p);const f=t[i],g=t[s],v=t[o],_=n[m],y=_.start,x=_.end;y[f]=h[f],y[g]=r?h[g]:u[g],y[v]=a?h[v]:u[g],x[f]=u[f],x[g]=r?h[g]:u[g],x[v]=a?h[v]:u[g],m++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){r.x=t?u.x:h.x,r.y=e?u.y:h.y,r.z=n?u.z:h.z,this.closestPointToPoint(r,i);const a=r.distanceToSquared(i);if(a<p&&(p=a,o&&o.copy(i),l&&l.copy(r),a<c))return Math.sqrt(a)}for(let t=0;t<12;t++){const a=e[t];for(let t=0;t<12;t++){const e=n[t];lf(a,e,i,r);const s=i.distanceToSquared(r);if(s<p&&(p=s,o&&o.copy(i),l&&l.copy(r),s<c))return Math.sqrt(s)}}return Math.sqrt(p)}}();const pf=new cn,mf=new cn,ff=new cn,gf=new Ie,vf=new Ie,_f=new Ie,yf=new cn;function xf(t,e,n,i,r,a,s){pf.fromBufferAttribute(e,i),mf.fromBufferAttribute(e,r),ff.fromBufferAttribute(e,a);const o=function(t,e,n,i,r,a){let s;return s=a===_?t.intersectTriangle(i,n,e,!0,r):t.intersectTriangle(e,n,i,a!==y,r),null===s?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,pf,mf,ff,yf,s);if(o){n&&(gf.fromBufferAttribute(n,i),vf.fromBufferAttribute(n,r),_f.fromBufferAttribute(n,a),o.uv=wi.getUV(yf,pf,mf,ff,gf,vf,_f,new Ie));const t={a:i,b:r,c:a,normal:new cn,materialIndex:0};wi.getNormal(pf,mf,ff,t.normal),o.face=t,o.faceIndex=i}return o}function bf(t,e,n,i,r){const a=3*i,s=t.index.getX(a),o=t.index.getX(a+1),l=t.index.getX(a+2),c=xf(n,t.attributes.position,t.attributes.uv,s,o,l,e);return c?(c.faceIndex=i,r&&r.push(c),c):null}function wf(t,e,n,i){const r=t.a,a=t.b,s=t.c;let o=e,l=e+1,c=e+2;n&&(o=n.getX(e),l=n.getX(e+1),c=n.getX(e+2)),r.x=i.getX(o),r.y=i.getY(o),r.z=i.getZ(o),a.x=i.getX(l),a.y=i.getY(l),a.z=i.getZ(l),s.x=i.getX(c),s.y=i.getY(c),s.z=i.getZ(c)}function Mf(t,e,n,i,r,a,s){const o=n.index,l=n.attributes.position;for(let n=t,c=e+t;n<c;n++)if(wf(s,3*n,o,l),s.needsUpdate=!0,i(s,n,r,a))return!0;return!1}class Sf{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function Tf(t,e){return 65535===e[t+15]}function Ef(t,e){return e[t+6]}function Af(t,e){return e[t+14]}function Rf(t){return t+8}function Cf(t,e){return e[t+6]}function Pf(t,e){return e[t+7]}const If=new dn,Lf=new cn,Df=["x","y","z"];function Nf(t,e,n,i,r){let a=2*t,s=Hf,o=Gf,l=Vf;if(Tf(a,o)){!function(t,e,n,i,r,a){for(let s=i,o=i+r;s<o;s++)bf(t,e,n,s,a)}(e,n,i,Ef(t,l),Af(a,o),r)}else{const a=Rf(t);Bf(a,s,i,Lf)&&Nf(a,e,n,i,r);const o=Cf(t,l);Bf(o,s,i,Lf)&&Nf(o,e,n,i,r)}}function Of(t,e,n,i){let r=2*t,a=Hf,s=Gf,o=Vf;if(Tf(r,s)){return function(t,e,n,i,r){let a=1/0,s=null;for(let o=i,l=i+r;o<l;o++){const i=bf(t,e,n,o);i&&i.distance<a&&(s=i,a=i.distance)}return s}(e,n,i,Ef(t,o),Af(r,s))}{const r=Pf(t,o),s=Df[r],l=i.direction[s]>=0;let c,h;l?(c=Rf(t),h=Cf(t,o)):(c=Cf(t,o),h=Rf(t));const u=Bf(c,a,i,Lf)?Of(c,e,n,i):null;if(u){const t=u.point[s];if(l?t<=a[h+r]:t>=a[h+r+3])return u}const d=Bf(h,a,i,Lf)?Of(h,e,n,i):null;return u&&d?u.distance<=d.distance?u:d:u||d||null}}const Uf=function(){let t,e;const n=[],i=new Sf((()=>new dn));return function(...a){t=i.getPrimitive(),e=i.getPrimitive(),n.push(t,e);const s=r(...a);i.releasePrimitive(t),i.releasePrimitive(e),n.pop(),n.pop();const o=n.length;return o>0&&(e=n[o-1],t=n[o-2]),s};function r(n,i,a,s,o=null,l=0,c=0){function h(t){let e=2*t,n=Gf,i=Vf;for(;!Tf(e,n);)e=2*(t=Rf(t));return Ef(t,i)}function u(t){let e=2*t,n=Gf,i=Vf;for(;!Tf(e,n);)e=2*(t=Cf(t,i));return Ef(t,i)+Af(e,n)}let d=2*n,p=Hf,m=Gf,f=Vf;if(Tf(d,m)){const e=Ef(n,f),i=Af(d,m);return qm(n,p,t),s(e,i,!1,c,l+n,t)}{const d=Rf(n),g=Cf(n,f);let v,_,y,x,b=d,w=g;if(o&&(y=t,x=e,qm(b,p,y),qm(w,p,x),v=o(y),_=o(x),_<v)){b=g,w=d;const t=v;v=_,_=t,y=x}y||(y=t,qm(b,p,y));const M=a(y,Tf(2*b,m),v,c+1,l+b);let S;if(2===M){const t=h(b);S=s(t,u(b)-t,!0,c+1,l+b,y)}else S=M&&r(b,i,a,s,o,l,c+1);if(S)return!0;x=e,qm(w,p,x);const T=a(x,Tf(2*w,m),_,c+1,l+w);let E;if(2===T){const t=h(w);E=s(t,u(w)-t,!0,c+1,l+w,x)}else E=T&&r(w,i,a,s,o,l,c+1);return!!E}}}(),Ff=function(){const t=new uf,e=new uf,n=new zn,i=new df,r=new df;return function a(s,o,l,c,h=null){let u=2*s,d=Hf,p=Gf,m=Vf;null===h&&(l.boundingBox||l.computeBoundingBox(),i.set(l.boundingBox.min,l.boundingBox.max,c),h=i);if(!Tf(u,p)){const t=s+8,e=m[s+6];qm(t,d,If);if(h.intersectsBox(If)&&a(t,o,l,c,h))return!0;qm(e,d,If);return!!(h.intersectsBox(If)&&a(e,o,l,c,h))}{const i=o,a=i.index,h=i.attributes.position,f=l.index,g=l.attributes.position,v=Ef(s,m),_=Af(u,p);if(n.copy(c).invert(),l.boundsTree){qm(s,d,r),r.matrix.copy(n),r.needsUpdate=!0;return l.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(c),t.b.applyMatrix4(c),t.c.applyMatrix4(c),t.needsUpdate=!0;for(let n=3*v,i=3*(_+v);n<i;n+=3)if(wf(e,n,a,h),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}})}for(let i=3*v,r=_+3*v;i<r;i+=3){wf(t,i,a,h),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,i=f.count;n<i;n+=3)if(wf(e,n,f,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function Bf(t,e,n,i){return qm(t,e,If),n.intersectBox(If,i)}const zf=[];let kf,Hf,Gf,Vf;function Wf(t){kf&&zf.push(kf),kf=t,Hf=new Float32Array(t),Gf=new Uint16Array(t),Vf=new Uint32Array(t)}function jf(){kf=null,Hf=null,Gf=null,Vf=null,zf.length&&Wf(zf.pop())}const Xf=Symbol("skip tree generation"),qf=new dn,Yf=new dn,Zf=new zn,Jf=new df,Kf=new df,Qf=new cn,$f=new cn,tg=new cn,eg=new cn,ng=new cn,ig=new dn,rg=new Sf((()=>new uf));class ag{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ag.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,i=t._roots,r=n.getIndex();let a;return a=e.cloneBuffers?{roots:i.map((t=>t.slice())),index:r.array.slice()}:{roots:i,index:r.array},a}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ag.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:i,roots:r}=t,a=new ag(e,{...n,[Xf]:!0});if(a._roots=r,n.setIndex){const n=e.getIndex();if(null===n){const n=new zi(t.index,1,!1);e.setIndex(n)}else n.array!==i&&(n.array.set(i),n.needsUpdate=!0)}return a}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:Bm,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Xf]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[Xf]||(this._roots=function(t,e){const n=af(t,e);let i,r,a;const s=[],o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let h=l(e);const u=new o(Vm*h);i=new Float32Array(u),r=new Uint32Array(u),a=new Uint16Array(u),c(0,e),s.push(u)}return s;function l(t){return t.count?1:1+l(t.left)+l(t.right)}function c(t,e){const n=t/4,s=t/2,o=!!e.count,l=e.boundingData;for(let t=0;t<6;t++)i[n+t]=l[t];if(o){const i=e.offset,o=e.count;return r[n+6]=i,a[s+14]=o,a[s+15]=Wm,t+Vm}{const i=e.left,a=e.right,s=e.splitAxis;let o;if(o=c(t+Vm,i),o/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return r[n+6]=o/4,o=c(o,a),r[n+7]=s,o}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new dn))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,i=e.attributes.position;let r,a,s,o,l=0;const c=this._roots;for(let t=0,e=c.length;t<e;t++)r=c[t],a=new Uint32Array(r),s=new Uint16Array(r),o=new Float32Array(r),h(0,l),l+=r.byteLength;function h(e,r,l=!1){const c=2*e;if(s[c+15]===Wm){const t=a[e+6];let r=1/0,l=1/0,h=1/0,u=-1/0,d=-1/0,p=-1/0;for(let e=3*t,a=3*(t+s[c+14]);e<a;e++){const t=n[e],a=i.getX(t),s=i.getY(t),o=i.getZ(t);a<r&&(r=a),a>u&&(u=a),s<l&&(l=s),s>d&&(d=s),o<h&&(h=o),o>p&&(p=o)}return(o[e+0]!==r||o[e+1]!==l||o[e+2]!==h||o[e+3]!==u||o[e+4]!==d||o[e+5]!==p)&&(o[e+0]=r,o[e+1]=l,o[e+2]=h,o[e+3]=u,o[e+4]=d,o[e+5]=p,!0)}{const n=e+8,i=a[e+6],s=n+r,c=i+r;let u=l,d=!1,p=!1;t?u||(d=t.has(s),p=t.has(c),u=!d&&!p):(d=!0,p=!0);const m=u||p;let f=!1;(u||d)&&(f=h(n,r,u));let g=!1;m&&(g=h(i,r,u));const v=f||g;if(v)for(let t=0;t<3;t++){const r=n+t,a=i+t,s=o[r],l=o[r+3],c=o[a],h=o[a+3];o[e+t]=s<c?s:c,o[e+t+3]=l>h?l:h}return v}}}traverse(t,e=0){const n=this._roots[e],i=new Uint32Array(n),r=new Uint16Array(n);!function e(a,s=0){const o=2*a,l=r[o+15]===Wm;if(l){const e=i[a+6],c=r[o+14];t(s,l,new Float32Array(n,4*a,6),e,c)}else{const r=a+8,o=i[a+6],c=i[a+7];t(s,l,new Float32Array(n,4*a,6),c)||(e(r,s+1),e(o,s+1))}}(0)}raycast(t,e=v){const n=this._roots,i=this.geometry,r=[],a=e.isMaterial,s=Array.isArray(e),o=i.groups,l=a?e.side:e;for(let a=0,c=n.length;a<c;a++){const c=s?e[o[a].materialIndex].side:l,h=r.length;if(Wf(n[a]),Nf(0,i,c,t,r),jf(),s){const t=o[a].materialIndex;for(let e=h,n=r.length;e<n;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=v){const n=this._roots,i=this.geometry,r=e.isMaterial,a=Array.isArray(e);let s=null;const o=i.groups,l=r?e.side:e;for(let r=0,c=n.length;r<c;r++){const c=a?e[o[r].materialIndex].side:l;Wf(n[r]);const h=Of(0,i,c,t);jf(),null!=h&&(null==s||h.distance<s.distance)&&(s=h,a&&(h.face.materialIndex=o[r].materialIndex))}return s}intersectsGeometry(t,e){const n=this.geometry;let i=!1;for(const r of this._roots)if(Wf(r),i=Ff(0,n,t,e),jf(),i)break;return i}shapecast(t,e,n){const i=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,i,r)=>{const a=3*n;return t(e,a,a+1,a+2,i,r)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=rg.getPrimitive();let{boundsTraverseOrder:a,intersectsBounds:s,intersectsRange:o,intersectsTriangle:l}=t;if(o&&l){const t=o;o=(e,n,a,s,o)=>!!t(e,n,a,s,o)||Mf(e,n,i,l,a,s,r)}else o||(o=l?(t,e,n,a)=>Mf(t,e,i,l,n,a,r):(t,e,n)=>n);let c=!1,h=0;for(const t of this._roots){if(Wf(t),c=Uf(0,i,s,o,a,h),jf(),c)break;h+=t.byteLength}return rg.releasePrimitive(r),c}bvhcast(t,e,n){let{intersectsRanges:i,intersectsTriangles:r}=n;const a=this.geometry.index,s=this.geometry.attributes.position,o=t.geometry.index,l=t.geometry.attributes.position;Zf.copy(e).invert();const c=rg.getPrimitive(),h=rg.getPrimitive();if(r){function d(t,n,i,u,d,p,m,f){for(let g=i,v=i+u;g<v;g++){wf(h,3*g,o,l),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let e=t,i=t+n;e<i;e++)if(wf(c,3*e,a,s),c.needsUpdate=!0,r(c,h,e,g,d,p,m,f))return!0}return!1}if(i){const p=i;i=function(t,e,n,i,r,a,s,o){return!!p(t,e,n,i,r,a,s,o)||d(t,e,n,i,r,a,s,o)}}else i=d}t.getBoundingBox(Yf),Yf.applyMatrix4(e);const u=this.shapecast({intersectsBounds:t=>Yf.intersectsBox(t),intersectsRange:(e,n,r,a,s,o)=>(qf.copy(o),qf.applyMatrix4(Zf),t.shapecast({intersectsBounds:t=>qf.intersectsBox(t),intersectsRange:(t,r,o,l,c)=>i(e,n,t,r,a,s,l,c)}))});return rg.releasePrimitive(c),rg.releasePrimitive(h),u}intersectsBox(t,e){return Jf.set(t.min,t.max,e),Jf.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Jf.intersectsBox(t),intersectsTriangle:t=>Jf.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},i={},r=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Jf.set(t.boundingBox.min,t.boundingBox.max,e),Jf.needsUpdate=!0;const s=this.geometry,o=s.attributes.position,l=s.index,c=t.attributes.position,h=t.index,u=rg.getPrimitive(),d=rg.getPrimitive();let p=$f,m=tg,f=null,g=null;i&&(f=eg,g=ng);let v=1/0,_=null,y=null;return Zf.copy(e).invert(),Kf.matrix.copy(Zf),this.shapecast({boundsTraverseOrder:t=>Jf.distanceToBox(t),intersectsBounds:(t,e,n)=>n<v&&n<a&&(e&&(Kf.min.copy(t.min),Kf.max.copy(t.max),Kf.needsUpdate=!0),!0),intersectsRange:(n,i)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Kf.distanceToBox(t),intersectsBounds:(t,e,n)=>n<v&&n<a,intersectsRange:(t,a)=>{for(let s=3*t,x=3*(t+a);s<x;s+=3){wf(d,s,h,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let t=3*n,e=3*(n+i);t<e;t+=3){wf(u,t,l,o),u.needsUpdate=!0;const e=u.distanceToTriangle(d,p,f);if(e<v&&(m.copy(p),g&&g.copy(f),v=e,_=t/3,y=s/3),e<r)return!0}}}});for(let t=0,a=h?h.count:c.count;t<a;t+=3){wf(d,t,h,c),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let e=3*n,a=3*(n+i);e<a;e+=3){wf(u,e,l,o),u.needsUpdate=!0;const n=u.distanceToTriangle(d,p,f);if(n<v&&(m.copy(p),g&&g.copy(f),v=n,_=e/3,y=t/3),n<r)return!0}}}}),rg.releasePrimitive(u),rg.releasePrimitive(d),v===1/0?null:(n.point?n.point.copy(m):n.point=m.clone(),n.distance=v,n.faceIndex=_,i&&(i.point?i.point.copy(g):i.point=g.clone(),i.point.applyMatrix4(Zf),m.applyMatrix4(Zf),i.distance=m.sub(i.point).length(),i.faceIndex=y),n)}closestPointToPoint(t,e={},n=0,i=1/0){const r=n*n,a=i*i;let s=1/0,o=null;if(this.shapecast({boundsTraverseOrder:e=>(Qf.copy(t).clamp(e.min,e.max),Qf.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<s&&n<a,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,Qf);const i=t.distanceToSquared(Qf);return i<s&&($f.copy(Qf),s=i,o=n),i<r}}),s===1/0)return null;const l=Math.sqrt(s);return e.point?e.point.copy($f):e.point=$f.clone(),e.distance=l,e.faceIndex=o,e}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{qm(0,new Float32Array(e),ig),t.union(ig)})),t}}function sg(t){switch(t){case 1:return ut;case 2:return pt;case 3:case 4:return mt}}class og extends il{constructor(){super(),this.minFilter=W,this.magFilter=W,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,i=t.count;if(null!==e){if(n*i%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=i*n/e}const r=t.itemSize,a=t.count,s=t.normalized,o=t.array.constructor,l=o.BYTES_PER_ELEMENT;let c,h,u,d,p=this._forcedType,m=r;if(null===p)switch(o){case Float32Array:p=nt;break;case Uint8Array:case Uint16Array:case Uint32Array:p=et;break;case Int8Array:case Int16Array:case Int32Array:p=tt}let f=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(r);switch(p){case nt:u=1,h=function(t){switch(t){case 1:return ht;case 2:return dt;case 3:case 4:return ot}}(r),s&&1===l?(d=o,f+="8",o===Uint8Array?c=J:(c=K,f+="_SNORM")):(d=Float32Array,f+="32F",c=nt);break;case tt:f+=8*l+"I",u=s?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,h=sg(r),1===l?(d=Int8Array,c=K):2===l?(d=Int16Array,c=Q):(d=Int32Array,c=tt);break;case et:f+=8*l+"UI",u=s?Math.pow(2,8*o.BYTES_PER_ELEMENT-1):1,h=sg(r),1===l?(d=Uint8Array,c=J):2===l?(d=Uint16Array,c=$):(d=Uint32Array,c=et)}3!==m||h!==ot&&h!==mt||(m=4);const g=Math.ceil(Math.sqrt(a)),v=new d(m*g*g),_=t.normalized;t.normalized=!1;for(let e=0;e<a;e++){const n=m*e;v[n]=t.getX(e)/u,r>=2&&(v[n+1]=t.getY(e)/u),r>=3&&(v[n+2]=t.getZ(e)/u,4===m&&(v[n+3]=1)),r>=4&&(v[n+3]=t.getW(e)/u)}t.normalized=_,this.internalFormat=f,this.format=h,this.type=c,this.image.width=g,this.image.height=g,this.image.data=v,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=i}}class lg extends og{constructor(){super(),this._forcedType=et}}class cg extends og{constructor(){super(),this._forcedType=nt}}class hg{constructor(){this.autoDispose=!0,this.index=new lg,this.position=new cg,this.bvhBounds=new il,this.bvhContents=new il,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const i=t._roots;if(1!==i.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const r=i[0],a=new Uint16Array(r),s=new Uint32Array(r),o=new Float32Array(r),l=r.byteLength/Vm,c=2*Math.ceil(Math.sqrt(l/2)),h=new Float32Array(4*c*c),u=Math.ceil(Math.sqrt(l)),d=new Uint32Array(2*u*u);for(let t=0;t<l;t++){const e=t*Vm/4,n=2*e,i=e;for(let e=0;e<3;e++)h[8*t+0+e]=o[i+0+e],h[8*t+4+e]=o[i+3+e];if(Tf(n,a)){const i=Af(n,a),r=Ef(e,s),o=4294901760|i;d[2*t+0]=o,d[2*t+1]=r}else{const n=4*Cf(e,s)/Vm,i=Pf(e,s);d[2*t+0]=i,d[2*t+1]=n}}e.image.data=h,e.image.width=c,e.image.height=c,e.format=ot,e.type=nt,e.internalFormat="RGBA32F",e.minFilter=W,e.magFilter=W,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=d,n.image.width=u,n.image.height=u,n.format=pt,n.type=et,n.internalFormat="RG32UI",n.minFilter=W,n.magFilter=W,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:i}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),i&&i.dispose()}}const ug=new cn,dg=new cn,pg=new cn,mg=new en,fg=new cn,gg=new cn,vg=new en,_g=new en,yg=new zn,xg=new zn;function bg(t,e){if(!t&&!e)return;const n=t.count===e.count,i=t.normalized===e.normalized,r=t.array.constructor===e.array.constructor,a=t.itemSize===e.itemSize;if(!(n&&i&&r&&a))throw new Error}function wg(t,e=null){const n=t.array.constructor,i=t.normalized,r=t.itemSize,a=null===e?t.count:e;return new zi(new n(r*a),r,i)}function Mg(t,e,n=0){if(t.isInterleavedBufferAttribute){const i=t.itemSize;for(let r=0,a=t.count;r<a;r++){const a=r+n;e.setX(a,t.getX(r)),i>=2&&e.setY(a,t.getY(r)),i>=3&&e.setZ(a,t.getZ(r)),i>=4&&e.setW(a,t.getW(r))}}else{const i=e.array,r=i.constructor,a=i.BYTES_PER_ELEMENT*t.itemSize*n;new r(i.buffer,a,t.array.length).set(t.array)}}function Sg(t,e,n){const i=t.elements,r=e.elements;for(let t=0,e=r.length;t<e;t++)i[t]+=r[t]*n}function Tg(t,e,n){const i=t.skeleton,r=t.geometry,a=i.bones,s=i.boneInverses;vg.fromBufferAttribute(r.attributes.skinIndex,e),_g.fromBufferAttribute(r.attributes.skinWeight,e),yg.elements.fill(0);for(let t=0;t<4;t++){const e=_g.getComponent(t);if(0!==e){const n=vg.getComponent(t);xg.multiplyMatrices(a[n].matrixWorld,s[n]),Sg(yg,xg,e)}}return yg.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(yg),n}function Eg(t,e,n,i,r){fg.set(0,0,0);for(let a=0,s=t.length;a<s;a++){const s=e[a],o=t[a];0!==s&&(gg.fromBufferAttribute(o,i),n?fg.addScaledVector(gg,s):fg.addScaledVector(gg.sub(r),s))}r.add(fg)}class Ag{constructor(t){this.matrixWorld=new zn,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,i=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=i,n){n.boneTexture||n.computeBoneTexture(),n.update();const t=n.boneMatrices;this.boneMatrices&&this.boneMatrices.length===t.length?this.boneMatrices.set(t):this.boneMatrices=t.slice()}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&function(t,e){if(null===t||null===e)return t===e;if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class Rg{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach((t=>{t.traverseVisible((t=>{t.isMesh&&e.push(t)}))})),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map((()=>new Ji)),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach((e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)})),t}generate(t=new Ji){let e=[];const{meshes:n,useGroups:i,_intermediateGeometry:r,_diffMap:a}=this;for(let t=0,i=n.length;t<i;t++){const i=n[t],s=r[t],o=a.get(i);!o||o.didChange(i)?(this._convertToStaticGeometry(i,s),e.push(!1),o?o.update():a.set(i,new Ag(i))):e.push(!0)}!function(t,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},n=new Ji){const i=null!==t[0].index,{useGroups:r=!1,updateIndex:a=!1,skipAttributes:s=[]}=e,o=new Set(Object.keys(t[0].attributes)),l={};let c=0;n.clearGroups();for(let e=0;e<t.length;++e){const a=t[e];let s=0;if(i!==(null!==a.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in a.attributes){if(!o.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');void 0===l[t]&&(l[t]=[]),l[t].push(a.attributes[t]),s++}if(s!==o.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(r){let t;if(i)t=a.index.count;else{if(void 0===a.attributes.position)throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t=a.attributes.position.count}n.addGroup(c,t,e),c+=t}}if(i){let e=!1;if(!n.index){let i=0;for(let e=0;e<t.length;++e)i+=t[e].index.count;n.setIndex(new zi(new Uint32Array(i),1,!1)),e=!0}if(a||e){const e=n.index;let i=0,r=0;for(let n=0;n<t.length;++n){const a=t[n],o=a.index;if(!0!==s[n])for(let t=0;t<o.count;++t)e.setX(i,o.getX(t)+r),i++;r+=a.attributes.position.count}}}for(const t in l){const e=l[t];if(!(t in n.attributes)){let i=0;for(const t in e)i+=e[t].count;n.setAttribute(t,wg(l[t][0],i))}const i=n.attributes[t];let r=0;for(let t=0,n=e.length;t<n;t++){const n=e[t];!0!==s[t]&&Mg(n,i,r),r+=n.count}}}(r,{useGroups:i,skipAttributes:e},t);for(const e in t.attributes)t.attributes[e].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new Ji){const n=t.geometry,i=this.applyWorldTransforms,r=this.attributes.includes("normal"),a=this.attributes.includes("tangent"),s=n.attributes,o=e.attributes;e.index||(e.index=n.index),o.position||e.setAttribute("position",wg(s.position)),r&&!o.normal&&s.normal&&e.setAttribute("normal",wg(s.normal)),a&&!o.tangent&&s.tangent&&e.setAttribute("tangent",wg(s.tangent)),bg(n.index,e.index),bg(s.position,o.position),r&&bg(s.normal,o.normal),a&&bg(s.tangent,o.tangent);const l=s.position,c=r?s.normal:null,h=a?s.tangent:null,u=n.morphAttributes.position,d=n.morphAttributes.normal,p=n.morphAttributes.tangent,m=n.morphTargetsRelative,f=t.morphTargetInfluences,g=new Le;g.getNormalMatrix(t.matrixWorld);for(let e=0,n=s.position.count;e<n;e++)ug.fromBufferAttribute(l,e),c&&dg.fromBufferAttribute(c,e),h&&(mg.fromBufferAttribute(h,e),pg.fromBufferAttribute(h,e)),f&&(u&&Eg(u,f,m,e,ug),d&&Eg(d,f,m,e,dg),p&&Eg(p,f,m,e,pg)),t.isSkinnedMesh&&(t.boneTransform(e,ug),c&&Tg(t,e,dg),h&&Tg(t,e,pg)),i&&ug.applyMatrix4(t.matrixWorld),o.position.setXYZ(e,ug.x,ug.y,ug.z),c&&(i&&dg.applyNormalMatrix(g),o.normal.setXYZ(e,dg.x,dg.y,dg.z)),h&&(i&&pg.transformDirection(t.matrixWorld),o.tangent.setXYZW(e,pg.x,pg.y,pg.z,mg.w));for(const t in this.attributes){const n=this.attributes[t];"position"!==n&&"tangent"!==n&&"normal"!==n&&n in s&&(o[n]||e.setAttribute(n,wg(s[n])),bg(s[n],o[n]),Mg(s[n],o[n]))}return e}}function Cg(t){let e,n,i,r=-1,a=0;for(let s=0;s<t.length;++s){const o=t[s];if(o.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===e&&(e=o.array.constructor),e!==o.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=o.itemSize),n!==o.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=o.normalized),i!==o.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===r&&(r=o.gpuType),r!==o.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;a+=o.array.length}const s=new e(a);let o=0;for(let e=0;e<t.length;++e)s.set(t[e].array,o),o+=t[e].array.length;const l=new zi(s,n,i);return void 0!==r&&(l.gpuType=r),l}function Pg(t,e=!1){return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."),function(t,e=!1){const n=null!==t[0].index,i=new Set(Object.keys(t[0].attributes)),r=new Set(Object.keys(t[0].morphAttributes)),a={},s={},o=t[0].morphTargetsRelative,l=new Ji;let c=0;for(let h=0;h<t.length;++h){const u=t[h];let d=0;if(n!==(null!==u.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in u.attributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[t]&&(a[t]=[]),a[t].push(u.attributes[t]),d++}if(d!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". Make sure all geometries have the same number of attributes."),null;if(o!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in u.morphAttributes){if(!r.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[t]&&(s[t]=[]),s[t].push(u.morphAttributes[t])}if(e){let t;if(n)t=u.index.count;else{if(void 0===u.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+h+". The geometry must have either an index or a position attribute"),null;t=u.attributes.position.count}l.addGroup(c,t,h),c+=t}}if(n){let e=0;const n=[];for(let i=0;i<t.length;++i){const r=t[i].index;for(let t=0;t<r.count;++t)n.push(r.getX(t)+e);e+=t[i].attributes.position.count}l.setIndex(n)}for(const t in a){const e=Cg(a[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute."),null;l.setAttribute(t,e)}for(const t in s){const e=s[t][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[t]=[];for(let n=0;n<e;++n){const e=[];for(let i=0;i<s[t].length;++i)e.push(s[t][i][n]);const i=Cg(e);if(!i)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute."),null;l.morphAttributes[t].push(i)}}return l}(t,e)}class Ig extends br{constructor(t){super(t);for(const t in this.uniforms)Object.defineProperty(this,t,{get(){return this.uniforms[t].value},set(e){this.uniforms[t].value=e}})}setDefine(t,e=void 0){null==e?t in this.defines&&(delete this.defines[t],this.needsUpdate=!0):this.defines[t]!==e&&(this.defines[t]=e,this.needsUpdate=!0)}}class Lg extends Ig{constructor(t){super({blending:0,uniforms:{target1:{value:null},target2:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tuniform sampler2D target1;\n\t\t\t\tuniform sampler2D target2;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\n\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\n\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\n\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}"}),this.setValues(t)}}function Dg(t=1){let e="uint";return t>1&&(e="uvec"+t),`\n\t\t${e} sobolReverseBits( ${e} x ) {\n\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\n\n\t\t}\n\n\t\t${e} sobolHashCombine( uint seed, ${e} v ) {\n\n\t\t\treturn seed ^ ( v + ${e}( ( seed << 6 ) + ( seed >> 2 ) ) );\n\n\t\t}\n\n\t\t${e} sobolLaineKarrasPermutation( ${e} x, ${e} seed ) {\n\n\t\t\tx += seed;\n\t\t\tx ^= x * 0x6c50b47cu;\n\t\t\tx ^= x * 0xb82f1e52u;\n\t\t\tx ^= x * 0xc7afe638u;\n\t\t\tx ^= x * 0x8d22f6e6u;\n\t\t\treturn x;\n\n\t\t}\n\n\t\t${e} nestedUniformScrambleBase2( ${e} x, ${e} seed ) {\n\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\n\t\t\tx = sobolReverseBits( x );\n\t\t\treturn x;\n\n\t\t}\n\t`}function Ng(t=1){let e="uint",n="float",i="",r=".r",a="1u";return t>1&&(e="uvec"+t,n="vec"+t,i=t+"",2===t?(r=".rg",a="uvec2( 1u, 2u )"):3===t?(r=".rgb",a="uvec3( 1u, 2u, 3u )"):(r="",a="uvec4( 1u, 2u, 3u, 4u )")),`\n\n\t\t${n} sobol${i}( int effect ) {\n\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\n\t\t\tuint index = sobolPathIndex;\n\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\n\t\t\t${n} sobol_pt = sobolGetTexturePoint( shuffled_index )${r};\n\t\t\t${e} result = ${e}( sobol_pt * 16777216.0 );\n\n\t\t\t${e} seed2 = sobolHashCombine( seed, ${a} );\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\n\n\t\t\treturn SOBOL_FACTOR * ${n}( result >> 8 );\n\n\t\t}\n\t`}const Og=`\n\n\t// Utils\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\n\n\t${Dg(1)}\n\t${Dg(2)}\n\t${Dg(3)}\n\t${Dg(4)}\n\n\tuint sobolHash( uint x ) {\n\n\t\t// finalizer from murmurhash3\n\t\tx ^= x >> 16;\n\t\tx *= 0x85ebca6bu;\n\t\tx ^= x >> 13;\n\t\tx *= 0xc2b2ae35u;\n\t\tx ^= x >> 16;\n\t\treturn x;\n\n\t}\n\n`,Ug=`\n\n\t// Seeds\n\tuniform sampler2D sobolTexture;\n\tuint sobolPixelIndex;\n\tuint sobolPathIndex;\n\tuint sobolBounceIndex;\n\n\tuint sobolGetSeed( uint bounce, uint effect ) {\n\n\t\treturn sobolHash(\n\t\t\tsobolHashCombine(\n\t\t\t\tsobolHashCombine(\n\t\t\t\t\tsobolHash( bounce ),\n\t\t\t\t\tsobolPixelIndex\n\t\t\t\t),\n\t\t\t\teffect\n\t\t\t)\n\t\t);\n\n\t}\n\n\tvec4 sobolGetTexturePoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\tindex = index % SOBOL_MAX_POINTS;\n\n\t\t}\n\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\n\t\tuint y = index / dim.x;\n\t\tuint x = index - y * dim.x;\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\n\t\treturn texture( sobolTexture, uv );\n\n\t}\n\n\t${Ng(1)}\n\t${Ng(2)}\n\t${Ng(3)}\n\t${Ng(4)}\n\n`;class Fg extends Ig{constructor(){super({blending:0,uniforms:{resolution:{value:new Ie}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:`\n\n\t\t\t\t${Og}\n\t\t\t\t\n\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\n\t);\n\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n\t);\n\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\n\n\t\tuint X = 0u;\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\n\n\t\t\tuint mask = ( index >> bit ) & 1u;\n\t\t\tX ^= mask * directions[ bit ];\n\n\t\t}\n\t\treturn X;\n\n\t}\n\n\tvec4 generateSobolPoint( uint index ) {\n\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\n\n\t\t\treturn vec4( 0.0 );\n\n\t\t}\n\n\t\t// NOTEL this sobol "direction" is also available but we can't write out 5 components\n\t\t// uint x = index & 0x00ffffffu;\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\n\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\n\n\t}\n\n\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\n\n\t\t\t\t}\n\t\t\t`})}}class Bg{generate(t,e=256){const n=new rn(e,e,{type:nt,format:ot,minFilter:W,magFilter:W,generateMipmaps:!1}),i=t.getRenderTarget();t.setRenderTarget(n);const r=new Um(new Fg);return r.material.resolution.set(e,e),r.render(t),t.setRenderTarget(i),r.dispose(),n}}const zg=new en,kg=new en;function*Hg(){const{_renderer:t,_fsQuad:e,_blendQuad:n,_primaryTarget:i,_blendTargets:r,_sobolTarget:a,_subframe:s,alpha:o,camera:l,material:c}=this,h=new en,u=new en,d=n.material;let[p,m]=r;for(;;){o?(d.opacity=this._opacityFactor/(this._samples+1),c.blending=0,c.opacity=1):(c.opacity=this._opacityFactor/(this._samples+1),c.blending=1);const[r,f,g,v]=s,_=i.width,y=i.height;c.resolution.set(_*g,y*v),c.sobolTexture=a.texture,c.seed++;const x=this.tiles.x||1,b=this.tiles.y||1,w=x*b,M=1/t.getPixelRatio();for(let a=0;a<b;a++)for(let s=0;s<x;s++){c.cameraWorldMatrix.copy(l.matrixWorld),c.invProjectionMatrix.copy(l.projectionMatrixInverse);let S=0;l.projectionMatrix.elements[15]>0&&(S=1),l.isEquirectCamera&&(S=2),c.setDefine("CAMERA_TYPE",S);const T=t.getRenderTarget(),E=t.autoClear,A=t.getScissorTest();t.getScissor(h),t.getViewport(u);let R=s,C=a;if(!this.stableTiles){const t=this._currentTile%(x*b);R=t%x,C=~~(t/x),this._currentTile=t+1}t.setRenderTarget(i),t.setScissorTest(!0),zg.x=R*_/x,zg.y=(b-C-1)*y/b,zg.z=_/x,zg.w=y/b,zg.x=r*_+g*zg.x,zg.y=f*y+v*zg.y,zg.z=g*zg.z,zg.w=v*zg.w,zg.x=zg.x,zg.y=zg.y,zg.z=zg.z,zg.w=zg.w,zg.multiplyScalar(M).ceil(),kg.x=r*_,kg.y=f*y,kg.z=g*_,kg.w=v*y,kg.multiplyScalar(M).ceil(),t.setScissor(zg),t.setViewport(kg),t.autoClear=!1,e.render(t),t.setViewport(u),t.setScissor(h),t.setScissorTest(A),t.setRenderTarget(T),t.autoClear=E,o&&(d.target1=p.texture,d.target2=i.texture,t.setRenderTarget(m),n.render(t),t.setRenderTarget(T)),this._samples+=1/w,s===x-1&&a===b-1&&(this._samples=Math.round(this._samples)),yield}[p,m]=[m,p]}}const Gg=new Ai;class Vg{get material(){return this._fsQuad.material}set material(t){this._fsQuad.material=t}get target(){return this._alpha?this._blendTargets[1]:this._primaryTarget}set alpha(t){this._alpha!==t&&(t||(this._blendTargets[0].dispose(),this._blendTargets[1].dispose()),this._alpha=t,this.reset())}get alpha(){return this._alpha}get samples(){return this._samples}constructor(t){this.camera=null,this.tiles=new Ie(1,1),this.stableNoise=!1,this.stableTiles=!0,this._samples=0,this._subframe=new en(0,0,1,1),this._opacityFactor=1,this._renderer=t,this._alpha=!1,this._fsQuad=new Um(null),this._blendQuad=new Um(new Lg),this._task=null,this._currentTile=0,this._sobolTarget=(new Bg).generate(t),this._primaryTarget=new rn(1,1,{format:ot,type:nt}),this._blendTargets=[new rn(1,1,{format:ot,type:nt}),new rn(1,1,{format:ot,type:nt})]}setSize(t,e){t=Math.ceil(t),e=Math.ceil(e),this._primaryTarget.width===t&&this._primaryTarget.height===e||(this._primaryTarget.setSize(t,e),this._blendTargets[0].setSize(t,e),this._blendTargets[1].setSize(t,e),this.reset())}dispose(){this._primaryTarget.dispose(),this._blendTargets[0].dispose(),this._blendTargets[1].dispose(),this._sobolTarget.dispose(),this._fsQuad.dispose(),this._blendQuad.dispose(),this._task=null}reset(){const{_renderer:t,_primaryTarget:e,_blendTargets:n}=this,i=t.getRenderTarget(),r=t.getClearAlpha();t.getClearColor(Gg),t.setRenderTarget(e),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[0]),t.setClearColor(0,0),t.clearColor(),t.setRenderTarget(n[1]),t.setClearColor(0,0),t.clearColor(),t.setClearColor(Gg,r),t.setRenderTarget(i),this._samples=0,this._task=null,this.stableNoise&&(this.material.seed=0)}update(){this._task||(this._task=Hg.call(this)),this._task.next()}}function*Wg(t){const{viewCount:e,_camera:n,_quiltUtility:i,_subframe:r}=this,a={subframe:r,projectionMatrix:n.projectionMatrix,offsetDirection:new cn};for(;;){for(let r=0;r<e;r++){i.near=this.camera.near,i.far=this.camera.far,i.getCameraViewInfo(r,a),a.offsetDirection.transformDirection(this.camera.matrixWorld),this.camera.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.position.addScaledVector(a.offsetDirection,a.offset),n.updateMatrixWorld(),n.projectionMatrixInverse.copy(n.projectionMatrix).invert(),this._opacityFactor=Math.floor(this._samples+1)/Math.floor(this._quiltSamples+1);do{const e=this.camera;this.camera=n,t(),this.camera=e,yield}while(this._samples%1!=0);this._quiltSamples+=1/e}this._quiltSamples=Math.round(this._quiltSamples)}}class jg{constructor(){this.viewCount=48,this.quiltDimensions=new Ie(8,6),this.viewCone=35*Pe.DEG2RAD,this.viewFoV=14*Pe.DEG2RAD,this.displayDistance=1,this.displayAspect=.75,this.near=.01,this.far=10}getCameraViewInfo(t,e={}){const{quiltDimensions:n,viewCone:i,displayDistance:r,viewCount:a,viewFoV:s,displayAspect:o,near:l,far:c}=this;e.subframe=e.subframe||new en,e.offsetDirection=e.offsetDirection||new cn,e.projectionMatrix=e.projectionMatrix||new zn;const h=Math.tan(.5*i)*r,u=1===a?0:2*h/(a-1)*t-h;e.offsetDirection.set(1,0,0),e.offset=u;const d=Math.tan(.5*s)*r,p=o*d,m=l/r;e.projectionMatrix.makePerspective(m*(-p-u),m*(p-u),m*d,m*-d,l,c);const f=t%n.x,g=Math.floor(t/n.x),v=1/n.x,_=1/n.y;return e.subframe.set(f*v,g*_,v,_),e}setFromDisplayView(t,e,n){this.displayAspect=e/n,this.displayDistance=t,this.viewFoV=2*Math.atan(.5*n/t)}}function Xg(t,e,n){const i=t.index,r=t.attributes.position.count,a=i?i.count:r;let s,o=t.groups;0===o.length&&(o=[{count:a,start:0,materialIndex:0}]),s=n.length<=255?new Uint8Array(r):new Uint16Array(r);for(let t=0;t<o.length;t++){const r=o[t],l=r.start,c=r.count,h=Math.min(c,a-l),u=Array.isArray(e)?e[r.materialIndex]:e,d=n.indexOf(u);for(let t=0;t<h;t++){let e=l+t;i&&(e=i.getX(e)),s[e]=d}}return new zi(s,1,!1)}function qg(t,e){if(e)for(const n in t.attributes)e.includes(n)||t.deleteAttribute(n)}function Yg(t,e){const{attributes:n=[],normalMapRequired:i=!1}=e;if(!t.attributes.normal&&n&&n.includes("normal")&&t.computeVertexNormals(),!t.attributes.uv&&n&&n.includes("uv")){const e=t.attributes.position.count;t.setAttribute("uv",new zi(new Float32Array(2*e),2,!1))}if(!t.attributes.tangent&&n&&n.includes("tangent"))if(i)null===t.index&&(t=function(t,e=1e-4){e=Math.max(e,Number.EPSILON);const n={},i=t.getIndex(),r=t.getAttribute("position"),a=i?i.count:r.count;let s=0;const o=Object.keys(t.attributes),l={},c={},h=[],u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let e=0,n=o.length;e<n;e++){const n=o[e],i=t.attributes[n];l[n]=new zi(new i.array.constructor(i.count*i.itemSize),i.itemSize,i.normalized);const r=t.morphAttributes[n];r&&(c[n]=new zi(new r.array.constructor(r.count*r.itemSize),r.itemSize,r.normalized))}const p=.5*e,m=Math.log10(1/e),f=Math.pow(10,m),g=p*f;for(let e=0;e<a;e++){const r=i?i.getX(e):e;let a="";for(let e=0,n=o.length;e<n;e++){const n=o[e],i=t.getAttribute(n),s=i.itemSize;for(let t=0;t<s;t++)a+=~~(i[u[t]](r)*f+g)+","}if(a in n)h.push(n[a]);else{for(let e=0,n=o.length;e<n;e++){const n=o[e],i=t.getAttribute(n),a=t.morphAttributes[n],h=i.itemSize,p=l[n],m=c[n];for(let t=0;t<h;t++){const e=u[t],n=d[t];if(p[n](s,i[e](r)),a)for(let t=0,i=a.length;t<i;t++)m[t][n](s,a[t][e](r))}}n[a]=s,h.push(s),s++}}const v=t.clone();for(const e in t.attributes){const t=l[e];if(v.setAttribute(e,new zi(t.array.slice(0,s*t.itemSize),t.itemSize,t.normalized)),e in c)for(let t=0;t<c[e].length;t++){const n=c[e][t];v.morphAttributes[e][t]=new zi(n.array.slice(0,s*n.itemSize),n.itemSize,n.normalized)}}return v.setIndex(h),v}(t)),t.computeTangents();else{const e=t.attributes.position.count;t.setAttribute("tangent",new zi(new Float32Array(4*e),4,!1))}if(!t.attributes.color&&n&&n.includes("color")){const e=t.attributes.position.count,n=new Float32Array(4*e);n.fill(1),t.setAttribute("color",new zi(n,4))}if(!t.index){const e=t.attributes.position.count,n=new Array(e);for(let t=0;t<e;t++)n[t]=t;t.setIndex(n)}}function Zg(t,e={}){e={attributes:null,cloneGeometry:!0,...e};const n=[],i=new Set;for(let e=0,n=t.length;e<n;e++){const n=t[e];!1!==n.visible&&(Array.isArray(n.material)?n.material.forEach((t=>i.add(t))):i.add(n.material))}const r=Array.from(i);for(let i=0,a=t.length;i<a;i++){const a=t[i];if(!1===a.visible)continue;a.updateMatrixWorld();const s=t[i].geometry,o=e.cloneGeometry?s.clone():s;o.applyMatrix4(a.matrixWorld),Yg(o,{attributes:e.attributes,normalMapRequired:!!a.material.normalMap}),qg(o,e.attributes);const l=Xg(o,a.material,r);o.setAttribute("materialIndex",l),n.push(o)}const a=new Set;r.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&a.add(n)}}));return{geometry:Pg(n,!1),materials:r,textures:Array.from(a)}}function Jg(t){return t.buffer instanceof ArrayBuffer&&"BYTES_PER_ELEMENT"in t}class Kg extends Mr{set bokehSize(t){this.fStop=this.getFocalLength()/t}get bokehSize(){return this.getFocalLength()/this.fStop}constructor(...t){super(...t),this.fStop=1.4,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=25,this.anamorphicRatio=1}copy(t,e){return super.copy(t,e),this.fStop=t.fStop,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio,this}}const Qg=new Ie,$g=new Ie,tv=new cd,ev=new Ai;class nv extends il{constructor(t,e){super(new Float32Array(t*e*4),t,e,ot,nt,B,H,G,q,q),this.generationCallback=null}update(){this.dispose(),this.needsUpdate=!0;const{data:t,width:e,height:n}=this.image;for(let i=0;i<e;i++)for(let r=0;r<n;r++){$g.set(e,n),Qg.set(i/e,r/n),Qg.x-=.5,Qg.y=1-Qg.y,tv.theta=2*Qg.x*Math.PI,tv.phi=Qg.y*Math.PI,tv.radius=1,this.generationCallback(tv,Qg,$g,ev);const a=4*(r*e+i);t[a+0]=ev.r,t[a+1]=ev.g,t[a+2]=ev.b,t[a+3]=1}}copy(t){return super.copy(t),this.generationCallback=t.generationCallback,this}}const iv=new cn;function rv(t){return`${t.source.uuid}:${t.encoding}`}function av(t){const e=new Set,n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=rv(r);e.has(a)||(e.add(a),n.push(r))}return n}const sv=180;class ov{constructor(){this._features={}}isUsed(t){return t in this._features}setUsed(t,e=!0){!1===e?delete this._features[t]:this._features[t]=!0}reset(){this._features={}}}class lv extends il{constructor(){super(new Float32Array(4),1,1),this.format=ot,this.type=nt,this.wrapS=G,this.wrapT=G,this.generateMipmaps=!1,this.threeCompatibilityTransforms=!1,this.features=new ov}setCastShadow(t,e){this.image.data[t*sv+57]=e?0:1}getCastShadow(t){const e=this.image.data;return!Boolean(e[t*sv+57])}setMatte(t,e){this.image.data[t*sv+56]=e?1:0}getMatte(t){const e=this.image.data;return Boolean(e[t*sv+56])}updateFrom(t,e){function n(t,e,n=-1){if(e in t&&t[e]){const n=rv(t[e]);return d[n]}return n}function i(t,e,n){return e in t?t[e]:n}function r(t,e,n,i){let r;if(r=l?function(t){return t.map||t.specularMap||t.displacementMap||t.normalMap||t.bumpMap||t.roughnessMap||t.metalnessMap||t.alphaMap||t.emissiveMap||t.clearcoatMap||t.clearcoatNormalMap||t.clearcoatRoughnessMap||t.iridescenceMap||t.iridescenceThicknessMap||t.specularIntensityMap||t.specularColorMap||t.transmissionMap||t.thicknessMap||t.sheenColorMap||t.sheenRoughnessMap||null}(t):t[e]&&t[e].isTexture?t[e]:null,r){const t=r.matrix.elements;let e=0;n[i+e++]=t[0],n[i+e++]=t[3],n[i+e++]=t[6],e++,n[i+e++]=t[1],n[i+e++]=t[4],n[i+e++]=t[7],e++}return 8}let a=0;const s=45*t.length,o=Math.ceil(Math.sqrt(s)),{threeCompatibilityTransforms:l,image:c,features:h}=this,u=av(e),d={};for(let t=0,e=u.length;t<e;t++)d[rv(u[t])]=t;c.width!==o&&(this.dispose(),c.data=new Float32Array(o*o*4),c.width=o,c.height=o);const p=c.data;h.reset();for(let e=0,s=t.length;e<s;e++){const s=t[e];if(s.isFogVolumeMaterial){h.setUsed("FOG");for(let t=0;t<sv;t++)p[a+t]=0;p[a+0+0]=s.color.r,p[a+0+1]=s.color.g,p[a+0+2]=s.color.b,p[a+8+3]=i(s,"emissiveIntensity",0),p[a+12+0]=s.emissive.r,p[a+12+1]=s.emissive.g,p[a+12+2]=s.emissive.b,p[a+52+1]=s.density,p[a+52+3]=0,p[a+56+2]=4,a+=sv;continue}p[a++]=s.color.r,p[a++]=s.color.g,p[a++]=s.color.b,p[a++]=n(s,"map"),p[a++]=i(s,"metalness",0),p[a++]=n(s,"metalnessMap"),p[a++]=i(s,"roughness",0),p[a++]=n(s,"roughnessMap"),p[a++]=i(s,"ior",1.5),p[a++]=i(s,"transmission",0),p[a++]=n(s,"transmissionMap"),p[a++]=i(s,"emissiveIntensity",0),"emissive"in s?(p[a++]=s.emissive.r,p[a++]=s.emissive.g,p[a++]=s.emissive.b):(p[a++]=0,p[a++]=0,p[a++]=0),p[a++]=n(s,"emissiveMap"),p[a++]=n(s,"normalMap"),"normalScale"in s?(p[a++]=s.normalScale.x,p[a++]=s.normalScale.y):(p[a++]=1,p[a++]=1),p[a++]=i(s,"clearcoat",0),p[a++]=n(s,"clearcoatMap"),p[a++]=i(s,"clearcoatRoughness",0),p[a++]=n(s,"clearcoatRoughnessMap"),p[a++]=n(s,"clearcoatNormalMap"),"clearcoatNormalScale"in s?(p[a++]=s.clearcoatNormalScale.x,p[a++]=s.clearcoatNormalScale.y):(p[a++]=1,p[a++]=1),a++,p[a++]=i(s,"sheen",0),"sheenColor"in s?(p[a++]=s.sheenColor.r,p[a++]=s.sheenColor.g,p[a++]=s.sheenColor.b):(p[a++]=0,p[a++]=0,p[a++]=0),p[a++]=n(s,"sheenColorMap"),p[a++]=i(s,"sheenRoughness",0),p[a++]=n(s,"sheenRoughnessMap"),p[a++]=n(s,"iridescenceMap"),p[a++]=n(s,"iridescenceThicknessMap"),p[a++]=i(s,"iridescence",0),p[a++]=i(s,"iridescenceIOR",1.3);const o=i(s,"iridescenceThicknessRange",[100,400]);p[a++]=o[0],p[a++]=o[1],"specularColor"in s?(p[a++]=s.specularColor.r,p[a++]=s.specularColor.g,p[a++]=s.specularColor.b):(p[a++]=1,p[a++]=1,p[a++]=1),p[a++]=n(s,"specularColorMap"),p[a++]=i(s,"specularIntensity",1),p[a++]=n(s,"specularIntensityMap");const l=0===i(s,"thickness",0)&&i(s,"attenuationDistance",1/0)===1/0;if(p[a++]=Number(l),a++,"attenuationColor"in s?(p[a++]=s.attenuationColor.r,p[a++]=s.attenuationColor.g,p[a++]=s.attenuationColor.b):(p[a++]=1,p[a++]=1,p[a++]=1),p[a++]=i(s,"attenuationDistance",1/0),p[a++]=n(s,"alphaMap"),p[a++]=s.opacity,p[a++]=s.alphaTest,!l&&s.transmission>0)p[a++]=0;else switch(s.side){case v:p[a++]=1;break;case _:p[a++]=-1;break;case y:p[a++]=0}a++,a++,p[a++]=Number(s.vertexColors)|Number(s.flatShading)<<1,p[a++]=Number(s.transparent),a+=r(s,"map",p,a),a+=r(s,"metalnessMap",p,a),a+=r(s,"roughnessMap",p,a),a+=r(s,"transmissionMap",p,a),a+=r(s,"emissiveMap",p,a),a+=r(s,"normalMap",p,a),a+=r(s,"clearcoatMap",p,a),a+=r(s,"clearcoatNormalMap",p,a),a+=r(s,"clearcoatRoughnessMap",p,a),a+=r(s,"sheenColorMap",p,a),a+=r(s,"sheenRoughnessMap",p,a),a+=r(s,"iridescenceMap",p,a),a+=r(s,"iridescenceThicknessMap",p,a),a+=r(s,"specularColorMap",p,a),a+=r(s,"specularIntensityMap",p,a)}this.needsUpdate=!0}}const cv=new Ai;class hv extends sn{constructor(...t){super(...t);const e=this.texture;e.format=ot,e.type=J,e.minFilter=q,e.magFilter=q,e.wrapS=H,e.wrapT=H,e.setTextures=(...t)=>{this.setTextures(...t)};const n=new Um(new Ii);this.fsQuad=n}setTextures(t,e,n,i){const r=av(i),a=t.getRenderTarget(),s=t.toneMapping,o=t.getClearAlpha();t.getClearColor(cv);const l=r.length||1;this.setSize(e,n,l),t.setClearColor(0,0),t.toneMapping=E;const c=this.fsQuad;for(let e=0,n=l;e<n;e++){const n=r[e];n&&(n.matrixAutoUpdate=!1,n.matrix.identity(),c.material.map=n,c.material.transparent=!0,t.setRenderTarget(this,e),c.render(t),n.updateMatrix(),n.matrixAutoUpdate=!0)}c.material.map=null,t.setClearColor(cv,o),t.setRenderTarget(a),t.toneMapping=s}dispose(){super.dispose(),this.fsQuad.dispose()}}function uv(t,e,n=0,i=t.length){let r=n,a=n+i-1;for(;r<a;){const n=r+a>>1;t[n]<e?r=n+1:a=n}return r-n}function dv(t,e,n){return.2126*t+.7152*e+.0722*n}class pv{constructor(){const t=new il(new Float32Array([1,1,1,1]),1,1);t.type=nt,t.format=ot,t.minFilter=q,t.magFilter=q,t.wrapS=H,t.wrapT=H,t.generateMipmaps=!1,t.needsUpdate=!0;const e=new il(new Float32Array([0,1]),1,2);e.type=nt,e.format=ht,e.minFilter=q,e.magFilter=q,e.generateMipmaps=!1,e.needsUpdate=!0;const n=new il(new Float32Array([0,0,1,1]),2,2);n.type=nt,n.format=ht,n.minFilter=q,n.magFilter=q,n.generateMipmaps=!1,n.needsUpdate=!0,this.map=t,this.marginalWeights=e,this.conditionalWeights=n,this.totalSum=1}dispose(){this.marginalWeights.dispose(),this.conditionalWeights.dispose(),this.map.dispose()}updateFrom(t){const e=function(t){const e=t.clone();e.source=new Ke({...e.image});const{width:n,height:i,data:r}=e.image;let a=r;if(e.type===it){a=new Float32Array(r.length);for(const t in r)a[t]=Ui.fromHalfFloat(r[t]);e.image.data=a,e.type=nt}if(e.flipY){const t=a;a=a.slice();for(let e=0;e<i;e++)for(let r=0;r<n;r++){const s=4*(e*n+r),o=4*((i-e-1)*n+r);a[o+0]=t[s+0],a[o+1]=t[s+1],a[o+2]=t[s+2],a[o+3]=t[s+3]}e.flipY=!1,e.image.data=a}return e}(t);e.wrapS=H,e.wrapT=H;const{width:n,height:i,data:r}=e.image,a=new Float32Array(n*i),s=new Float32Array(n*i),o=new Float32Array(i),l=new Float32Array(i);let c=0,h=0;for(let t=0;t<i;t++){let e=0;for(let i=0;i<n;i++){const o=t*n+i,l=dv(r[4*o+0],r[4*o+1],r[4*o+2]);e+=l,c+=l,a[o]=l,s[o]=e}if(0!==e)for(let i=t*n,r=t*n+n;i<r;i++)a[i]/=e,s[i]/=e;h+=e,o[t]=e,l[t]=h}if(0!==h)for(let t=0,e=o.length;t<e;t++)o[t]/=h,l[t]/=h;const u=new Float32Array(i),d=new Float32Array(n*i);for(let t=0;t<i;t++){const e=uv(l,(t+1)/i);u[t]=(e+.5)/i}for(let t=0;t<i;t++)for(let e=0;e<n;e++){const i=t*n+e,r=uv(s,(e+1)/n,t*n,n);d[i]=(r+.5)/n}this.dispose();const{marginalWeights:p,conditionalWeights:m}=this;p.image={width:i,height:1,data:u},p.needsUpdate=!0,m.image={width:n,height:i,data:d},m.needsUpdate=!0,this.totalSum=c,this.map=e}}class mv{constructor(){this.bokehSize=0,this.apertureBlades=0,this.apertureRotation=0,this.focusDistance=10,this.anamorphicRatio=1}updateFrom(t){t instanceof Kg?(this.bokehSize=t.bokehSize,this.apertureBlades=t.apertureBlades,this.apertureRotation=t.apertureRotation,this.focusDistance=t.focusDistance,this.anamorphicRatio=t.anamorphicRatio):(this.bokehSize=0,this.apertureRotation=0,this.apertureBlades=0,this.focusDistance=10,this.anamorphicRatio=1)}}class fv{constructor(){const t=new il(new Float32Array(4),1,1);t.format=ot,t.type=nt,t.wrapS=G,t.wrapT=G,t.generateMipmaps=!1,this.tex=t,this.count=0}updateFrom(t,e=[]){const n=this.tex,i=Math.max(6*t.length,1),r=Math.ceil(Math.sqrt(i));n.image.width!==r&&(n.dispose(),n.image.data=new Float32Array(r*r*4),n.image.width=r,n.image.height=r);const a=n.image.data,s=new cn,o=new cn,l=new zn,c=new ln,h=new cn,u=new cn,d=new cn;for(let n=0,i=t.length;n<i;n++){const i=t[n],r=6*n*4;let p=0;i.getWorldPosition(o),a[r+p++]=o.x,a[r+p++]=o.y,a[r+p++]=o.z;let m=0;if(i.isRectAreaLight&&i.isCircular?m=1:i.isSpotLight?m=2:i.isDirectionalLight?m=3:i.isPointLight&&(m=4),a[r+p++]=m,a[r+p++]=i.color.r,a[r+p++]=i.color.g,a[r+p++]=i.color.b,a[r+p++]=i.intensity,i.getWorldQuaternion(c),i.isRectAreaLight)s.set(i.width,0,0).applyQuaternion(c),a[r+p++]=s.x,a[r+p++]=s.y,a[r+p++]=s.z,p++,o.set(0,i.height,0).applyQuaternion(c),a[r+p++]=o.x,a[r+p++]=o.y,a[r+p++]=o.z,a[r+p++]=s.cross(o).length()*(i.isCircular?Math.PI/4:1);else if(i.isSpotLight){const t=i.radius;h.setFromMatrixPosition(i.matrixWorld),u.setFromMatrixPosition(i.target.matrixWorld),l.lookAt(h,u,d),c.setFromRotationMatrix(l),s.set(1,0,0).applyQuaternion(c),a[r+p++]=s.x,a[r+p++]=s.y,a[r+p++]=s.z,p++,o.set(0,1,0).applyQuaternion(c),a[r+p++]=o.x,a[r+p++]=o.y,a[r+p++]=o.z,a[r+p++]=Math.PI*t*t,a[r+p++]=t,a[r+p++]=i.shadow.camera.near,a[r+p++]=i.decay,a[r+p++]=i.distance,a[r+p++]=Math.cos(i.angle),a[r+p++]=Math.cos(i.angle*(1-i.penumbra)),a[r+p++]=e.indexOf(i.iesTexture)}else if(i.isPointLight){const t=s.setFromMatrixPosition(i.matrixWorld);a[r+p++]=t.x,a[r+p++]=t.y,a[r+p++]=t.z,p++,p+=4,p+=2,a[r+p++]=i.decay,a[r+p++]=i.distance}else if(i.isDirectionalLight){const t=s.setFromMatrixPosition(i.matrixWorld),e=o.setFromMatrixPosition(i.target.matrixWorld);u.subVectors(t,e).normalize(),a[r+p++]=u.x,a[r+p++]=u.y,a[r+p++]=u.z}}n.needsUpdate=!0,this.count=t.length}}function gv(t){const e=this,n=t.split("\n");let i,r=0;function a(t){return(t=(t=(t=t.trim()).replace(/,/g," ")).replace(/\s\s+/g," ")).split(" ")}function s(t,e){for(;;){const i=a(n[r++]);for(let t=0;t<i.length;++t)e.push(Number(i[t]));if(e.length===t)break}}for(e.verAngles=[],e.horAngles=[],e.candelaValues=[],e.tiltData={},e.tiltData.angles=[],e.tiltData.mulFactors=[];i=n[r++],!i.includes("TILT"););i.includes("NONE")||i.includes("INCLUDE")&&function(){let t=n[r++],i=a(t);e.tiltData.lampToLumGeometry=Number(i[0]),t=n[r++],i=a(t),e.tiltData.numAngles=Number(i[0]),s(e.tiltData.numAngles,e.tiltData.angles),s(e.tiltData.numAngles,e.tiltData.mulFactors)}(),function(){const t=[];s(10,t),e.count=Number(t[0]),e.lumens=Number(t[1]),e.multiplier=Number(t[2]),e.numVerAngles=Number(t[3]),e.numHorAngles=Number(t[4]),e.gonioType=Number(t[5]),e.units=Number(t[6]),e.width=Number(t[7]),e.length=Number(t[8]),e.height=Number(t[9])}(),function(){const t=[];s(3,t),e.ballFactor=Number(t[0]),e.blpFactor=Number(t[1]),e.inputWatts=Number(t[2])}();for(let t=0;t<e.numHorAngles;++t)e.candelaValues.push([]);s(e.numVerAngles,e.verAngles),s(e.numHorAngles,e.horAngles);for(let t=0;t<e.numHorAngles;++t)s(e.numVerAngles,e.candelaValues[t]);for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n)e.candelaValues[t][n]*=e.candelaValues[t][n]*e.multiplier*e.ballFactor*e.blpFactor;let o=-1;for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n){const i=e.candelaValues[t][n];o=o<i?i:o}if(o>0)for(let t=0;t<e.numHorAngles;++t)for(let n=0;n<e.numVerAngles;++n)e.candelaValues[t][n]/=o}class vv extends tu{_getIESValues(t){const e=new Float32Array(64800);function n(e,n){let i=0,r=0,a=0,s=0,o=0,l=0;for(let e=0;e<t.numHorAngles-1;++e)if(n<t.horAngles[e+1]||e==t.numHorAngles-2){r=e,a=t.horAngles[e],s=t.horAngles[e+1];break}for(let n=0;n<t.numVerAngles-1;++n)if(e<t.verAngles[n+1]||n==t.numVerAngles-2){i=n,o=t.verAngles[n],l=t.verAngles[n+1];break}const c=s-a,h=l-o;if(0===h)return 0;const u=0===c?0:(n-a)/c,d=(e-o)/h,p=0===c?r:r+1,m=Pe.lerp(t.candelaValues[r][i],t.candelaValues[p][i],u),f=Pe.lerp(t.candelaValues[r][i+1],t.candelaValues[p][i+1],u);return Pe.lerp(m,f,d)}const i=t.horAngles[0],r=t.horAngles[t.numHorAngles-1];for(let t=0;t<64800;++t){let a=t%360;const s=Math.floor(t/360);r-i!=0&&(a<i||a>=r)&&(a%=2*r,a>r&&(a=2*r-a)),e[t]=n(s,a)}return e}load(t,e,n,i){const r=new iu(this.manager);r.setResponseType("text"),r.setCrossOrigin(this.crossOrigin),r.setWithCredentials(this.withCredentials),r.setPath(this.path),r.setRequestHeader(this.requestHeader);const a=new il(null,360,180,ht,nt);return a.minFilter=q,a.magFilter=q,r.load(t,(t=>{const n=new gv(t);a.image.data=this._getIESValues(n),a.needsUpdate=!0,void 0!==e&&e(a)}),n,i),a}parse(t){const e=new gv(t),n=new il(null,360,180,ht,nt);return n.minFilter=q,n.magFilter=q,n.image.data=this._getIESValues(e),n.needsUpdate=!0,n}}const _v=new Ai;class yv extends sn{constructor(...t){super(...t);const e=this.texture;e.format=ot,e.type=nt,e.minFilter=q,e.magFilter=q,e.wrapS=G,e.wrapT=G,e.generateMipmaps=!1,e.updateFrom=(...t)=>{this.updateFrom(...t)};const n=new Um(new Ii);this.fsQuad=n,this.iesLoader=new vv}async updateFrom(t,e){const n=t.getRenderTarget(),i=t.toneMapping,r=t.getClearAlpha();t.getClearColor(_v);const a=e.length||1;this.setSize(360,180,a),t.setClearColor(0,0),t.toneMapping=E;const s=this.fsQuad;for(let n=0,i=a;n<i;n++){const i=e[n];i&&(i.matrixAutoUpdate=!1,i.matrix.identity(),s.material.map=i,s.material.transparent=!0,t.setRenderTarget(this,n),s.render(t),i.updateMatrix(),i.matrixAutoUpdate=!0)}s.material.map=null,t.setClearColor(_v,r),t.setRenderTarget(n),t.toneMapping=i,s.dispose()}dispose(){super.dispose(),this.fsQuad.dispose()}}const xv="\n\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\n\n\t#ifndef RAY_OFFSET\n\t#define RAY_OFFSET 1e-4\n\t#endif\n\n\t// adjust the hit point by the surface normal by a factor of some offset and the\n\t// maximum component-wise value of the current point to accommodate floating point\n\t// error as values increase.\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\n\n\t\tvec3 point = rayOrigin + rayDirection * dist;\n\t\tvec3 absPoint = abs( point );\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\n\n\t}\n\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\n\n\t\tvec3 ot = - log( attColor ) / attDist;\n\t\treturn exp( - ot * dist );\n\n\t}\n\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\n\n\t\t// get the half vector - assuming if the light incident vector is on the other side\n\t\t// of the that it's transmissive.\n\t\tvec3 h;\n\t\tif ( wi.z > 0.0 ) {\n\n\t\t\th = normalize( wi + wo );\n\n\t\t} else {\n\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\n\t\t\t// From Section 2.2 on computing the transmission half vector:\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\n\t\t\th = normalize( wi + wo * eta );\n\n\t\t}\n\n\t\th *= sign( h.z );\n\t\treturn h;\n\n\t}\n\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\n\n\t\treturn normalize( a + b );\n\n\t}\n\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\n\t// we find a ray like that we ignore it to avoid artifacts.\n\t// This function returns if the direction is on the same side of both planes.\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\n\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\n\n\t}\n\n\t// ray sampling x and z are swapped to align with expected background view\n\tvec2 equirectDirectionToUv( vec3 direction ) {\n\n\t\t// from Spherical.setFromCartesianCoords\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\n\t\tuv /= vec2( 2.0 * PI, PI );\n\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\n\t\tuv.x += 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\t\treturn uv;\n\n\t}\n\n\tvec3 equirectUvToDirection( vec2 uv ) {\n\n\t\t// undo above adjustments\n\t\tuv.x -= 0.5;\n\t\tuv.y = 1.0 - uv.y;\n\n\t\t// from Vector3.setFromSphericalCoords\n\t\tfloat theta = uv.x * 2.0 * PI;\n\t\tfloat phi = uv.y * PI;\n\n\t\tfloat sinPhi = sin( phi );\n\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\n\n\t}\n\n\t// power heuristic for multiple importance sampling\n\tfloat misHeuristic( float a, float b ) {\n\n\t\tfloat aa = a * a;\n\t\tfloat bb = b * b;\n\t\treturn aa / ( aa + bb );\n\n\t}\n\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\n\t// erichlof/THREE.js-PathTracing-Renderer/\n\tfloat tentFilter( float x ) {\n\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\n\n\t}\n";class bv extends Ig{constructor(){super({uniforms:{envMap:{value:null},blur:{value:0}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t\t${xv}\n\n\t\t\t\tuniform sampler2D envMap;\n\t\t\t\tuniform float blur;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\n\n\t\t\t\t}\n\n\t\t\t`})}}function wv(t,e,n,i,r){if(e>i)throw new Error;const a=t.length/e,s=8*t.constructor.BYTES_PER_ELEMENT;let o=1;switch(t.constructor){case Uint8Array:case Uint16Array:case Uint32Array:o=2**s-1;break;case Int8Array:case Int16Array:case Int32Array:o=2**(s-1)-1}for(let s=0;s<a;s++){const a=4*s,l=e*s;for(let s=0;s<i;s++)n[r+a+s]=e>=s+1?t[l+s]/o:0}}class Mv extends an{constructor(){super(),this._textures=[],this.type=nt,this.format=ot,this.internalFormat="RGBA32F"}updateAttribute(t,e){const n=this._textures[t];n.updateFrom(e);const i=n.image,r=this.image;if(i.width!==r.width||i.height!==r.height)throw new Error("FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.");const{width:a,height:s,data:o}=r,l=a*s*4*t;let c=e.itemSize;3===c&&(c=4),wv(n.image.data,c,o,4,l),this.dispose(),this.needsUpdate=!0}setAttributes(t){const e=t[0].count,n=t.length;for(let i=0,r=n;i<r;i++)if(t[i].count!==e)throw new Error("FloatAttributeTextureArray: All attributes must have the same item count.");const i=this._textures;for(;i.length<n;){const t=new cg;i.push(t)}for(;i.length>n;)i.pop();for(let e=0,r=n;e<r;e++)i[e].updateFrom(t[e]);const r=i[0].image,a=this.image;r.width===a.width&&r.height===a.height&&r.depth===n||(a.width=r.width,a.height=r.height,a.depth=n,a.data=new Float32Array(a.width*a.height*a.depth*4));const{data:s,width:o,height:l}=a;for(let e=0,r=n;e<r;e++){const n=i[e],r=o*l*4*e;let a=t[e].itemSize;3===a&&(a=4),wv(n.image.data,a,s,4,r)}this.dispose(),this.needsUpdate=!0}}class Sv extends Mv{updateNormalAttribute(t){this.updateAttribute(0,t)}updateTangentAttribute(t){this.updateAttribute(1,t)}updateUvAttribute(t){this.updateAttribute(2,t)}updateColorAttribute(t){this.updateAttribute(3,t)}updateFrom(t,e,n,i){this.setAttributes([t,e,n,i])}}const Tv="\n    precision highp float;\n    precision highp int;\n    struct FloatStruct {\n        highp float value;\n    };\n\n    struct IntStruct {\n        highp int value;\n    };\n\n    struct UintStruct {\n        highp uint value;\n    };\n\n    vec2 computePrecision() {\n\n        #if MODE == 0 // float\n\n            float exponent = 0.0;\n            float value = 1.5;\n            while ( value > 1.0 ) {\n\n                exponent ++;\n                value = 1.0 + pow( 2.0, - exponent ) / 2.0;\n\n            }\n\n            float structExponent = 0.0;\n            FloatStruct str;\n            str.value = 1.5;\n            while ( str.value > 1.0 ) {\n\n                structExponent ++;\n                str.value = 1.0 + pow( 2.0, - structExponent ) / 2.0;\n\n            }\n\n            return vec2( exponent, structExponent );\n\n\n        #elif MODE == 1 // int\n\n            int bits = 0;\n            int value = 1;\n            while ( value > 0 ) {\n\n                value = value << 1;\n                value = value | 1;\n                bits ++;\n\n            }\n\n            int structBits = 0;\n            IntStruct str;\n            str.value = 1;\n            while ( str.value > 0 ) {\n\n                str.value = str.value << 1;\n                str.value = str.value | 1;\n                structBits ++;\n\n            }\n\n            return vec2( bits, structBits );\n\n        #else // uint\n\n            int bits = 0;\n            uint value = 1u;\n            while ( value > 0u ) {\n\n                value = value << 1u;\n                bits ++;\n\n            }\n\n            int structBits = 0;\n            UintStruct str;\n            str.value = 1u;\n            while( str.value > 0u ) {\n\n                str.value = str.value << 1u;\n                structBits ++;\n\n            }\n\n            return vec2( bits, structBits );\n\n        #endif\n\n    }\n\n\n";class Ev extends Ig{set mode(t){switch(this._mode=t,t.toLowerCase()){case"float":this.setDefine("MODE",0);break;case"int":this.setDefine("MODE",1);break;case"uint":this.setDefine("MODE",2)}}constructor(){super({vertexShader:`\n\n\t\t\t\t${Tv}\n\n\t\t\t\tvarying vec2 vPrecision;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvPrecision = computePrecision();\n\n\t\t\t\t}\n\n\t\t\t`,fragmentShader:`\n\n\t\t\t\t${Tv}\n\n\t\t\t\tvarying vec2 vPrecision;\n\t\t\t\tvoid main( void ) {\n\n\t\t\t\t\tvec2 fPrecision = computePrecision();\n\t\t\t\t\tgl_FragColor = vec4( vPrecision, fPrecision ) / 255.0;\n\n\t\t\t\t}\n\n\t\t\t`})}}class Av{constructor(t){this._renderer=t,this._result=null}detect(){if(this._result)return this._result;const t=this._renderer,e=new Ev,n=new Um(e),i=new rn(1,1),r=t.getRenderTarget(),a={int:l("int"),uint:l("uint"),float:l("float")},s=o("int",a.int)||o("uint",a.uint)||o("float",a.float);return this._result={detail:a,message:s,pass:!Boolean(s)},t.setRenderTarget(r),n.dispose(),i.dispose(),e.dispose(),this._result;function o(t,e){return e.vertex===e.vertexStruct&&e.fragment===e.fragmentStruct?"":`Type "${t}" cannot correctly provide highp precision in structs.`}function l(r){e.mode=r,t.setRenderTarget(i),n.render(t);const a=new Uint8Array(4);return t.readRenderTargetPixels(i,0,0,1,1,a),{vertex:a[0],vertexStruct:a[1],fragment:a[2],fragmentStruct:a[3]}}}}class Rv{constructor(t){this._renderer=t}detect(t){const e=this._renderer,n=new mr(new gr,t),i=new Mr,r=e.debug.checkShaderErrors;e.debug.checkShaderErrors=!0;const a=e.info.programs,s=a.length;if(e.compile(n,i),e.debug.checkShaderErrors=r,n.geometry.dispose(),a.length===s)return{detail:null,pass:!0,message:"Cannot determine shader compilation status if material has already been used."};{const e=a[a.length-1],n=!e.diagnostics||e.diagnostics.runnable;return{detail:{},pass:n,message:n?"":`Cannot render ${t.type} on this device.`}}}}var Cv=Object.freeze({__proto__:null,BlurredEnvMapGenerator:class{constructor(t){this.renderer=t,this.pmremGenerator=new aa(t),this.copyQuad=new Um(new bv),this.renderTarget=new rn(1,1,{type:nt,format:ot})}dispose(){this.pmremGenerator.dispose(),this.copyQuad.dispose(),this.renderTarget.dispose()}generate(t,e){const{pmremGenerator:n,renderTarget:i,copyQuad:r,renderer:a}=this,s=n.fromEquirectangular(t),{width:o,height:l}=t.image;i.setSize(o,l),r.material.envMap=s.texture,r.material.blur=e;const c=a.getRenderTarget(),h=a.autoClear;a.setRenderTarget(i),a.autoClear=!0,r.render(a),a.setRenderTarget(c),a.autoClear=h;const u=new Float32Array(o*l*4);a.readRenderTargetPixels(i,0,0,o,l,u);const d=new il(u,o,l,ot,nt);return d.minFilter=t.minFilter,d.magFilter=t.magFilter,d.wrapS=t.wrapS,d.wrapT=t.wrapT,d.mapping=B,d.needsUpdate=!0,s.dispose(),d}},CompatibilityDetector:class{constructor(t,e){this._renderer=t,this._material=e}detect(){let t=new Av(this._renderer),e=t.detect();return e.pass?(t=new Rv(this._renderer),e=t.detect(this._material),e.pass?{detail:{},pass:!0,message:""}:e):e}},DenoiseMaterial:class extends Ig{constructor(t){super({blending:0,transparent:!1,depthWrite:!1,depthTest:!1,defines:{USE_SLIDER:0},uniforms:{sigma:{value:5},threshold:{value:.03},kSigma:{value:1},map:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\n\t\t\t\t//  All rights reserved.\n\t\t\t\t//\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\n\t\t\t\t//\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\n\t\t\t\t//\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\n\t\t\t\t//\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tuniform float sigma;\n\t\t\t\tuniform float threshold;\n\t\t\t\tuniform float kSigma;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\n\n\t\t\t\t// Parameters:\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\n\t\t\t\t//\t\t kSigma * sigma  --\x3e  radius of the circular kernel\n\t\t\t\t//\t float threshold   - edge sharpening threshold\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\n\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\n\t\t\t\t\tfloat radQ = radius * radius;\n\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\n\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\n\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\n\n\t\t\t\t\tfloat zBuff = 0.0;\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\n\n\t\t\t\t\tvec2 d;\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\n\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\n\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\n\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\n\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\n\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\n\n\t\t\t\t\t\t\tzBuff += deltaFactor;\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn aBuff / zBuff;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t\t\t}\n\n\t\t\t"}),this.setValues(t)}},DynamicPathTracingSceneGenerator:class{get initialized(){return Boolean(this.bvh)}constructor(t){this.objects=Array.isArray(t)?t:[t],this.bvh=null,this.geometry=new Ji,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new Rg(this.objects)}reset(){this.bvh=null,this.geometry.dispose(),this.geometry=new Ji,this.materials=null,this.textures=null,this.lights=[],this.staticGeometryGenerator=new Rg(this.objects)}dispose(){}generate(){const{objects:t,staticGeometryGenerator:e,geometry:n}=this;if(null===this.bvh){const i=["position","normal","tangent","uv","color"];for(let e=0,n=t.length;e<n;e++)t[e].traverse((t=>{if(t.isMesh){const e=!!t.material.normalMap;Yg(t.geometry,{attributes:i,normalMapRequired:e})}else(t.isRectAreaLight||t.isSpotLight)&&this.lights.push(t)}));const r=new Set,a=e.getMaterials();a.forEach((t=>{for(const e in t){const n=t[e];n&&n.isTexture&&r.add(n)}})),e.attributes=i,e.generate(n);const s=Xg(n,a,a);return n.setAttribute("materialIndex",s),n.clearGroups(),this.bvh=new ag(n),this.materials=a,this.textures=Array.from(r),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}{const{bvh:i}=this;return e.generate(n),i.refit(),{lights:this.lights,bvh:this.bvh,materials:this.materials,textures:this.textures,objects:t}}}},EquirectCamera:class extends wr{constructor(){super(),this.isEquirectCamera=!0}},EquirectHdrInfoUniform:pv,FogVolumeMaterial:class extends Mh{constructor(t){super(t),this.isFogVolumeMaterial=!0,this.density=.015,this.emissive=new Ai,this.emissiveIntensity=0,this.opacity=.15,this.transparent=!0,this.roughness=1,this.metalness=0,this.setValues(t)}},GradientEquirectTexture:class extends nv{constructor(t=512){super(t,t),this.topColor=(new Ai).set(16777215),this.bottomColor=(new Ai).set(0),this.exponent=2,this.generationCallback=(t,e,n,i)=>{iv.setFromSpherical(t);const r=.5*iv.y+.5;i.lerpColors(this.bottomColor,this.topColor,r**this.exponent)}}copy(t){return super.copy(t),this.topColor.copy(t.topColor),this.bottomColor.copy(t.bottomColor),this}},GradientMapMaterial:class extends Ig{constructor(t){super({defines:{FEATURE_BIN:0},uniforms:{map:{value:null},minColor:{value:new Ai(0)},minValue:{value:0},maxColor:{value:new Ai(16777215)},maxValue:{value:10},field:{value:0},power:{value:1}},blending:0,vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform vec3 minColor;\n\t\t\t\tuniform float minValue;\n\t\t\t\tuniform vec3 maxColor;\n\t\t\t\tuniform float maxValue;\n\t\t\t\tuniform int field;\n\t\t\t\tuniform float power;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat value = texture( map, vUv )[ field ];\n\n\t\t\t\t\t#if FEATURE_BIN\n\n\t\t\t\t\tvalue = ceil( value );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat t = smoothstep( minValue, maxValue, value );\n\t\t\t\t\tt = pow( t, power );\n\n\t\t\t\t\tgl_FragColor.rgb = vec3( mix( minColor, maxColor, t ) );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}"}),this.setValues(t)}},GraphMaterial:class extends Ig{get graphFunctionSnippet(){return this._graphFunctionSnippet}set graphFunctionSnippet(t){this._graphFunctionSnippet=t}constructor(t){super({blending:0,transparent:!1,depthWrite:!1,depthTest:!1,defines:{USE_SLIDER:0},uniforms:{dim:{value:!0},thickness:{value:1},graphCount:{value:4},graphDisplay:{value:new en(1,1,1,1)},overlay:{value:!0},xRange:{value:new Ie(-2,2)},yRange:{value:new Ie(-2,2)},colors:{value:[new Ai(15277667).convertSRGBToLinear(),new Ai(5025616).convertSRGBToLinear(),new Ai(240116).convertSRGBToLinear(),new Ai(16761095).convertSRGBToLinear()]}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform bool overlay;\n\t\t\t\tuniform bool dim;\n\t\t\t\tuniform bvec4 graphDisplay;\n\t\t\t\tuniform float graphCount;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 xRange;\n\t\t\t\tuniform vec2 yRange;\n\t\t\t\tuniform vec3 colors[ 4 ];\n\n\t\t\t\t__FUNCTION_CONTENT__\n\n\t\t\t\tfloat map( float _min, float _max, float v ) {\n\n\t\t\t\t\tfloat len = _max - _min;\n\t\t\t\t\treturn _min + len * v;\n\n\t\t\t\t}\n\n\t\t\t\tvec3 getBackground( vec2 point, float steepness ) {\n\n\t\t\t\t\tvec2 pw = fwidth( point );\n\t\t\t\t\tvec2 halfWidth = pw * 0.5;\n\n\t\t\t\t\t// x, y axes\n\t\t\t\t\tvec2 distToZero = smoothstep(\n\t\t\t\t\t\t- halfWidth * 0.5,\n\t\t\t\t\t\thalfWidth * 0.5,\n\t\t\t\t\t\tabs( point.xy ) - pw\n\t\t\t\t\t);\n\n\t\t\t\t\t// 1 unit markers\n\t\t\t\t\tvec2 temp;\n\t\t\t\t\tvec2 modAxis = abs( modf( point + vec2( 0.5 ), temp ) ) - 0.5;\n\t\t\t\t\tvec2 distToAxis = smoothstep(\n\t\t\t\t\t\t- halfWidth,\n\t\t\t\t\t\thalfWidth,\n\t\t\t\t\t\tabs( modAxis.xy ) - pw * 0.5\n\t\t\t\t\t);\n\n\t\t\t\t\t// if we're at a chart boundary then remove the artifacts\n\t\t\t\t\tif ( abs( pw.y ) > steepness * 0.5 ) {\n\n\t\t\t\t\t\tdistToZero.y = 1.0;\n\t\t\t\t\t\tdistToAxis.y = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mix colors into a background color\n\t\t\t\t\tfloat axisIntensity = 1.0 - min( distToZero.x, distToZero.y );\n\t\t\t\t\tfloat markerIntensity = 1.0 - min( distToAxis.x, distToAxis.y );\n\n\t\t\t\t\tvec3 markerColor = mix( vec3( 0.005 ), vec3( 0.05 ), markerIntensity );\n\t\t\t\t\tvec3 backgroundColor = mix( markerColor, vec3( 0.2 ), axisIntensity );\n\t\t\t\t\treturn backgroundColor;\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// from uniforms\n\t\t\t\t\tfloat sectionCount = overlay ? 1.0 : graphCount;\n\t\t\t\t\tfloat yWidth = abs( yRange.y - yRange.x );\n\n\t\t\t\t\t// separate into sections\n\t\t\t\t\tfloat _section;\n\t\t\t\t\tfloat sectionY = modf( sectionCount * vUv.y, _section );\n\t\t\t\t\tint section = int( sectionCount - _section - 1.0 );\n\n\t\t\t\t\t// get the current point\n\t\t\t\t\tvec2 point = vec2(\n\t\t\t\t\t\tmap( xRange.x, xRange.y, vUv.x ),\n\t\t\t\t\t\tmap( yRange.x, yRange.y, sectionY )\n\t\t\t\t\t);\n\n\t\t\t\t\t// get the results\n\t\t\t\t\tvec4 result = graphFunction( point.x );\n\t\t\t\t\tvec4 delta = result - vec4( point.y );\n\t\t\t\t\tvec4 halfDdf = fwidth( delta ) * 0.5;\n\t\t\t\t\tif ( fwidth( point.y ) > yWidth * 0.5 ) {\n\n\t\t\t\t\t\thalfDdf = vec4( 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph display intensity\n\t\t\t\t\tvec4 graph = smoothstep( - halfDdf, halfDdf, abs( delta ) - thickness * halfDdf );\n\n\t\t\t\t\t// initialize the background\n\t\t\t\t\tgl_FragColor.rgb = getBackground( point, yWidth );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\tif ( dim && ( point.x < 0.0 || point.y < 0.0 ) ) {\n\n\t\t\t\t\t\tgraph = mix(\n\t\t\t\t\t\t\tvec4( 1.0 ),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t0.05\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// color the charts\n\t\t\t\t\tif ( sectionCount > 1.0 ) {\n\n\t\t\t\t\t\tif ( graphDisplay[ section ] ) {\n\n\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\tcolors[ section ],\n\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\tgraph[ section ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( int i = 0; i < int( graphCount ); i ++ ) {\n\n\t\t\t\t\t\t\tif ( graphDisplay[ i ] ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\t\t\t\tcolors[ i ],\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb,\n\t\t\t\t\t\t\t\t\tgraph[ i ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\n\t\t\t"}),this._graphFunctionSnippet="\n\t\t\tvec4 graphFunctionSnippet( float x ) {\n\n\t\t\t\treturn vec4(\n\t\t\t\t\tsin( x * 3.1415926535 ),\n\t\t\t\t\tcos( x ),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t);\n\n\t\t\t}\n\t\t",this.setValues(t)}onBeforeCompile(t){return t.fragmentShader=t.fragmentShader.replace("__FUNCTION_CONTENT__",this._graphFunctionSnippet),t}customProgramCacheKey(){return this._graphFunctionSnippet}},IESLoader:vv,IESProfilesTexture:yv,LightsInfoUniformStruct:fv,MaterialBase:Ig,MaterialReducer:class{constructor(){const t=new Set;t.add("uuid"),this.ignoreKeys=t,this.shareTextures=!0,this.textures=[],this.materials=[]}areEqual(t,e){const n=new Set,i=new Set,r=this.ignoreKeys,a=(t,e)=>{if(t===e)return!0;if(t&&e&&t instanceof Object&&e instanceof Object){if(i.has(t)||i.has(e))throw new Error("MaterialReducer: Material is recursive.");const s=t instanceof Element,o=e instanceof Element;if(s||o)return s===o&&t instanceof Image&&e instanceof Image&&t.src===e.src;const l=t instanceof ImageBitmap,c=e instanceof ImageBitmap;if(l||c)return!1;if(t.equals)return t.equals(e);const h=Jg(t),u=Jg(e);if(h||u){if(h!==u||t.constructor!==e.constructor||t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}i.add(t),i.add(e),n.clear();for(const e in t)!t.hasOwnProperty(e)||t[e]instanceof Function||r.has(e)||n.add(e);for(const t in e)!e.hasOwnProperty(t)||e[t]instanceof Function||r.has(t)||n.add(t);const d=Array.from(n.values());let p=!0;for(const n in d){const i=d[n];if(!r.has(i)&&(p=a(t[i],e[i]),!p))break}return i.delete(t),i.delete(e),p}return!1};return a(t,e)}process(t){const{textures:e,materials:n}=this;let i=0;const r=t=>{let r=null;for(const e in n){const i=n[e];this.areEqual(t,i)&&(r=i)}if(r)return i++,r;if(n.push(t),this.shareTextures)for(const n in t){if(!t.hasOwnProperty(n))continue;const i=t[n];if(i&&i.isTexture&&i.image instanceof Image){let r=null;for(const t in e){const n=e[t];if(this.areEqual(n,i)){r=n;break}}r?t[n]=r:e.push(i)}}return t};return t.traverse((t=>{if(t.isMesh&&t.material){const e=t.material;if(Array.isArray(e))for(let t=0;t<e.length;t++)e[t]=r(e[t]);else t.material=r(e)}})),{replaced:i,retained:n.length}}},MaterialsTexture:lv,PathTracingRenderer:Vg,PathTracingSceneGenerator:class{prepScene(t){t=Array.isArray(t)?t:[t];const e=[],n=[];for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible((t=>{if(t.isSkinnedMesh||t.isMesh&&t.morphTargetInfluences){const n=new Rg(t);n.attributes=["position","color","normal","tangent","uv","uv2"],n.applyWorldTransforms=!1;const i=new mr(n.generate(),t.material);i.matrixWorld.copy(t.matrixWorld),i.matrix.copy(t.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale),e.push(i)}else t.isMesh?e.push(t):(t.isRectAreaLight||t.isSpotLight||t.isDirectionalLight||t.isPointLight)&&n.push(t)}));return{...Zg(e,{attributes:["position","normal","tangent","uv","color"]}),lights:n}}generate(t,e={}){const{materials:n,textures:i,geometry:r,lights:a}=this.prepScene(t),s={strategy:km,...e,maxLeafTris:1};return{scene:t,materials:n,textures:i,lights:a,bvh:new ag(r,s)}}},PhysicalCamera:Kg,PhysicalCameraUniform:mv,PhysicalPathTracingMaterial:class extends Ig{onBeforeRender(){this.setDefine("FEATURE_DOF",0===this.physicalCamera.bokehSize?0:1),this.setDefine("FEATURE_BACKGROUND_MAP",this.backgroundMap?1:0),this.setDefine("FEATURE_FOG",this.materials.features.isUsed("FOG")?1:0)}constructor(t){super({transparent:!0,depthWrite:!1,defines:{FEATURE_MIS:1,FEATURE_RUSSIAN_ROULETTE:1,FEATURE_DOF:1,FEATURE_BACKGROUND_MAP:0,FEATURE_FOG:1,CAMERA_TYPE:0,DEBUG_MODE:0,ATTR_NORMAL:0,ATTR_TANGENT:1,ATTR_UV:2,ATTR_COLOR:3},uniforms:{resolution:{value:new Ie},bounces:{value:10},transmissiveBounces:{value:10},physicalCamera:{value:new mv},bvh:{value:new hg},attributesArray:{value:new Sv},materialIndexAttribute:{value:new lg},materials:{value:new lv},textures:{value:(new hv).texture},lights:{value:new fv},iesProfiles:{value:(new yv).texture},cameraWorldMatrix:{value:new zn},invProjectionMatrix:{value:new zn},backgroundBlur:{value:0},environmentIntensity:{value:1},environmentRotation:{value:new zn},envMapInfo:{value:new pv},backgroundMap:{value:null},seed:{value:0},opacity:{value:1},filterGlossyFactor:{value:0},backgroundAlpha:{value:1},sobolTexture:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\t\t\t\t#define RAY_OFFSET 1e-4\n\t\t\t\t#define INFINITY 1e20\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\t\t\t\tprecision highp sampler2DArray;\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\t\t\t\t#include <common>\n\n\t\t\t\t// bvh intersection\n\t\t\t\t\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n\t\t\t\t\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n\n\t\t\t\t// random\n\t\t\t\t\n\n\t// https://www.shadertoy.com/view/wltcRS\n\tuvec4 WHITE_NOISE_SEED;\n\n\tvoid rng_initialize( vec2 p, int frame ) {\n\n\t\t// white noise seed\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\n\n\t}\n\n\t// https://www.pcg-random.org/\n\tvoid pcg4d( inout uvec4 v ) {\n\n\t\tv = v * 1664525u + 1013904223u;\n\t\tv.x += v.y * v.w;\n\t\tv.y += v.z * v.x;\n\t\tv.z += v.x * v.y;\n\t\tv.w += v.y * v.z;\n\t\tv = v ^ ( v >> 16u );\n\t\tv.x += v.y*v.w;\n\t\tv.y += v.z*v.x;\n\t\tv.z += v.x*v.y;\n\t\tv.w += v.y*v.z;\n\n\t}\n\n\t// returns [ 0, 1 ]\n\tfloat rand() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\n\n\t}\n\n\tvec2 rand2() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\n\n\t}\n\n\tvec3 rand3() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\n\n\t}\n\n\tvec4 rand4() {\n\n\t\tpcg4d( WHITE_NOISE_SEED );\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\n\n\t}\n\n\t\t\t\t${Og}\n\t\t\t\t${Ug}\n\n\t\t\t\t// common\n\t\t\t\t\n\n\t// add texel fetch functions for texture arrays\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\n\n\t\tuint width = uint( textureSize( tex, 0 ).x );\n\t\tuvec2 uv;\n\t\tuv.x = index % width;\n\t\tuv.y = index / width;\n\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\n\n\t}\n\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\n\n\t\treturn\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\n\n\t}\n\n\n\t\t\t\t\n\n\tbool totalInternalReflection( float cosTheta, float eta ) {\n\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\n\t\treturn eta * sinTheta > 1.0;\n\n\t}\n\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\n\tfloat schlickFresnel( float cosine, float f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\n\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\n\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\n\n\t}\n\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat ni = eta;\n\t\tfloat nt = 1.0;\n\n\t\t// Check for total internal reflection\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\n\t\tif( sinThetaTSq >= 1.0 ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\n\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\n\n\t}\n\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\n\tfloat iorRatioToF0( float eta ) {\n\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\n\n\t}\n\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn f90;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\n\n\t}\n\n\tfloat evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\n\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\n\n\t\t\treturn 1.0;\n\n\t\t}\n\n\t\treturn schlickFresnel( cosTheta, f0 );\n\n\t}\n\n\t/*\n\t// https://schuttejoe.github.io/post/disneybsdf/\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\n\n\t\tfloat dotHV = dot( wo, wh );\n\t\tfloat dotHL = dot( wi, wh );\n\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\n\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\n\n\t}\n\t*/\n\n\t\t\t\t${xv}\n\t\t\t\t\n\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\n\t// For more information see: https://github.com/gkjohnson/three-gpu-pathtracer/pull/171#issuecomment-1152275248\n\tfloat acosApprox( float x ) {\n\n\t\tx = clamp( x, -1.0, 1.0 );\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\n\n\t}\n\n\t// An acos with input values bound to the range [-1, 1].\n\tfloat acosSafe( float x ) {\n\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\n\n\t}\n\n\tfloat saturateCos( float val ) {\n\n\t\treturn clamp( val, 0.001, 1.0 );\n\n\t}\n\n\tfloat square( float t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 square( vec2 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec3 square( vec3 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec4 square( vec4 t ) {\n\n\t\treturn t * t;\n\n\t}\n\n\tvec2 rotateVector( vec2 v, float t ) {\n\n\t\tfloat ac = cos( t );\n\t\tfloat as = sin( t );\n\t\treturn vec2(\n\t\t\tv.x * ac - v.y * as,\n\t\t\tv.x * as + v.y * ac\n\t\t);\n\n\t}\n\n\t// forms a basis with the normal vector as Z\n\tmat3 getBasisFromNormal( vec3 normal ) {\n\n\t\tvec3 other;\n\t\tif ( abs( normal.x ) > 0.5 ) {\n\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\n\n\t\t} else {\n\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\n\n\t\t}\n\n\t\tvec3 ortho = normalize( cross( normal, other ) );\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\n\t\treturn mat3( ortho2, ortho, normal );\n\n\t}\n\n\n\t\t\t\t\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the rectangle on that same plane.\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = p - center;\n\n\t\t\t// check if p falls inside the rectangle\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\n\n\t\t\t\tfloat a2 = dot( v, vi );\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\n\n\t\t\t\t\tdist = t;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, out float dist ) {\n\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\n\n\t\tif ( t > EPSILON ) {\n\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\n\t\t\tvec3 vi = hit - position;\n\n\t\t\tfloat a1 = dot( u, vi );\n\t\t\tfloat a2 = dot( v, vi );\n\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\n\n\t\t\t\tdist = t;\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\n\n\t\t\t\t// uniform structs\n\t\t\t\t\n\n\tstruct PhysicalCamera {\n\n\t\tfloat focusDistance;\n\t\tfloat anamorphicRatio;\n\t\tfloat bokehSize;\n\t\tint apertureBlades;\n\t\tfloat apertureRotation;\n\n\t};\n\n\n\t\t\t\t\n\n\t#define RECT_AREA_LIGHT_TYPE 0\n\t#define CIRC_AREA_LIGHT_TYPE 1\n\t#define SPOT_LIGHT_TYPE 2\n\t#define DIR_LIGHT_TYPE 3\n\t#define POINT_LIGHT_TYPE 4\n\n\tstruct LightsInfo {\n\n\t\tsampler2D tex;\n\t\tuint count;\n\n\t};\n\n\tstruct Light {\n\n\t\tvec3 position;\n\t\tint type;\n\n\t\tvec3 color;\n\t\tfloat intensity;\n\n\t\tvec3 u;\n\t\tvec3 v;\n\t\tfloat area;\n\n\t\t// spot light fields\n\t\tfloat radius;\n\t\tfloat near;\n\t\tfloat decay;\n\t\tfloat distance;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint iesProfile;\n\n\t};\n\n\tLight readLightInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 6u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\n\t\tLight l;\n\t\tl.position = s0.rgb;\n\t\tl.type = int( round( s0.a ) );\n\n\t\tl.color = s1.rgb;\n\t\tl.intensity = s1.a;\n\n\t\tl.u = s2.rgb;\n\t\tl.v = s3.rgb;\n\t\tl.area = s3.a;\n\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\t\tl.radius = s4.r;\n\t\t\tl.near = s4.g;\n\t\t\tl.decay = s4.b;\n\t\t\tl.distance = s4.a;\n\n\t\t\tl.coneCos = s5.r;\n\t\t\tl.penumbraCos = s5.g;\n\t\t\tl.iesProfile = int( round ( s5.b ) );\n\n\t\t}\n\n\t\treturn l;\n\n\t}\n\n\n\t\t\t\t\n\n\tstruct EquirectHdrInfo {\n\n\t\tsampler2D marginalWeights;\n\t\tsampler2D conditionalWeights;\n\t\tsampler2D map;\n\n\t\tfloat totalSum;\n\n\t};\n\n\n\t\t\t\t\n\n\tstruct Material {\n\n\t\tvec3 color;\n\t\tint map;\n\n\t\tfloat metalness;\n\t\tint metalnessMap;\n\n\t\tfloat roughness;\n\t\tint roughnessMap;\n\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tint transmissionMap;\n\n\t\tfloat emissiveIntensity;\n\t\tvec3 emissive;\n\t\tint emissiveMap;\n\n\t\tint normalMap;\n\t\tvec2 normalScale;\n\n\t\tfloat clearcoat;\n\t\tint clearcoatMap;\n\t\tint clearcoatNormalMap;\n\t\tvec2 clearcoatNormalScale;\n\t\tfloat clearcoatRoughness;\n\t\tint clearcoatRoughnessMap;\n\n\t\tint iridescenceMap;\n\t\tint iridescenceThicknessMap;\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThicknessMinimum;\n\t\tfloat iridescenceThicknessMaximum;\n\n\t\tvec3 specularColor;\n\t\tint specularColorMap;\n\n\t\tfloat specularIntensity;\n\t\tint specularIntensityMap;\n\t\tbool thinFilm;\n\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\tint alphaMap;\n\n\t\tbool castShadow;\n\t\tfloat opacity;\n\t\tfloat alphaTest;\n\n\t\tfloat side;\n\t\tbool matte;\n\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tint sheenColorMap;\n\t\tfloat sheenRoughness;\n\t\tint sheenRoughnessMap;\n\n\t\tbool vertexColors;\n\t\tbool flatShading;\n\t\tbool transparent;\n\t\tbool fogVolume;\n\n\t\tmat3 mapTransform;\n\t\tmat3 metalnessMapTransform;\n\t\tmat3 roughnessMapTransform;\n\t\tmat3 transmissionMapTransform;\n\t\tmat3 emissiveMapTransform;\n\t\tmat3 normalMapTransform;\n\t\tmat3 clearcoatMapTransform;\n\t\tmat3 clearcoatNormalMapTransform;\n\t\tmat3 clearcoatRoughnessMapTransform;\n\t\tmat3 sheenColorMapTransform;\n\t\tmat3 sheenRoughnessMapTransform;\n\t\tmat3 iridescenceMapTransform;\n\t\tmat3 iridescenceThicknessMapTransform;\n\t\tmat3 specularColorMapTransform;\n\t\tmat3 specularIntensityMapTransform;\n\n\t};\n\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\n\n\t\tmat3 textureTransform;\n\n\t\tvec4 row1 = texelFetch1D( tex, index );\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\n\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\n\n\t\treturn textureTransform;\n\n\t}\n\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\n\n\t\tuint i = index * 45u;\n\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\n\n\t\tMaterial m;\n\t\tm.color = s0.rgb;\n\t\tm.map = int( round( s0.a ) );\n\n\t\tm.metalness = s1.r;\n\t\tm.metalnessMap = int( round( s1.g ) );\n\t\tm.roughness = s1.b;\n\t\tm.roughnessMap = int( round( s1.a ) );\n\n\t\tm.ior = s2.r;\n\t\tm.transmission = s2.g;\n\t\tm.transmissionMap = int( round( s2.b ) );\n\t\tm.emissiveIntensity = s2.a;\n\n\t\tm.emissive = s3.rgb;\n\t\tm.emissiveMap = int( round( s3.a ) );\n\n\t\tm.normalMap = int( round( s4.r ) );\n\t\tm.normalScale = s4.gb;\n\n\t\tm.clearcoat = s4.a;\n\t\tm.clearcoatMap = int( round( s5.r ) );\n\t\tm.clearcoatRoughness = s5.g;\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\n\t\tm.clearcoatNormalScale = s6.rg;\n\n\t\tm.sheen = s6.a;\n\t\tm.sheenColor = s7.rgb;\n\t\tm.sheenColorMap = int( round( s7.a ) );\n\t\tm.sheenRoughness = s8.r;\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\n\n\t\tm.iridescenceMap = int( round( s8.b ) );\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\n\t\tm.iridescence = s9.r;\n\t\tm.iridescenceIor = s9.g;\n\t\tm.iridescenceThicknessMinimum = s9.b;\n\t\tm.iridescenceThicknessMaximum = s9.a;\n\n\t\tm.specularColor = s10.rgb;\n\t\tm.specularColorMap = int( round( s10.a ) );\n\n\t\tm.specularIntensity = s11.r;\n\t\tm.specularIntensityMap = int( round( s11.g ) );\n\t\tm.thinFilm = bool( s11.b );\n\n\t\tm.attenuationColor = s12.rgb;\n\t\tm.attenuationDistance = s12.a;\n\n\t\tm.alphaMap = int( round( s13.r ) );\n\n\t\tm.opacity = s13.g;\n\t\tm.alphaTest = s13.b;\n\t\tm.side = s13.a;\n\n\t\tm.matte = bool( s14.r );\n\t\tm.castShadow = ! bool( s14.g );\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\n\t\tm.transparent = bool( s14.a );\n\n\t\tuint firstTextureTransformIdx = i + 15u;\n\n\t\tm.mapTransform = m.map == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx );\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\n\n\t\treturn m;\n\n\t}\n\n\n\t\t\t\t\n\n#ifndef FOG_CHECK_ITERATIONS\n#define FOG_CHECK_ITERATIONS 30\n#endif\n\n// returns whether the given material is a fog material or not\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\n\n\tuint i = materialIndex * 45u;\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\n\treturn bool( int( s14.b ) & 4 );\n\n}\n\n// returns true if we're within the first fog volume we hit\nbool bvhIntersectFogVolumeHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\tusampler2D materialIndexAttribute, sampler2D materials,\n\tout Material material\n) {\n\n\tmaterial.fogVolume = false;\n\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\n\n\t\t// find nearest hit\n\t\tuvec4 faceIndices = uvec4( 0u );\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\tvec3 barycoord = vec3( 0.0 );\n\t\tfloat side = 1.0;\n\t\tfloat dist = 0.0;\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\t\tif ( hit ) {\n\n\t\t\t// if it's a fog volume return whether we hit the front or back face\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\n\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\n\t\t\t\treturn side == - 1.0;\n\n\t\t\t} else {\n\n\t\t\t\t// move the ray forward\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\n\n\n\t\t\t\t// sampling\n\t\t\t\t\n\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\n\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\n\t\tfloat a = - 1.0 / ( sign + n.z );\n\t\tfloat b = n.x * n.y * a;\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\n\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat theta = 2.0 * PI * uv.y;\n\t\tfloat x = r * cos( theta );\n\t\tfloat y = r * sin( theta );\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\n\n\t}\n\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\n\n\t\t// get the edges of the triangle and the diagonal across the\n\t\t// center of the parallelogram\n\t\tvec2 e1 = a - b;\n\t\tvec2 e2 = c - b;\n\t\tvec2 diag = normalize( e1 + e2 );\n\n\t\t// pick the point in the parallelogram\n\t\tif ( r.x + r.y > 1.0 ) {\n\n\t\t\tr = vec2( 1.0 ) - r;\n\n\t\t}\n\n\t\treturn e1 * r.x + e2 * r.y;\n\n\t}\n\n\tvec2 sampleCircle( vec2 uv ) {\n\n\t\tfloat angle = 2.0 * PI * uv.x;\n\t\tfloat radius = sqrt( uv.y );\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\n\n\t}\n\n\tvec3 sampleSphere( vec2 uv ) {\n\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\n\t\tfloat t = uv.y * PI * 2.0;\n\t\tfloat f = sqrt( 1.0 - u * u );\n\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\n\n\t}\n\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\n\n\t\tsides = max( sides, 3 );\n\n\t\tvec3 r = uvw;\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\n\t\tfloat segment = floor( float( sides ) * r.x );\n\n\t\tfloat angle1 = anglePerSegment * segment;\n\t\tfloat angle2 = angle1 + anglePerSegment;\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\n\t\tvec2 b = vec2( 0.0, 0.0 );\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\n\n\t\treturn sampleTriangle( a, b, c, r.yz );\n\n\t}\n\n\t// samples an aperture shape with the given number of sides. 0 means circle\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\n\n\t\treturn blades == 0 ?\n\t\t\tsampleCircle( uvw.xy ) :\n\t\t\tsampleRegularPolygon( blades, uvw );\n\n\t}\n\n\n\n\t\t\t\t\n\n\tstruct SurfaceRecord {\n\n\t\t// surface type\n\t\tbool volumeParticle;\n\n\t\t// geometry\n\t\tvec3 faceNormal;\n\t\tbool frontFace;\n\t\tvec3 normal;\n\t\tmat3 normalBasis;\n\t\tmat3 normalInvBasis;\n\n\t\t// cached properties\n\t\tfloat eta;\n\t\tfloat f0;\n\n\t\t// material\n\t\tfloat roughness;\n\t\tfloat filteredRoughness;\n\t\tfloat metalness;\n\t\tvec3 color;\n\t\tvec3 emission;\n\n\t\t// transmission\n\t\tfloat ior;\n\t\tfloat transmission;\n\t\tbool thinFilm;\n\t\tvec3 attenuationColor;\n\t\tfloat attenuationDistance;\n\n\t\t// clearcoat\n\t\tvec3 clearcoatNormal;\n\t\tmat3 clearcoatBasis;\n\t\tmat3 clearcoatInvBasis;\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tfloat filteredClearcoatRoughness;\n\n\t\t// sheen\n\t\tfloat sheen;\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\n\t\t// iridescence\n\t\tfloat iridescence;\n\t\tfloat iridescenceIor;\n\t\tfloat iridescenceThickness;\n\n\t\t// specular\n\t\tvec3 specularColor;\n\t\tfloat specularIntensity;\n\t};\n\n\tstruct ScatterRecord {\n\t\tfloat specularPdf;\n\t\tfloat pdf;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\t\n\n\t// The GGX functions provide sampling and distribution information for normals as output so\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\n\t// [2] http://jcgt.org/published/0007/04/01/\n\t// [4] http://jcgt.org/published/0003/02/03/\n\n\t// trowbridge-reitz === GGX === GTR\n\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\n\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\n\t\t// function below, as well\n\n\t\t// Implementation from reference [1]\n\t\t// stretch view\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\n\n\t\t// orthonormal basis\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\n\t\tvec3 T2 = cross( T1, V );\n\n\t\t// sample point with polar coordinates (r, phi)\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\n\t\tfloat r = sqrt( uv.x );\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\n\t\tfloat P1 = r * cos( phi );\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\n\n\t\t// compute normal\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\n\n\t\t// unstretch\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\n\n\t\treturn N;\n\n\t}\n\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\n\t// as specified in Appendix B of the following paper\n\t// See equation (34) from reference [0]\n\tfloat ggxLamda( float theta, float roughness ) {\n\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\n\t\tfloat alpha2 = roughness * roughness;\n\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\n\t\treturn numerator / 2.0;\n\n\t}\n\n\t// See equation (34) from reference [0]\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\n\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\n\n\t}\n\n\t// See equation (125) from reference [4]\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat scatterTheta = acos( wo.z );\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\n\n\t}\n\n\t// See equation (33) from reference [0]\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\n\n\t\tfloat a2 = roughness * roughness;\n\t\ta2 = max( EPSILON, a2 );\n\t\tfloat cosTheta = halfVector.z;\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\n\n\t\tif ( cosTheta == 0.0 ) return 0.0;\n\n\t\tfloat theta = acosSafe( halfVector.z );\n\t\tfloat tanTheta = tan( theta );\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\n\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\n\t\treturn ( a2 / denom );\n\n\t}\n\n\t// See equation (3) from reference [2]\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\n\n\t\tfloat incidentTheta = acos( wi.z );\n\t\tfloat D = ggxDistribution( halfVector, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\n\n\t}\n\n\n\t\n\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetD( float cosThetaH, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat invAlpha = 1.0 / alpha;\n\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\n\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\n\n\t}\n\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\n\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\n\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\n\n\t}\n\n\tfloat velvetL( float x, float alpha ) {\n\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\n\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\n\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\n\n\t}\n\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetLambda( float cosTheta, float alpha ) {\n\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\n\n\t}\n\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\n\n\t\tfloat alpha = max( roughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\n\n\t}\n\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\n\n\t\tcosTheta = saturate( cosTheta );\n\n\t\tfloat c = 1.0 - cosTheta;\n\t\tfloat c3 = c * c * c;\n\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\n\n\t}\n\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\n\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\n\n\t}\n\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\n\t\talpha = alpha * alpha;\n\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\n\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\n\n\t\treturn 1.0 - maxSheenColor * eWo;\n\n\t}\n\n\n\t\n\n\t// XYZ to sRGB color space\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\n\t\txyz /= 1.0685e-7;\n\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\n\t\treturn srgb;\n\n\t}\n\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\n\t\t\treturn vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIor < outsideIOR ) {\n\n\t\t\tphi12 = PI;\n\n\t\t}\n\n\t\tfloat phi21 = PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[0] < iridescenceIor ) {\n\n\t\t\tphi23[ 0 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[1] < iridescenceIor ) {\n\n\t\t\tphi23[ 1 ] = PI;\n\n\t\t}\n\n\t\tif ( baseIOR[2] < iridescenceIor ) {\n\n\t\t\tphi23[ 2 ] = PI;\n\n\t\t}\n\n\t\t// Phase shift\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m = 0 (DC term amplitude)\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\n\t\t// Reflectance term for m > 0 (pairs of diracs)\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n\n\n\t// diffuse\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\n\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\n\n\t\t// TODO: subsurface approx?\n\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\n\t\treturn wi.z / PI;\n\n\t}\n\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tvec3 lightDirection = sampleSphere( sobol2( 11 ) );\n\t\tlightDirection.z += 1.0;\n\t\tlightDirection = normalize( lightDirection );\n\n\t\treturn lightDirection;\n\n\t}\n\n\t// specular\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\n\t\tfloat metalness = surf.metalness;\n\t\tfloat roughness = surf.filteredRoughness;\n\n\t\tfloat eta = surf.eta;\n\t\tfloat f0 = surf.f0;\n\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\n\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\n\n\t\t// PDF\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\n\t\tfloat incidentTheta = acos( wo.z );\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\n\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\n\n\t}\n\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 12 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\n\t// transmission\n\t/*\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\t\tbool thinFilm = surf.thinFilm;\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat filteredRoughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tbool frontFace = surf.frontFace;\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( filteredRoughness ),\n\t\t\tsobol2( 13 )\n\t\t);\n\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\n\t\treturn normalize( lightDirection );\n\n\t}\n\t*/\n\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, out vec3 color ) {\n\n\t\tcolor = surf.transmission * surf.color;\n\n\t\t// PDF\n\t\tfloat F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\t\tif ( F >= 1.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 1.0 - F );\n\n\t}\n\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\tfloat roughness = surf.filteredRoughness;\n\t\tfloat eta = surf.eta;\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( sobol2( 13 ) ) * roughness );\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\n\n\t\tif ( surf.thinFilm ) {\n\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\n\n\t\t}\n\t\treturn normalize( lightDirection );\n\n\t}\n\n\t// clearcoat\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\n\n\t\tfloat ior = 1.5;\n\t\tfloat f0 = iorRatioToF0( ior );\n\t\tbool frontFace = surf.frontFace;\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\n\t\tfloat D = ggxDistribution( wh, roughness );\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\n\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\n\n\t\t// PDF\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\n\n\t}\n\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\n\n\t\t// sample ggx vndf distribution which gives a new normal\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\n\t\tvec3 halfVector = ggxDirection(\n\t\t\two,\n\t\t\tvec2( roughness ),\n\t\t\tsobol2( 14 )\n\t\t);\n\n\t\t// apply to new ray by reflecting off the new normal\n\t\treturn - reflect( wo, halfVector );\n\n\t}\n\n\t// sheen\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\n\n\t\tfloat cosThetaO = saturateCos( wo.z );\n\t\tfloat cosThetaI = saturateCos( wi.z );\n\t\tfloat cosThetaH = wh.z;\n\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\n\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\n\t\tvec3 color = surf.sheenColor;\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\n\t\tcolor *= wi.z;\n\n\t\treturn color;\n\n\t}\n\n\t// bsdf\n\tvoid getLobeWeights(\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\n\t\tout float diffuseWeight, out float specularWeight, out float transmissionWeight, out float clearcoatWeight\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\t\tfloat fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\n\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\n\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\n\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\n\t\tdiffuseWeight /= totalWeight;\n\t\tspecularWeight /= totalWeight;\n\t\ttransmissionWeight /= totalWeight;\n\t\tclearcoatWeight /= totalWeight;\n\t}\n\n\tfloat bsdfEval(\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, out float specularPdf, out vec3 color\n\t) {\n\n\t\tfloat metalness = surf.metalness;\n\t\tfloat transmission = surf.transmission;\n\n\t\tfloat spdf = 0.0;\n\t\tfloat dpdf = 0.0;\n\t\tfloat tpdf = 0.0;\n\t\tfloat cpdf = 0.0;\n\t\tcolor = vec3( 0.0 );\n\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\n\n\t\t// diffuse\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\n\t\t\tcolor *= 1.0 - surf.transmission;\n\n\t\t}\n\n\t\t// ggx specular\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\n\n\t\t\tvec3 outColor;\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\n\t\t\tcolor += outColor;\n\n\t\t}\n\n\t\t// transmission\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\n\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\n\n\t\t}\n\n\t\t// sheen\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\n\n\t\t// clearcoat\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\n\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\n\n\t\t}\n\n\t\tfloat pdf =\n\t\t\tdpdf * diffuseWeight\n\t\t\t+ spdf * specularWeight\n\t\t\t+ tpdf * transmissionWeight\n\t\t\t+ cpdf * clearcoatWeight;\n\n\t\t// retrieve specular rays for the shadows flag\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\n\n\t\treturn pdf;\n\n\t}\n\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, out vec3 color ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tcolor = surf.color / ( 4.0 * PI );\n\t\t\treturn 1.0 / ( 4.0 * PI );\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\n\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\n\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat specularPdf;\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\n\n\t}\n\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\n\n\t\tif ( surf.volumeParticle ) {\n\n\t\t\tScatterRecord sampleRec;\n\t\t\tsampleRec.specularPdf = 0.0;\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\n\t\t\tsampleRec.direction = sampleSphere( sobol2( 16 ) );\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\n\t\t\treturn sampleRec;\n\n\t\t}\n\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\n\t\tmat3 normalBasis = surf.normalBasis;\n\t\tmat3 invBasis = surf.normalInvBasis;\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\n\n\t\tfloat diffuseWeight;\n\t\tfloat specularWeight;\n\t\tfloat transmissionWeight;\n\t\tfloat clearcoatWeight;\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\n\n\t\tfloat pdf[4];\n\t\tpdf[0] = diffuseWeight;\n\t\tpdf[1] = specularWeight;\n\t\tpdf[2] = transmissionWeight;\n\t\tpdf[3] = clearcoatWeight;\n\n\t\tfloat cdf[4];\n\t\tcdf[0] = pdf[0];\n\t\tcdf[1] = pdf[1] + cdf[0];\n\t\tcdf[2] = pdf[2] + cdf[1];\n\t\tcdf[3] = pdf[3] + cdf[2];\n\n\t\tif( cdf[3] != 0.0 ) {\n\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\n\t\t\tcdf[0] *= invMaxCdf;\n\t\t\tcdf[1] *= invMaxCdf;\n\t\t\tcdf[2] *= invMaxCdf;\n\t\t\tcdf[3] *= invMaxCdf;\n\n\t\t} else {\n\n\t\t\tcdf[0] = 1.0;\n\t\t\tcdf[1] = 0.0;\n\t\t\tcdf[2] = 0.0;\n\t\t\tcdf[3] = 0.0;\n\n\t\t}\n\n\t\tvec3 wi;\n\t\tvec3 clearcoatWi;\n\n\t\tfloat r = sobol( 15 );\n\t\tif ( r <= cdf[0] ) { // diffuse\n\n\t\t\twi = diffuseDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[1] ) { // specular\n\n\t\t\twi = specularDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\n\n\t\t\twi = transmissionDirection( wo, surf );\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\n\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\n\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\n\n\t\t}\n\n\t\tScatterRecord result;\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\n\t\tresult.direction = normalize( surf.normalBasis * wi );\n\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\t// samples the the given environment map in the given direction\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\n\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\n\n\t}\n\n\t// gets the pdf of the given direction to sample\n\tfloat equirectDirectionPdf( vec3 direction ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tfloat theta = uv.y * PI;\n\t\tfloat sinTheta = sin( theta );\n\t\tif ( sinTheta == 0.0 ) {\n\n\t\t\treturn 0.0;\n\n\t\t}\n\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\n\n\t}\n\n\t// samples the color given env map with CDF and returns the pdf of the direction\n\tfloat sampleEquirect( EquirectHdrInfo info, vec3 direction, out vec3 color ) {\n\n\t\tvec2 uv = equirectDirectionToUv( direction );\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\t// samples a direction of the envmap with color and retrieves pdf\n\tfloat sampleEquirectProbability( EquirectHdrInfo info, vec2 r, out vec3 color, out vec3 direction ) {\n\n\t\t// sample env map cdf\n\t\tfloat v = texture2D( info.marginalWeights, vec2( r.x, 0.0 ) ).x;\n\t\tfloat u = texture2D( info.conditionalWeights, vec2( r.y, v ) ).x;\n\t\tvec2 uv = vec2( u, v );\n\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\n\t\tdirection = derivedDirection;\n\t\tcolor = texture2D( info.map, uv ).rgb;\n\n\t\tfloat totalSum = info.totalSum;\n\t\tfloat lum = luminance( color );\n\t\tivec2 resolution = textureSize( info.map, 0 );\n\t\tfloat pdf = lum / totalSum;\n\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\n\n\t}\n\n\n\t\t\t\t\n\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n\t}\n\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\n\n\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t}\n\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\n\n\t\tfloat cosTheta = dot( posToLight, lightDir );\n\t\tfloat angle = acos( cosTheta ) * ( 1.0 / PI );\n\n\t\treturn texture2D( iesProfiles, vec3( 0.0, angle, iesProfile ) ).r;\n\n\t}\n\n\tstruct LightRecord {\n\n\t\tfloat dist;\n\t\tvec3 direction;\n\t\tfloat pdf;\n\t\tvec3 emission;\n\t\tint type;\n\n\t};\n\n\tbool lightsClosestHit( sampler2D lights, uint lightCount, vec3 rayOrigin, vec3 rayDirection, out LightRecord lightRec ) {\n\n\t\tbool didHit = false;\n\t\tuint l;\n\t\tfor ( l = 0u; l < lightCount; l ++ ) {\n\n\t\t\tLight light = readLightInfo( lights, l );\n\n\t\t\tvec3 u = light.u;\n\t\t\tvec3 v = light.v;\n\n\t\t\t// check for backface\n\t\t\tvec3 normal = normalize( cross( u, v ) );\n\t\t\tif ( dot( normal, rayDirection ) < 0.0 ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tu *= 1.0 / dot( u, u );\n\t\t\tv *= 1.0 / dot( v, v );\n\n\t\t\tfloat dist;\n\n\t\t\t// MIS / light intersection is not supported for punctual lights.\n\t\t\tif(\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\n\t\t\t) {\n\n\t\t\t\tif ( ! didHit || dist < lightRec.dist ) {\n\n\t\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\n\t\t\t\t\tdidHit = true;\n\t\t\t\t\tlightRec.dist = dist;\n\t\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\n\t\t\t\t\tlightRec.emission = light.color * light.intensity;\n\t\t\t\t\tlightRec.direction = rayDirection;\n\t\t\t\t\tlightRec.type = light.type;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn didHit;\n\n\t}\n\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\n\t\tlightRec.emission = light.color * light.intensity;\n\n\t\tvec3 randomPos;\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\n\n\t\t\t// rectangular area light\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\n\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\n\n\t\t\t// circular area light\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\t\tfloat x = r * cos( theta );\n\t\t\tfloat y = r * sin( theta );\n\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\n\n\t\t}\n\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tlightRec.dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / lightRec.dist;\n\t\tlightRec.direction = direction;\n\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\n\n\t\tfloat radius = light.radius * sqrt( ruv.x );\n\t\tfloat theta = ruv.y * 2.0 * PI;\n\t\tfloat x = radius * cos( theta );\n\t\tfloat y = radius * sin( theta );\n\n\t\tvec3 u = light.u;\n\t\tvec3 v = light.v;\n\t\tvec3 normal = normalize( cross( u, v ) );\n\n\t\tfloat angle = acos( light.coneCos );\n\t\tfloat angleTan = tan( angle );\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\n\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\n\t\tvec3 toLight = randomPos - rayOrigin;\n\t\tfloat lightDistSq = dot( toLight, toLight );\n\t\tfloat dist = sqrt( lightDistSq );\n\n\t\tvec3 direction = toLight / max( dist, EPSILON );\n\t\tfloat cosTheta = dot( direction, normal );\n\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\n\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\n\t\tLightRecord lightRec;\n\t\tlightRec.type = light.type;\n\t\tlightRec.dist = dist;\n\t\tlightRec.direction = direction;\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\n\t\tlightRec.pdf = 1.0;\n\n\t\treturn lightRec;\n\n\t}\n\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\n\n\t\t// pick a random light\n\t\tuint l = uint( ruv.x * float( lightCount ) );\n\t\tLight light = readLightInfo( lights, l );\n\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\n\n\t\t\treturn randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\n\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\n\n\t\t\tvec3 lightRay = light.u - rayOrigin;\n\t\t\tfloat lightDist = length( lightRay );\n\t\t\tfloat cutoffDistance = light.distance;\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\n\t\t\tif ( cutoffDistance > 0.0 ) {\n\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\n\n\t\t\t}\n\n\t\t\tLightRecord rec;\n\t\t\trec.direction = normalize( lightRay );\n\t\t\trec.dist = length( lightRay );\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\n\t\t\trec.type = light.type;\n\t\t\treturn rec;\n\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\n\n\t\t\tLightRecord rec;\n\t\t\trec.dist = 1e10;\n\t\t\trec.direction = light.u;\n\t\t\trec.pdf = 1.0;\n\t\t\trec.emission = light.color * light.intensity;\n\t\t\trec.type = light.type;\n\n\t\t\treturn rec;\n\n\t\t} else {\n\n\t\t\t// sample the light\n\t\t\treturn randomAreaLightSample( light, rayOrigin, ruv.yz );\n\n\t\t}\n\n\t}\n\n\n\t\t\t\t\n\n\t// returns the hit distance given the material density\n\tfloat intersectFogVolume( Material material, float u ) {\n\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\n\n\t}\n\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\n\n\t\tScatterRecord sampleRec;\n\t\tsampleRec.specularPdf = 0.0;\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\n\t\tsampleRec.direction = sampleSphere( uv );\n\t\tsampleRec.color = surf.color;\n\t\treturn sampleRec;\n\n\t}\n\n\n\n\t\t\t\t// environment\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\n\t\t\t\tuniform mat4 environmentRotation;\n\t\t\t\tuniform float environmentIntensity;\n\n\t\t\t\t// lighting\n\t\t\t\tuniform sampler2DArray iesProfiles;\n\t\t\t\tuniform LightsInfo lights;\n\n\t\t\t\t// background\n\t\t\t\tuniform float backgroundBlur;\n\t\t\t\tuniform float backgroundAlpha;\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\tuniform sampler2D backgroundMap;\n\n\t\t\t\t#endif\n\n\t\t\t\t// camera\n\t\t\t\tuniform mat4 cameraWorldMatrix;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\t#if FEATURE_DOF\n\n\t\t\t\tuniform PhysicalCamera physicalCamera;\n\n\t\t\t\t#endif\n\n\t\t\t\t// geometry\n\t\t\t\tuniform sampler2DArray attributesArray;\n\t\t\t\tuniform usampler2D materialIndexAttribute;\n\t\t\t\tuniform sampler2D materials;\n\t\t\t\tuniform sampler2DArray textures;\n\t\t\t\tuniform BVH bvh;\n\n\t\t\t\t// path tracer\n\t\t\t\tuniform int bounces;\n\t\t\t\tuniform int transmissiveBounces;\n\t\t\t\tuniform float filterGlossyFactor;\n\t\t\t\tuniform int seed;\n\n\t\t\t\t// image\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t// globals\n\t\t\t\tmat3 envRotation3x3;\n\t\t\t\tmat3 invEnvRotation3x3;\n\t\t\t\tfloat lightsDenom;\n\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\n\n\t\t\t\t\treturn clamp(\n\t\t\t\t\t\tmax(\n\t\t\t\t\t\t\troughness,\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\n\t\t\t\t\t\t0.0,\n\t\t\t\t\t\t1.0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\n\n\t\t\t\t\tvec3 sampleDir = normalize( direction + sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur );\n\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\n\n\t\t\t\t\treturn sampleEquirectColor( backgroundMap, sampleDir );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t\t\n\n\tstruct Ray {\n\n\t\tvec3 origin;\n\t\tvec3 direction;\n\n\t};\n\n\tstruct SurfaceHit {\n\n\t\tuvec4 faceIndices;\n\t\tvec3 barycoord;\n\t\tvec3 faceNormal;\n\t\tfloat side;\n\t\tfloat dist;\n\n\t};\n\n\tstruct RenderState {\n\n\t\tbool firstRay;\n\t\tbool transmissiveRay;\n\t\tbool isShadowRay;\n\t\tfloat accumulatedRoughness;\n\t\tint transmissiveTraversals;\n\t\tint traversals;\n\t\tuint depth;\n\t\tvec3 throughputColor;\n\t\tMaterial fogMaterial;\n\n\t};\n\n\tRenderState initRenderState() {\n\n\t\tRenderState result;\n\t\tresult.firstRay = true;\n\t\tresult.transmissiveRay = true;\n\t\tresult.isShadowRay = false;\n\t\tresult.accumulatedRoughness = 0.0;\n\t\tresult.transmissiveTraversals = 0;\n\t\tresult.traversals = 0;\n\t\tresult.throughputColor = vec3( 1.0 );\n\t\tresult.depth = 0u;\n\t\tresult.fogMaterial.fogVolume = false;\n\t\treturn result;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 ndcToRayOrigin( vec2 coord ) {\n\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\n\t}\n\n\tRay getCameraRay() {\n\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\n\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\n\t\t// around this pixel's UV coordinate for AA\n\t\tvec2 ruv = sobol2( 0 );\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\n\t\tRay ray;\n\n\t\t#if CAMERA_TYPE == 2\n\n\t\t\t// Equirectangular projection\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\n\n\t\t\tray.direction = normalize( rayDirection4.xyz );\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\n\n\t\t#else\n\n\t\t\t// get [- 1, 1] normalized device coordinates\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\n\t\t\tray.origin = ndcToRayOrigin( ndc );\n\n\t\t\t#if CAMERA_TYPE == 1\n\n\t\t\t\t// Orthographic projection\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\n\t\t\t\tray.direction = normalize( ray.direction );\n\n\t\t\t#else\n\n\t\t\t\t// Perspective projection\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#if FEATURE_DOF\n\t\t{\n\n\t\t\t// depth of field\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\n\n\t\t\t// get the aperture sample\n\t\t\t// if blades === 0 then we assume a circle\n\t\t\tvec3 shapeUVW= sobol3( 1 );\n\t\t\tint blades = physicalCamera.apertureBlades;\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\n\n\t\t\t// rotate the aperture shape\n\t\t\tapertureSample =\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\n\n\t\t\t// create the new ray\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\n\t\t\tray.direction = focalPoint - ray.origin;\n\n\t\t}\n\t\t#endif\n\n\t\tray.direction = normalize( ray.direction );\n\n\t\treturn ray;\n\n\t}\n\n\n\t\t\t\t\n\n\t#define NO_HIT 0\n\t#define SURFACE_HIT 1\n\t#define LIGHT_HIT 2\n\t#define FOG_HIT 3\n\n\tint traceScene(\n\n\t\tRay ray, BVH bvh, LightsInfo lights, Material fogMaterial,\n\t\tout SurfaceHit surfaceHit, out LightRecord lightRec\n\n\t) {\n\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\n\t\tbool lightHit = lightsClosestHit( lights.tex, lights.count, ray.origin, ray.direction, lightRec );\n\n\t\t#if FEATURE_FOG\n\n\t\tif ( fogMaterial.fogVolume ) {\n\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, sobol( 1 ) );\n\t\t\tif ( particleDist + 1e-4 < surfaceHit.dist && ( particleDist + 1e-4 < lightRec.dist || ! lightHit ) ) {\n\n\t\t\t\tsurfaceHit.side = 1.0;\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\n\t\t\t\tsurfaceHit.dist = particleDist;\n\t\t\t\treturn FOG_HIT;\n\n\t\t\t}\n\n\t\t}\n\n\t\t#endif\n\n\t\tif ( lightHit && ( lightRec.dist < surfaceHit.dist || ! hit ) ) {\n\n\t\t\treturn LIGHT_HIT;\n\n\t\t}\n\n\t\tif ( hit ) {\n\n\t\t\treturn SURFACE_HIT;\n\n\t\t}\n\n\t\treturn NO_HIT;\n\n\t}\n\n\n\t\t\t\t\n\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\n\t// returns true if a solid surface was hit\n\tbool attenuateHit(\n\t\tBVH bvh, RenderState state,\n\t\tRay ray, float rayDist,\n\t\tout vec3 color\n\t) {\n\n\t\tint traversals = state.traversals;\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\n\t\tbool isShadowRay = state.isShadowRay;\n\t\tMaterial fogMaterial = state.fogMaterial;\n\n\t\tvec3 startPoint = ray.origin;\n\n\t\t// hit results\n\t\tSurfaceHit surfaceHit;\n\t\tLightRecord lightRec;\n\n\t\tcolor = vec3( 1.0 );\n\n\t\t// TODO: we should be using sobol sampling here instead of rand but the sobol bounce and path indices need to be incremented\n\t\t// and then reset.\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\n\n\t\t\tint hitType = traceScene(\n\t\t\t\tray, bvh, lights, fogMaterial,\n\t\t\t\tsurfaceHit, lightRec\n\t\t\t);\n\n\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( hitType == LIGHT_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * lightRec.dist );\n\t\t\t\treturn totalDist < rayDist - max( totalDist, rayDist ) * 1e-4;\n\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\n\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\n\t\t\t\tif ( totalDist > rayDist ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\n\t\t\t\t// TODO: should we account for emissive surfaces here?\n\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t// adjust the ray to the new surface\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\tif ( material.fogVolume ) {\n\n\t\t\t\t\tfogMaterial = material;\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t\t\t// albedo\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\t\t\tif ( material.map != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.vertexColors ) {\n\n\t\t\t\t\talbedo *= vertexColor;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMap\n\t\t\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t\t\t}\n\n\t\t\t\t// transmission\n\t\t\t\tfloat transmission = material.transmission;\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t\t\t}\n\n\t\t\t\t// metalness\n\t\t\t\tfloat metalness = material.metalness;\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t\t\t}\n\n\t\t\t\tfloat alphaTest = material.alphaTest;\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\n\t\t\t\tif (\n\t\t\t\t\ttransmissionFactor < rand() && ! (\n\t\t\t\t\t\t// material sidedness\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\n\n\t\t\t\t\t\t// alpha test\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t\t\t\t// opacity\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand()\n\t\t\t\t\t)\n\t\t\t\t) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\n\n\t\t\t\t\t// only attenuate by surface color on the way in\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\n\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\n\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\n\n\t\t\t\t}\n\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\n\n\t\t\t\t\ti -= sign( transmissiveTraversals );\n\t\t\t\t\ttransmissiveTraversals --;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\n\t\t\t\t\n\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\n\n\t\t// uniformly pick a light or environment map\n\t\tif( lightsDenom != 0.0 && sobol( 5 ) < float( lights.count ) / lightsDenom ) {\n\n\t\t\t// sample a light or environment\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, sobol3( 6 ) );\n\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tlightRec.pdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the light area\n\t\t\tRay lightRay;\n\t\t\tlightRay.origin = rayOrigin;\n\t\t\tlightRay.direction = lightRec.direction;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tlightRec.pdf > 0.0 &&\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( bvh, state, lightRay, lightRec.dist, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\n\t\t\t\t\treturn attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find a sample in the environment map to include in the contribution\n\t\t\tvec3 envColor, envDirection;\n\t\t\tfloat envPdf = sampleEquirectProbability( envMapInfo, sobol2( 7 ), envColor, envDirection );\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\n\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\n\t\t\t// results so we ignore the sample in this case.\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\n\t\t\tif ( isSampleBelowSurface ) {\n\n\t\t\t\tenvPdf = 0.0;\n\n\t\t\t}\n\n\t\t\t// check if a ray could even reach the surface\n\t\t\tRay envRay;\n\t\t\tenvRay.origin = rayOrigin;\n\t\t\tenvRay.direction = envDirection;\n\t\t\tvec3 attenuatedColor;\n\t\t\tif (\n\t\t\t\tenvPdf > 0.0 &&\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\n\t\t\t\t! attenuateHit( bvh, state, envRay, INFINITY, attenuatedColor )\n\t\t\t) {\n\n\t\t\t\t// get the material pdf\n\t\t\t\tvec3 sampleColor;\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\n\n\t\t\t\t\t// weight the direct light contribution\n\t\t\t\t\tenvPdf /= lightsDenom;\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\n\t\t\t\t\treturn attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vec3( 0.0 );\n\n\t}\n\n\n\t\t\t\t\n\n\t#define SKIP_SURFACE 0\n\t#define HIT_SURFACE 1\n\tint getSurfaceRecord(\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\n\t\tfloat accumulatedRoughness,\n\t\tout SurfaceRecord surf\n\t) {\n\n\t\tif ( material.fogVolume ) {\n\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\n\n\t\t\tSurfaceRecord fogSurface;\n\t\t\tfogSurface.volumeParticle = true;\n\t\t\tfogSurface.color = material.color;\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\n\t\t\tfogSurface.normal = normal;\n\t\t\tfogSurface.faceNormal = normal;\n\t\t\tfogSurface.clearcoatNormal = normal;\n\n\t\t\tsurf = fogSurface;\n\t\t\treturn HIT_SURFACE;\n\n\t\t}\n\n\t\t// uv coord for textures\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\n\n\t\t// albedo\n\t\tvec4 albedo = vec4( material.color, material.opacity );\n\t\tif ( material.map != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\n\t\t}\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\talbedo *= vertexColor;\n\n\t\t}\n\n\t\t// alphaMap\n\t\tif ( material.alphaMap != - 1 ) {\n\n\t\t\talbedo.a *= texture2D( textures, vec3( uv, material.alphaMap ) ).x;\n\n\t\t}\n\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\n\t\t// and it's single sided.\n\t\t// - alpha test is disabled when it === 0\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\n\t\tfloat alphaTest = material.alphaTest;\n\t\tbool useAlphaTest = alphaTest != 0.0;\n\t\tif (\n\t\t\t// material sidedness\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\n\n\t\t\t// alpha test\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\n\n\t\t\t// opacity\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < sobol( 3 )\n\t\t) {\n\n\t\t\treturn SKIP_SURFACE;\n\n\t\t}\n\n\t\t// fetch the interpolated smooth normal\n\t\tvec3 normal = normalize( textureSampleBarycoord(\n\t\t\tattributesArray,\n\t\t\tATTR_NORMAL,\n\t\t\tsurfaceHit.barycoord,\n\t\t\tsurfaceHit.faceIndices.xyz\n\t\t).xyz );\n\n\t\t// roughness\n\t\tfloat roughness = material.roughness;\n\t\tif ( material.roughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\n\n\t\t}\n\n\t\t// metalness\n\t\tfloat metalness = material.metalness;\n\t\tif ( material.metalnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\n\n\t\t}\n\n\t\t// emission\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\n\t\tif ( material.emissiveMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\n\n\t\t}\n\n\t\t// transmission\n\t\tfloat transmission = material.transmission;\n\t\tif ( material.transmissionMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\n\n\t\t}\n\n\t\t// normal\n\t\tif ( material.flatShading ) {\n\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\n\t\t\t// interpolated vertex normals.\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\n\n\t\t}\n\n\t\tvec3 baseNormal = normal;\n\t\tif ( material.normalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.normalScale;\n\t\t\t\tnormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tnormal *= surfaceHit.side;\n\n\t\t// clearcoat\n\t\tfloat clearcoat = material.clearcoat;\n\t\tif ( material.clearcoatMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\n\n\t\t}\n\n\t\t// clearcoatRoughness\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\n\n\t\t}\n\n\t\t// clearcoatNormal\n\t\tvec3 clearcoatNormal = baseNormal;\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\n\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\n\t\t\t\tattributesArray,\n\t\t\t\tATTR_TANGENT,\n\t\t\t\tsurfaceHit.barycoord,\n\t\t\t\tsurfaceHit.faceIndices.xyz\n\t\t\t);\n\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\n\t\t\t// resulting in NaNs and slow path tracing.\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\n\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\n\n\t\t\t}\n\n\t\t}\n\n\t\tclearcoatNormal *= surfaceHit.side;\n\n\t\t// sheenColor\n\t\tvec3 sheenColor = material.sheenColor;\n\t\tif ( material.sheenColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// sheenRoughness\n\t\tfloat sheenRoughness = material.sheenRoughness;\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\n\n\t\t}\n\n\t\t// iridescence\n\t\tfloat iridescence = material.iridescence;\n\t\tif ( material.iridescenceMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\n\n\t\t}\n\n\t\t// iridescence thickness\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\n\n\t\t}\n\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\n\n\t\t// specular color\n\t\tvec3 specularColor = material.specularColor;\n\t\tif ( material.specularColorMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\n\n\t\t}\n\n\t\t// specular intensity\n\t\tfloat specularIntensity = material.specularIntensity;\n\t\tif ( material.specularIntensityMap != - 1 ) {\n\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\n\n\t\t}\n\n\t\tsurf.volumeParticle = false;\n\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\n\t\tsurf.normal = normal;\n\n\t\tsurf.metalness = metalness;\n\t\tsurf.color = albedo.rgb;\n\t\tsurf.emission = emission;\n\n\t\tsurf.ior = material.ior;\n\t\tsurf.transmission = transmission;\n\t\tsurf.thinFilm = material.thinFilm;\n\t\tsurf.attenuationColor = material.attenuationColor;\n\t\tsurf.attenuationDistance = material.attenuationDistance;\n\n\t\tsurf.clearcoatNormal = clearcoatNormal;\n\t\tsurf.clearcoat = clearcoat;\n\n\t\tsurf.sheen = material.sheen;\n\t\tsurf.sheenColor = sheenColor;\n\n\t\tsurf.iridescence = iridescence;\n\t\tsurf.iridescenceIor = material.iridescenceIor;\n\t\tsurf.iridescenceThickness = iridescenceThickness;\n\n\t\tsurf.specularColor = specularColor;\n\t\tsurf.specularIntensity = specularIntensity;\n\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\n\t\t// applied by its brdf function\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\n\t\tsurf.roughness = roughness * roughness;\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\n\t\tsurf.sheenRoughness = sheenRoughness;\n\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\n\t\t// then we can just always assume this is a front face.\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\n\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\n\t\t// The accumulated roughness value is scaled by a user setting and a "magic value" of 5.0.\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\n\t\t// sharp internal reflections\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\n\n\t\t// get the normal frames\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\n\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\n\n\t\treturn HIT_SURFACE;\n\n\t}\n\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// init\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) |  uint( gl_FragCoord.y );\n\t\t\t\t\tsobolPathIndex = uint( seed );\n\n\t\t\t\t\t// get camera ray\n\t\t\t\t\tRay ray = getCameraRay();\n\n\t\t\t\t\t// inverse environment rotation\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\n\t\t\t\t\tlightsDenom = environmentIntensity == 0.0 && lights.count != 0u ? float( lights.count ) : float( lights.count + 1u );\n\n\t\t\t\t\t// final color\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\n\n\t\t\t\t\t// surface results\n\t\t\t\t\tSurfaceHit surfaceHit;\n\t\t\t\t\tLightRecord lightRec;\n\t\t\t\t\tScatterRecord scatterRec;\n\n\t\t\t\t\t// path tracing state\n\t\t\t\t\tRenderState state = initRenderState();\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\n\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\n\t\t\t\t\t\tbvh, ray.origin, - ray.direction,\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\n\t\t\t\t\t\tstate.fogMaterial\n\t\t\t\t\t);\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\n\n\t\t\t\t\t\tsobolBounceIndex ++;\n\n\t\t\t\t\t\tstate.depth ++;\n\t\t\t\t\t\tstate.traversals = bounces - i;\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\n\n\t\t\t\t\t\tint hitType = traceScene(\n\t\t\t\t\t\t\tray, bvh, lights, state.fogMaterial,\n\t\t\t\t\t\t\tsurfaceHit, lightRec\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( hitType == LIGHT_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// NOTE: we skip MIS for punctual lights since they are not supported in forward PT case\n\t\t\t\t\t\t\t\tif ( lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ) {\n\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// weight the contribution\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( hitType == NO_HIT ) {\n\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( envRotation3x3 * ray.direction, sobol2( 2 ) ) * state.throughputColor;\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\n\t\t\t\t\t\t\t\tvec3 envColor;\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envMapInfo, envRotation3x3 * ray.direction, envColor );\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\n\n\t\t\t\t\t\t\t\t// and weight the contribution\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\n\n\t\t\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\n\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\n\n\t\t\t\t\t\t#if FEATURE_FOG\n\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\n\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\n\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\n\n\t\t\t\t\t\t\tstate.fogMaterial = material;\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// early out if this is a matte material\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\n\t\t\t\t\t\t// then skip it\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSurfaceRecord surf;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgetSurfaceRecord(\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\n\t\t\t\t\t\t\t\tsurf\n\t\t\t\t\t\t\t) == SKIP_SURFACE\n\t\t\t\t\t\t) {\n\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\n\t\t\t\t\t\t\t// crash the context with too long a loop.\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\n\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < sobol( 4 );\n\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\n\n\t\t\t\t\t\t// next event estimation\n\t\t\t\t\t\t#if FEATURE_MIS\n\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\n\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// accumulate emissive color\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\n\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\n\t\t\t\t\t\t// perform this separate from a bounce\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\n\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\n\t\t\t\t\t\t\ti --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// handle throughput color transformation\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\n\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\n\n\t\t\t\t\t\t// russian roulette path termination\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\n\t\t\t\t\t\tuint minBounces = 3u;\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\n\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\n\t\t\t\t\t\trrProb = sqrt( rrProb );\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\n\t\t\t\t\t\tif ( sobol( 8 ) > rrProb ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\t// prepare for next ray\n\t\t\t\t\t\tray.direction = scatterRec.direction;\n\t\t\t\t\t\tray.origin = hitPoint;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor.a *= opacity;\n\n\t\t\t\t\t#if DEBUG_MODE == 1\n\n\t\t\t\t\t// output the number of rays checked in the path and number of\n\t\t\t\t\t// transmissive rays encountered.\n\t\t\t\t\tgl_FragColor.rgb = vec3(\n\t\t\t\t\t\tfloat( state.depth ),\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\n\t\t\t\t\t\t0.0\n\t\t\t\t\t);\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}},PhysicalSpotLight:class extends pu{constructor(...t){super(...t),this.iesTexture=null,this.radius=0}copy(t,e){return super.copy(t,e),this.iesTexture=t.iesTexture,this.radius=t.radius,this}},ProceduralEquirectTexture:nv,QuiltPathTracingRenderer:class extends Vg{get samples(){return this._samples/this.viewCount}constructor(...t){super(...t),["quiltDimensions","viewCount","viewCone","viewFoV","displayDistance","displayAspect"].forEach((t=>{Object.defineProperty(this,t,{enumerable:!0,set:e=>{this._quiltUtility[t]=e},get:()=>this._quiltUtility[t]})})),this._quiltUtility=new jg,this._quiltSamples=0,this._camera=new Mr,this._quiltTask=null}setFromDisplayView(...t){this._quiltUtility.setFromDisplayView(...t)}update(){this.alpha=!1,this._quiltTask||(this._quiltTask=Wg.call(this,(()=>{super.update()}))),this._quiltTask.next()}reset(){super.reset(),this._quiltTask=null,this._quiltSamples=0}},RenderTarget2DArray:hv,ShapedAreaLight:class extends wu{constructor(...t){super(...t),this.isCircular=!1}copy(t,e){return super.copy(t,e),this.isCircular=t.isCircular,this}},getGroupMaterialIndicesAttribute:Xg,mergeMeshes:Zg,setCommonAttributes:Yg,trimToAttributes:qg});const Pv=new Zn(0,0,0,"YXZ"),Iv=new cn,Lv={type:"change"},Dv={type:"lock"},Nv={type:"unlock"},Ov=Math.PI/2;function Uv(t){if(!1===this.isLocked)return;const e=t.movementX||t.mozMovementX||t.webkitMovementX||0,n=t.movementY||t.mozMovementY||t.webkitMovementY||0,i=this.camera;Pv.setFromQuaternion(i.quaternion),Pv.y-=.002*e*this.pointerSpeed,Pv.x-=.002*n*this.pointerSpeed,Pv.x=Math.max(Ov-this.maxPolarAngle,Math.min(Ov-this.minPolarAngle,Pv.x)),i.quaternion.setFromEuler(Pv),this.dispatchEvent(Lv)}function Fv(){this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(Dv),this.isLocked=!0):(this.dispatchEvent(Nv),this.isLocked=!1)}function Bv(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}var zv=Object.freeze({__proto__:null,PointerLockControls:class extends ve{constructor(t,e){super(),this.camera=t,this.domElement=e,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,this._onMouseMove=Uv.bind(this),this._onPointerlockChange=Fv.bind(this),this._onPointerlockError=Bv.bind(this),this.connect()}connect(){this.domElement.ownerDocument.addEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this._onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this._onPointerlockError)}dispose(){this.disconnect()}getObject(){return this.camera}getDirection(t){return t.set(0,0,-1).applyQuaternion(this.camera.quaternion)}moveForward(t){const e=this.camera;Iv.setFromMatrixColumn(e.matrix,0),Iv.crossVectors(e.up,Iv),e.position.addScaledVector(Iv,t)}moveRight(t){const e=this.camera;Iv.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(Iv,t)}lock(){this.domElement.requestPointerLock()}unlock(){this.domElement.ownerDocument.exitPointerLock()}}});
